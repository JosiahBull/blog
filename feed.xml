
 <?xml version="1.0" encoding="utf-8"?>
   <feed xmlns="http://www.w3.org/2005/Atom">

     <title>Philippe Gaultier's blog</title>
     <link href="https://gaultier.github.io/blog"/>
     <updated>2023-12-15T11:40:58Z</updated>
     <author>
       <name>Philippe Gaultier</name>
     </author>
     <id>urn:uuid:9c065c53-31bc-4049-a795-936802a6b1df</id>
	
     <entry>
       <title>Getting started with Scheme by solving an Advent of Code 2018 challenge</title>
       <link href="/blog/advent_of_code_2018_5.html"/>
       <id>urn:uuid:b3c0c1c1-e36f-51fd-9356-99f8686e7329</id>
       <updated>2023-12-15T11:33:55Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/highlight.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/languages/scheme.min.js"></script>
<script>
window.addEventListener("load", (event) => {
  hljs.highlightAll();
});
</script>
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>Getting started with Scheme by solving an Advent of Code 2018 challenge</h1>
<p>I started learning <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> very recently. <a href="http://wiki.call-cc.org/">Chicken Scheme</a> is a wonderful small and
performant implementation of Scheme, a programming language in the family of
LISPs.
Since I learn by doing, let's solve the <a href="https://adventofcode.com/2018/day/5">Advent of Code 2018 day 5 challenge</a> with a tiny Scheme program.
I encourage you to check out <a href="https://adventofcode.com/2018/about">Advent of
Code</a> and try to solve the challenges yourself.</p>
<p>Many people have the feeling that LISPs are slow and cryptic with all those
parentheses. I hope to show that it is in fact very approachable, easy to work
with, and even fast to run!</p>
<p>I will not go through installing Chicken Scheme and learning the basics, because
it was <a href="http://blog.klipse.tech/scheme/2016/09/11/scheme-tutorial-1.html">already done better than I can</a>.</p>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#getting-started-with-scheme-by-solving-an-advent-of-code-2018-challenge">Getting started with Scheme by solving an Advent of Code 2018 challenge</a>
<ul>
<li><a href="#the-problem">The problem</a></li>
<li><a href="#working-with-the-repl-to-iteratively-close-in-on-a-solution">Working with the REPL to iteratively close in on a solution</a>
<ul>
<li><a href="#a-small-detour-pattern-matching">A small detour: pattern matching</a></li>
<li><a href="#using-pattern-matching-to-solve-our-problem">Using pattern matching to solve our problem</a></li>
</ul>
</li>
<li><a href="#the-final-solution">The final solution</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
<h2>The problem</h2>
<p>We have a string looking like this: <code>AabcdZZqQ</code> which represents a chain of
chemical units. Adjacent units of the same type (i.e letter) and opposite
polarity (i.e casing) react together and disappear.
It means we want to remove adjacent characters which are the same letter and have opposite casing, e.g
<code>Aa</code> and <code>qQ</code> disappear while <code>bc</code> and <code>ZZ</code> remain. Once we are finished, we have: <code>bcdZZ</code>.</p>
<p>The final output is the number of characters in the final string, i.e, <code>5</code>.</p>
<h2>Working with the REPL to iteratively close in on a solution</h2>
<p>First, let's define our input, which is a string:</p>
<pre><code class="language-scheme">(define input &quot;aAbxXBctTCz&quot;)
</code></pre>
<p>Later, we will read our input string from a file, but for now it is simpler to
just hard-code it.</p>
<p>Most functions in Scheme are immutable, meaning they do not
modify their arguments, they instead return a new item which is slightly different.</p>
<p>We could work with strings, but it turns out it is simpler to work with lists
instead in our case. We do not want to keep track of indices, risking doing off-by-one mistakes.
Also, LISPs are good at handling lists (LISP stands for LISt Processor), and
we'll that we can use pattern matching to make the code very concise. I am not
aware of pattern matching capabilities on string, so let's use lists:</p>
<pre><code class="language-scheme">(string-&gt;list input)
</code></pre>
<p>Here, the
<code>string-&gt;list</code> function just returns a list of characters for a string (in other
languages it is usually named <code>split</code>).</p>
<p>Now, we need to detect if two characters are the same latter, with opposite casing.
Let's write a <code>char-opposite-casing?</code> function to do just that. It will take 2
arguments, the letters we are inspecting, and will return a boolean.
For now, let's just make it always return true:</p>
<pre><code class="language-scheme">(define (char-opposite-casing? a b) #\t)
</code></pre>
<p>We only deal with ASCII, so it is safe to compare ASCII codes to detect casing.</p>
<p>What is the ASCII code of <code>A</code>? Let's try it by using the function <code>char-&gt;integer</code>:</p>
<pre><code class="language-scheme">(char-&gt;integer #\A) 
</code></pre>
<p>What about <code>a</code>?</p>
<pre><code class="language-scheme">(char-&gt;integer #\a)
</code></pre>
<p>So there is a difference of <code>32</code> between the same ASCII letter in lowercase and
uppercase. Peeking at <code>man ascii</code> in the terminal confirms this hunch for all
letters of the alphabet.</p>
<p>So, time to implement <code>char-opposite-casing?</code>:</p>
<pre><code class="language-scheme">(define (char-case-opposite-casing? a b)
  (let* ((a-code (char-&gt;integer a))
         (b-code (char-&gt;integer b))
         (diff (- a-code b-code)))
    (= (* 32 32) (* diff diff))))
</code></pre>
<p>Let's try it with <code>a</code> and <code>A</code>:</p>
<pre><code class="language-scheme">(char-case-opposite-casing? #\a #\A) 
</code></pre>
<p>And flipped:</p>
<pre><code class="language-scheme">(char-case-opposite-casing? #\A #\a)
</code></pre>
<p>And <code>A</code> and <code>b</code>:</p>
<pre><code class="language-scheme">(char-case-opposite-casing? #\A #\b)
</code></pre>
<p><code>let*</code> is used to define local bindings which are only visible in this function.
It evaluates each binding in order which means we can define <code>diff</code> in terms of
<code>a</code> and <code>b</code> (contrary to <code>let</code>).</p>
<p>We could have done without it but it makes the function more readable.</p>
<p>The only hurdle is not caring
about the sign of the difference: if the difference is <code>32</code> or <code>-32</code>, it is the
same. We could compare the absolute value, but I (arbitrarily) chose to implement it without
branches, by comparing the squared values (which swallows the signs).</p>
<hr />
<p>Now let's work on the central problem: how to remove
characters in a list, in a functional, immutable way?</p>
<p>The idea is to write a recursive function taking two arguments: an accumulator
(let's call it <code>acc</code> from now on),
which will be eventually the end result, and the input list (<code>input</code>), from which we
gradually remove items until it is empty. We can view the first list as the work
we have done, and the second list as the work to do.</p>
<p>Let's first define the function. For now, it just returns the empty list:</p>
<pre><code class="language-scheme">(define (chem-react acc input)
  '())
</code></pre>
<p>At first, the accumulator is the empty list, so we will always call our function like
this:</p>
<pre><code class="language-scheme">(chem-react '() (string-&gt;list input))
</code></pre>
<p>It is import to know that most list functions do not work on the empty list in
Chicken Scheme. For example, to get the first element of a list, we use the <code>car</code> function:</p>
<pre><code class="language-scheme">(define my-list (list 1 2 3))

;; Note that this doest **not** mutate `my-list`
(car my-list)
</code></pre>
<p>But it won't work on the empty list:</p>
<pre><code class="language-scheme">(define my-list '())

(car my-list)
</code></pre>
<p>So we need to treat the case of the empty list (both for the first and the
second argument) explicitly. We could do that by using lots of <code>if</code>, but it is
more readable and concise to use pattern matching.</p>
<h3>A small detour: pattern matching</h3>
<p>Scheme has a minimalist core, so we do not get pattern matching out of
the box, but we can easily add it with the package <code>matchable</code>. Let's install
it in the terminal:</p>
<pre><code class="language-sh">$ chicken-install matchable
</code></pre>
<p>Now we can import it at the top of our code:</p>
<pre><code class="language-scheme">(import matchable)

;; At this point we can refer to any function in this module `matchable`.
;; No need to prefix them either with `matchable`.
</code></pre>
<p>Let's try to match the empty list in our function, and return (as an example) a
number, e.g <code>42</code>. We also want to match the case of both lists containing one
element, and returning the sum of those 2 elements:</p>
<pre><code class="language-scheme">(define (chem-react acc input)
  (match (list acc input)
    [(_ ()) 42]
    [((a) (b)) (+ a b)]))

(chem-react '() '()) ;; =&gt; 42

(chem-react (list 2) (list 3)) ;; =&gt; 5
</code></pre>
<p>A few interesting things here: <code>_</code> allows us to match anything, so the first
case is equivalent to checking if the second list is
empty. Additionally, we can bind variables to our patterns: we do that in the
second case, binding the first element of the first list to <code>a</code>, and the fist
element of the second list to <code>b</code>, and summing the two.</p>
<p>Note that not all possible cases are covered here, and we will get a (runtime)
error if we trigger one of them, for example with a list containing several numbers:</p>
<pre><code class="language-scheme">(chem-react (list 1 2) (list 3)) ;; =&gt; Error: (match) &quot;no matching pattern&quot;: ()
</code></pre>
<p>Let's go ahead and match the case of a list of one or more elements (<code>(a . arest)</code>) to avoid that:</p>
<pre><code class="language-scheme">(define (chem-react acc input)
  (match (list acc input)
    [(_ ()) 42]
    [((a) (b)) (+ a b)]
    [((a . arest) (b . brest)) (* a b)]))

(chem-react (list 2 3) (list 4)) ;; =&gt; 8
</code></pre>
<p>Here we choose to (arbitrarily) return the product of the first elements of both
list, to show that pattern matching is also a way to do destructuring.</p>
<h3>Using pattern matching to solve our problem</h3>
<p>If the second list (the input) is empty, it means we are
finished, so we return the first list (<code>acc</code>):</p>
<pre><code class="language-scheme">(define (chem-react acc input)
  (match (list acc input)
    [(_ ()) acc]))
</code></pre>
<p>Our recursion will work as follows: we look at the first element of the second
list (<code>input</code>, which is the work to do), let's call it <code>b</code>, and the first element of the first
list (<code>acc</code>, the work done), let's call it <code>a</code>.</p>
<p>If <code>a</code> and <code>b</code> are the same letter of opposite casing, we 'drop' the two. Otherwise, we
add <code>b</code> to the first list, and 'continue'. 'drop' and 'continue' are put in
quotes because that is vocabulary from imperative languages such as C; we'll see
in a minute how we implement it in a functional way.</p>
<p>If the first list is empty, this is our starting case: the only thing we can do
is mark <code>b</code> as 'processed', i.e add it to the first list, and call ourselves
with the remainder of <code>input</code>. Indeed, we can only work with two characters, so
if we only have one, we cannot do much.</p>
<p>It's time to learn about a new function: <code>cons</code>. <code>cons</code> just adds an item to a list, and
returns the new list with the added item:</p>
<pre><code class="language-scheme">(define my-list (list 2 3))

;; Note: `my-list` is **not** modified
(cons 1 my-list) 
</code></pre>
<p>We can now use <code>cons</code> to implement the new case:</p>
<pre><code class="language-scheme">(define (chem-react acc input)
  (match (list acc input)
    [(_ ()) acc]
    [(() (b . brest)) (chem-react (cons b acc) brest)]))


(chem-react '() '(#\A)) ;; =&gt; (#\A)
</code></pre>
<p>This new pattern is required for the recursion to
work, but it also covers the trivial case of an input string of only one character.</p>
<p>Now, let's treat the main case: we have at least an element <code>a</code> in <code>acc</code> and at
least an element <code>b</code> in <code>input</code>. If they are the same letters of opposite casing, we
call ourselves with the remainder of <code>acc</code> and the remainder of <code>input</code>, which
is equivalent to 'drop' <code>a</code> and <code>b</code>. Otherwise, we add <code>b</code> to <code>acc</code>, and we call
ourselves with the remainder of <code>input</code>, which is the equivalent of 'continuing':</p>
<pre><code class="language-scheme">(define (chem-react acc input)
  (match (list acc input)
    [(_ ()) acc]
    [(() (b . brest)) (chem-react (cons b acc) brest)]
    [((a . arest) (b . brest)) (if (char-case-opposite-casing? a b)
                                   (chem-react arest brest)
                                   (chem-react (cons b acc) brest))]))


(chem-react '() (list #\A #\a #\b)) ;; =&gt; (#\b)
(chem-react '() (string-&gt;list &quot;aAbxXBctTCz&quot;)) ;; =&gt; (#\z)
</code></pre>
<p>But wait a minute...Doesn't it look familiar? Yes, what we are doing here is a
fold (sometimes called reduce)!</p>
<p>Let's replace our custom recursion by <code>fold</code>. <code>chem-react</code> becomes the reduction
function. It becomes simpler because <code>fold</code> will not call it on the empty list,
so we only need to patter match <code>acc</code> (which is the empty list at the beginning):</p>
<pre><code class="language-scheme">(define (chem-react acc x)
  (match acc
    [() (cons x acc)]
    [(a . arest) (if (char-case-opposite-casing? a x)
                     arest
                     (cons x acc))]))


(foldl chem-react '() input) ;; =&gt; (#\z)
</code></pre>
<p>My experience writing code in a LISP is that I usually find a solution that is
relatively big, and I start replacing parts of it with standard functions such
as <code>fold</code> and it ends up very small.</p>
<blockquote>
<p>How do I read the input from a file?</p>
</blockquote>
<p>It's quite simple: we use the modules <code>chicken.file.posix</code> and <code>chicken.io</code>:</p>
<pre><code class="language-scheme">(import chicken.file.posix
        chicken.io)

(read-line (open-input-file &quot;/Users/pgaultier/Downloads/aoc5.txt&quot;)) ;; =&gt; &quot;a big string...&quot;
</code></pre>
<h2>The final solution</h2>
<p>Here I use the package <code>clojurian</code> (<code>chicken-install clojurian</code>) to have access
to the <code>-&gt;&gt;</code> macro which makes code more readable. It works like the pipe in the
shell. Instead of writing:</p>
<pre><code class="language-scheme">(foo (bar &quot;foo&quot; (baz 1 2)))
</code></pre>
<p>We write:</p>
<pre><code class="language-scheme">(-&gt;&gt; (baz 1 2)
     (bar &quot;foo&quot;)
     (foo))
</code></pre>
<p>The macro reorders the functions calls to make it flat and avoid nesting.
It is not strictly required, but I like that my code looks like a
pipeline of data transformations.</p>
<p>The final code:</p>
<pre><code class="language-scheme">(import matchable
        clojurian.syntax
        chicken.file.posix
        chicken.io)

(define (char-case-opposite-casing? a b)
  (let* ((a-code (char-&gt;integer a))
         (b-code (char-&gt;integer b))
         (diff (- a-code b-code)))
    (= (* 32 32) (* diff diff))))

(define (chem-react acc x)
  (match acc
    [() (cons x acc)]
    [(a . arest) (if (char-case-opposite-casing? a x)
                     arest
                     (cons x acc))]))

(-&gt;&gt; (open-input-file &quot;/Users/pgaultier/Downloads/aoc5.txt&quot;)
     (read-line)
     (string-&gt;list)
     (foldl chem-react '())
     (length)
     (print))
</code></pre>
<blockquote>
<p>But we will get a stack overflow on a big input!</p>
</blockquote>
<p>Scheme has a nice requirement for all implementations: they must implement
tail-call optimization, which is to say that the compiler can transform our function into an
equivalent for-loop. So we won't get a stack overflow, and it will be quite
efficient in terms of memory and time.</p>
<blockquote>
<p>But we are making thousands of copies, it will be slow as hell!</p>
</blockquote>
<p>Let's benchmark it on the real input (50 000 characters), with <code>-O3</code> to enable optimizations:</p>
<p><em>Note 1: The real output of the program is not shown to avoid spoiling the final result</em></p>
<p><em>Note 2: This is a simplistic way to do benchmarking. A more correct way would
be: warming up the file cache, making many runs, averaging the results, etc.
I did exactly that and it did not change the results in a significant manner.</em></p>
<pre><code class="language-sh">$ csc aoc5.scm -o aoc5 -O3 &amp;&amp; time ./aoc5
./aoc5  0.01s user 0.00s system 82% cpu 0.021 total
</code></pre>
<p>It takes 21 milliseconds. Not too bad for a garbage collected, functional,
immutable program.</p>
<p>Here is a hand-written C version which only does one allocation and removes
letters in place:</p>
<pre><code class="language-c">#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

int main() {
  int fd = open(&quot;/home/pg/Downloads/aoc2020_5.txt&quot;, O_RDONLY);
  if (fd == -1)
    return errno;

  struct stat st = {0};
  if (stat(&quot;/home/pg/Downloads/aoc2020_5.txt&quot;, &amp;st) == -1)
    return errno;

  int64_t input_len = st.st_size;
  char *const input = calloc(input_len, 1);

  if (read(fd, input, input_len) != input_len)
    return errno;

  while (input[input_len - 1] == '\n' || input[input_len - 1] == ' ')
    input_len--;

  int64_t i = 0;
  while (i &lt; input_len) {
    if (abs(input[i] - input[i + 1]) == 32) {
      memmove(input + i, input + i + 2, input_len - i - 2);
      input_len -= 2;
      i = i &gt; 0 ? i - 1 : 0;
    } else
      i++;
  }

  printf(&quot;`%zu`\n&quot;, input_len);
}
</code></pre>
<p>Let's benchmark it on the same input:</p>
<pre><code class="language-sh">$ cc -std=c99 -O3 -Weverything aoc5.c -march=native &amp;&amp; time ./a.out
./a.out  0.01s user 0.00s system 86% cpu 0.012 total
</code></pre>
<p>It took 12 milliseconds. So the scheme version is very close, and takes an
acceptable amount of time.</p>
<blockquote>
<p>Can't we use strings and not lists?</p>
</blockquote>
<p>Yes, of course. However we need to be careful about how strings are implemented
and what we we do with those. Most runtimes (e.g the JVM) use immutable strings,
meaning we could end up allocating thousands of big strings, and being quite slow.</p>
<h2>Conclusion</h2>
<p>That's it, we solved the fifth Advent of Code challenge in Scheme. The solution
is under 30 lines of code, is (hopefully) simple and readable, and has a
performance close to C, while having memory safety (I had several segfaults
while doing the C version).</p>
<p>But more than that, I think the real value in LISPs is
interactive programming, instead of the classical write-compile-execute-repeat,
which is much more time consuming. It is really important to get feedback as
early as possible, and LISPs give us that.</p>
<p>I hope it gave you a glance at what Scheme can do, and stay tuned for more blog
posts about programming. I intend to post more solutions to other coding
challenges, solved with a variety of programming languages.</p>
<blockquote>
<p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&amp;locale.x=en_US">Donate</a></p>
</blockquote>
</div>
</body>
</html>

]]>
    </content>
     </entry>

     <entry>
       <title>Optimizing an Advent of Code solution in assembly</title>
       <link href="/blog/advent_of_code_2018_5_revisited.html"/>
       <id>urn:uuid:371c9129-162e-5d69-af73-c3263a2f7e47</id>
       <updated>2023-12-13T16:37:47Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/highlight.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/languages/x86asm.min.js"></script>
<script>
window.addEventListener("load", (event) => {
  hljs.highlightAll();
});
</script>
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>Optimizing an Advent of Code solution in assembly</h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#optimizing-a-solution-for-advent-of-code-2018-challenge-in-assembly">Optimizing a solution for Advent of Code 2018 challenge in
assembly</a>
<ul>
<li><a href="#the-new-solution">The new solution</a></li>
<li><a href="#the-x86_64-implementation">The x86_64 implementation</a></li>
<li><a href="#benchmarking">Benchmarking</a></li>
<li><a href="#learnings">Learnings</a></li>
<li><a href="#appendix-the-full-code">Appendix: The full code</a>
<ul>
<li><a href="#the-old-c-implementation">The old C implementation</a></li>
<li><a href="#the-x64-implementation">The x64 implementation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>If you spot an error, please open a <a href="https://github.com/gaultier/blog">Github issue</a>!</em></p>
<hr />
<p>A few days ago I was tweaking the appearance of this blog and I stumbled upon my <a href="/blog/advent_of_code_2018_5">first article</a> which is about solving a simple problem from Advent of Code. Here it is again:</p>
<blockquote>
<p>We have a string looking like this: <code>AabcdZZqQ</code> which represents a chain of
chemical units. Adjacent units of the same type (i.e letter) and opposite
polarity (i.e casing) react together and disappear.
It means we want to remove adjacent characters which are the same letter and have opposite casing, e.g
<code>Aa</code> and <code>qQ</code> disappear while <code>bc</code> and <code>ZZ</code> remain. Once we are finished, we have: <code>bcdZZ</code>.</p>
<p>The final output is the number of characters in the final string, i.e, <code>5</code>.</p>
</blockquote>
<p>Immediately, I thought I could do better than my past self:</p>
<ul>
<li>In the Lisp solution, there are lots of allocations and the code is not straightforward.</li>
<li>In the Lisp solution, we use multiple external dependencies, which usually turn out to be problematic in the long run.</li>
<li>In the C solution, there is no allocation apart from the input but we do a lot of unnecessary work.</li>
<li>In the C solution, we use <code>abs(x) == 32</code> which we could avoid by doing <code>x*x == 32*32</code>.</li>
</ul>
<p>This coincided with me listening to an interview from the VLC developers saying there wrote hundred of thousand of lines of (multi platform!) Assembly code by hand in their new AV1 decoder. I thought that was intriguing, who still writes assembly by hand in 2023? Well these guys are no idiots so I should try it as well.</p>
<h2>The new solution</h2>
<p>I came up with a new algorithm, which on paper does less work. It's one linear pass on the input, and does not allocate.</p>
<p>Since the result we care about is the number of remaining characters, we simply keep track of the count as we sift through the input.</p>
<p>We maintain two pointers, <code>current</code> and <code>next</code>, which we compare to decide whether we should merge the characters they point to. 'Merging' means setting the two characters to <code>0</code> (it's basically a tombstone) and lower the count.</p>
<p><code>next</code> is always incremented by one in each loop iteration, that's the easy one.</p>
<p><code>current</code> is always pointing to a character before <code>current</code>, but not always directly adjacent, because there may be tombstones, i.e. zeroes, in-between.</p>
<p>In pseudo-code:</p>
<pre><code>remaining_count = len(input)
end = input + len(input)
current = &amp;input[0]
next = &amp;input[1]

while next != end:
    diff = *next - *current

    if diff*diff == 32*32:
      *current = 0
      *next = 0
      remaining_count -= 2

      current -= 1
      while current == 0:
        current -= 1
      endwhile
    else:
      current = next
    endif

 next += 1
    
endwhile

print(remaining_count)

</code></pre>
<p>The easy case is when there is no need to merge: <code>current</code> simply becomes <code>next</code> (and <code>next</code> is incremented at the end of the loop iteration).</p>
<p>The 'hard' case is merging: we set the two tombstones, lower the count, and now we are in a pickle: <code>current</code> needs to go backwards, but we do not know to where. There might be an arbitrary number of zeroes preceding the character <code>current</code> points to: the data on the left of <code>next</code> is sparse, the data on the right of <code>next</code> is not.</p>
<pre><code>[...] 0 0 A 0 0 0 0 B 0 0 0 0 C D E F [...]
          ^         ^         ^
          |         |         |
          target    |         |
                    current   |
                              next
</code></pre>
<p>So we have to do a backwards search to find the first non zero character.
We could memoize this location, but that would basically come down to the Scheme solution, having an output array of the same size as the input.</p>
<p>Astute readers might have noticed a potential issue with the backwards search: We may underflow the <code>input</code> and go out of bounds! To avoid that, we could clamp <code>current</code>, but the branch misprediction is costly (an earlier implementation of mine did this and that was almost twice as slow!), and we can simplify the code as well as improve the performance by simply prefixing the <code>input</code> with a non-zero value that has no chance of being merged with the rest of the input, say, <code>1</code>.</p>
<p>Let's implement it in x86_64 assembly!</p>
<h2>The x86_64 implementation</h2>
<p><em>For a gentle introduction to x64 assembly, go read an <a href="/blog/x11_x64.html">earlier article</a> of mine.</em></p>
<pre><code class="language-x86asm">BITS 64
CPU X64

%define SYSCALL_EXIT 60
%define SYSCALL_WRITE 1

section .data


prefix: db 1
input: db &quot;xPGgpXlvVLLP...&quot; ; Truncated for readability
static input:data

%define input_len 50000

section .text

exit:
static exit:function
  mov rax, SYSCALL_EXIT
  mov rdi, 0
  syscall

solve:
static solve:function
  push rbp
  mov rbp, rsp

  ; TODO

  pop rbp
  ret

global _start
_start:
  call solve
  call exit
</code></pre>
<p>We circumvent reading the input from a file and embed it directly in our code, something many people having their hand at Advent of Code challenges do. It is in the <code>data</code> section and not in the <code>.rodata</code> section because we are going to mutate it in place with the tombstones.</p>
<p>We also have to exit the program by ourselves since there is no libc, and we create a <code>solve</code> function which will have our logic.</p>
<p>We compile and run it so (on Linux, other OSes will be similar but slightly different):</p>
<pre><code class="language-shell">$ nasm -f elf64 -g aoc2018_5.asm &amp;&amp; ld.lld aoc2018_5.o -static -g -o aoc2018_5
$ ./aoc2020_5
</code></pre>
<p>Which outputs nothing for now, of course.</p>
<hr />
<p>We will need to print the <code>remaining_count</code> to <code>stdout</code> at the end so we add a function to do so:</p>
<pre><code class="language-x86asm">write_int_to_stdout:
static write_int:function
  push rbp
  mov rbp, rsp

  sub rsp, 32

  %define ARG0 rdi
  %define N rax
  %define BUF rsi
  %define BUF_LEN r10
  %define BUF_END r9

  lea BUF, [rsp+32]
  mov BUF_LEN, 0
  lea BUF_END, [rsp]
  mov N, ARG0

  .loop:
    mov rcx, 10 ; Divisor.
    mov rdx, 0 ; Reset rem.
    div rcx ; rax /= rcx

    add rdx, '0' ; Convert to ascii.

    ; *(end--) = rem
    dec BUF_END
    mov [BUF_END], dl
    
    inc BUF_LEN

    cmp N, 0
    jnz .loop

  mov rax, SYSCALL_WRITE
  mov rdi, 1
  mov rsi, BUF_END
  mov rdx, BUF_LEN
  syscall


  %undef ARG0
  %undef N
  %undef BUF
  %undef BUF_LEN
  %undef BUF_END

  add rsp, 32
  pop rbp
  ret
</code></pre>
<p>I am trying a new style of writing assembly which I saw notably the Go developers use: Since the biggest problem is that we have no named variables, we leverage the macro system from <code>nasm</code> to name the registers we work with in a human readable fashion.</p>
<p>Our <code>solve</code> function can now return a dummy number and we can print it out by passing the return value (in <code>rax</code>) of <code>solve</code> as the first argument (in <code>rdi</code>) of <code>write_int_to_stdout</code>:</p>
<pre><code class="language-x86asm">solve:
static solve:function
  push rbp
  mov rbp, rsp

  mov rax, 123

  pop rbp
  ret

global _start
_start:
  call solve

  mov rdi, rax
  call write_int_to_stdout

  call exit
</code></pre>
<hr />
<p>We now can focus on implementing <code>solve</code>. It's a one to one translation of the pseudo-code. We just have to judiciously choose which registers to use based on the x64 System V ABI to avoid bookkeeping work of saving and restoring registers. For example, we use <code>rax</code> to store <code>remaining_count</code> since this will be the return value, so that we do not have to do anything special at the end of the function.</p>
<p>Another pitfall to be aware of is that since we are dealing with ASCII characters, we could use the 8 bit form of the registers. However, some opcode such as <code>imul</code> are not usable with these. We have to use the 16, 32, or 64 bit form. This does not compile:</p>
<pre><code class="language-x86asm">  mov dl, 2
  imul dl, dl
</code></pre>
<p>But this does:</p>
<pre><code class="language-x86asm">  mov dx, 2
  imul dx, dx
</code></pre>
<p>And so we need to zero extend the 16 bit registers in some locations with <code>movzx</code> to fill the remainder of the register with zeroes. Forgetting to do so will lead to very nasty, obscure bugs.</p>
<p>Finally, we always write loops in the form of <code>do { ... } while(condition)</code>. This is easier in our case; we assume (and know) the input is not empty, for example.</p>
<p>Here we go. Note that this function does not need any stack space, since we modify the input in place, and the standard registers are enough to store the few values we keep track of:</p>
<pre><code class="language-x86asm">solve:
static solve:function
  push rbp
  mov rbp, rsp

  %define INPUT_LEN r10
  %define CURRENT r9
  %define NEXT r11
  %define REMAINING_COUNT rax
  %define END r8

  lea CURRENT, [input] 
  lea NEXT, [input + 1] 
  mov INPUT_LEN, input_len
  mov REMAINING_COUNT, INPUT_LEN
  lea END, [input]
  add END, INPUT_LEN
  

.loop:
  movzx dx, BYTE [CURRENT]
  movzx cx, BYTE [NEXT]
  sub dx, cx
  imul dx, dx

  mov rcx, 32*32

  cmp rdx, rcx
  jnz .else
  .then:
    mov BYTE [CURRENT], 0
    mov BYTE [NEXT], 0

    sub REMAINING_COUNT, 2

    .reverse_search:
    dec CURRENT
    mov dl, [CURRENT]
    cmp dl, 0
    jz .reverse_search


    jmp .endif
  .else:
    mov CURRENT, NEXT
  .endif:

  inc NEXT
  cmp NEXT, END
  jl .loop

  %undef INPUT_LEN
  %undef CURRENT
  %undef NEXT
  %undef REMAINING_COUNT
  %undef END


  pop rbp
  ret
</code></pre>
<h2>Benchmarking</h2>
<p>So, did it work? Is it fast? Let's compare the old C solution (also embedding the input data for a fair comparison) with our new Assembly one:</p>
<pre><code class="language-sh">$ clang -Ofast -g3 -march=native aoc2018_5.c -o aoc2018_5-c
$ hyperfine --warmup 3 --shell=none ./aoc2018_5 ./aoc2018_5-c

Benchmark 1: ./aoc2018_5
  Time (mean ± σ):       2.7 ms ±   1.0 ms    [User: 2.4 ms, System: 0.1 ms]
  Range (min … max):     1.2 ms …   4.6 ms    1174 runs
 
Benchmark 2: ./aoc2018_5-c
  Time (mean ± σ):       5.3 ms ±   1.4 ms    [User: 5.0 ms, System: 0.2 ms]
  Range (min … max):     4.1 ms …  10.4 ms    442 runs
 
Summary
  './aoc2018_5' ran
    1.95 ± 0.86 times faster than './aoc2018_5-c'
</code></pre>
<p>Yes, indeed, almost twice as fast!</p>
<h2>Learnings</h2>
<ul>
<li>Assembly can absolutely be written by hand, although with (much) more effort and a harder time troubleshooting what goes wrong.</li>
<li>Some tools (profilers, reverse-engineering tools) expect that the assembly they consume came from a C source file and will be confused when it's not the case.</li>
<li>There is no need to reach for esoteric, vendor specific instructions (such as SIMD or Intel string opcodes) to go fast and even beat a C implementation that does a bit more work than necessary.</li>
<li>Doing less work is the most important thing when optimizing.</li>
<li>At the same time, doing a bit of work instead of memoizing can be fast(er), even though it seems counter-intuitive, due to memory latency and cache misses.</li>
<li>Having a clear idea in pseudo-code of the solution will simplify the implementation in any language.</li>
<li>Naive assembly is very fast (your CPU is crazy fast when you do not abuse it with badly written interpreted languages, seriously!), but a good compiler will emit better assembly than you if you write C or similar. Unless you are an expert like the VLC guys.</li>
</ul>
<blockquote>
<p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&amp;locale.x=en_US">Donate</a></p>
</blockquote>
<h2>Appendix: The full code</h2>
<h3>The old C implementation</h3>
<pre><code class="language-c">#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

static char input[] =
    &quot;xPGgpXlvVLLPplNSiIsWwaAEeMmJjyYfFWfFwpPqcCYvVySsAUuaCcDdHlLSshxKkMmXQnNKkr&quot;
    &quot;RptBbTqQEevKkkKVsSmMmMvqFfGFSsfZzgQTtFLlfsSFBTtbfbBiIAHhzZaVNbBOonsfFSBYGg&quot;
    &quot;RryvaAVTtbFfqaAEetqQUubBTyYAWwzZeENRrgGaAfFnNnpPJjulLEeUaQqnNJjQtTPTaqQAoO&quot;
    &quot;EerRtnVaALlhDdPpHvvVrRsFVvfsMcCvkPZzpKbBOofZzyYFzZsAjJavGgkKRrVwWSYygFfGLr&quot;
    &quot;RLlgGlVaAXZzHuULDpPdoOlhgGVoOKkVvaAhOoHIiBNnxsSXbBbvVFfvtTUvVlaALPptTGguPp&quot;
    &quot;jJFmRrMqjJOOqQZzooQRVvrKkpVvPOopPKKbBkYykYQqPpPpoKkOihHIECcJjeyvsSVpbBPGKk&quot;
    &quot;gfVvHhiIvGgViXxlLdDIgGKMCncCNcmfFDDdSsXxqQtTaAdenNdDVvPuUpVvtTZzEQqyoOvVTx&quot;
    &quot;XtbBnDdcCZWwrRzNaeEAlDZzeEdJlelLEzZhHhOoHYyKkLjWwNnLAjJaiHhIvhHHhEhHeSsSKk&quot;
    &quot;sXxVvzZEevVzpliIRPprLPcOHhsSoRSsTtrlLCiISsJjMmZvnNoOVclLCVzZMmKhHkqWufFmMS&quot;
    &quot;mMkKsiFfoRrOIUozZyYNnSNnqQsTrRtSHhNniIbGgCcnNBxXSFYyWwfgFRrfaROorAsxXSGsSK&quot;
    &quot;BbkspPIeoOHhEiXxVvpPUfFuyYypPynNYpPSskdDKjJCeErRtxXTHIzjJZihoOZvoOGfFWwgVz&quot;
    &quot;CUuaXxAeEnBVvbNiIAaRdDxXrmMcgCyYceyYyYEEMmgWwGOoKkqQkeEVvGgrRJjrYyEeRKYyOP&quot;
    &quot;ZzJjpooOcCrgGtTOoRNneHiIXxnNIQqzZiHhZgGZzyYeEuUOmMbZzUjaAJuPpBozZzlfFLiIph&quot;
    &quot;HsvVSvVUTtuDdPhPVDdPpvYyvDgGCcdTSstaHhcCHhAJgGLOOoaARVCclgGLvrsSolAPpUuaXx&quot;
    &quot;aAkoOPpeEzGgZcCjJHhKkKlYUuyMQIiqSiqQBbIsGLLGgvWwTtVlpyTtYgAaGPSeEfFsDdgGkV&quot;
    &quot;bBNnvQrLlRqYWwyEqQLlsSSVvstTghHGeKkKQqhHHhmMoYyhsSAaHdDuUKkOMmDdMmgGgQqRnN&quot;
    &quot;TtVvryYlDdrnNLlRUcCurRgGZuUWwMmbBTtjJzjJbBdDaAwWLjJKDpPpcCDdHhPRrhHRzjeEJZ&quot;
    &quot;mMcNfVvlLvtTVSsxXFnVvTxtTKkjkAaKhzZxXfFHuBbkKTeEyrRcCYTtGgtuZDdjJzUUcSsCqQ&quot;
    &quot;gGuUqUulLRrwWQeHOohSXxNnisSIWHhwiuUIfFVMxUaAuGdDgXmdHhDUuTFWwftbBvVKAakvrq&quot;
    &quot;QAayYWwRCcIvVijJhHrSNnsDaAdBbHLlhRPpAqZzQSsaQmOpPozQLlqhHZIDdisdDSyFpPfEJj&quot;
    &quot;eYowWhHrnNRRUuhHLeEdDlkKyYkKqQCcEexXifFIYfFqQyFzDdZcCorRgGzqQZDdzIiMmwWrRI&quot;
    &quot;IjJihlLHoOyYDzrRuUKbBvMmeEKkFffFsSVcYJuUjQqMHEeeEhbBYyucCfFGDdqQRmMHhhHqWw&quot;
    &quot;oOQTtrBhHxXCcbggGGpgGPgEecCYyEeEesSisSeOovVcwWCEIPJjnlLTtyYNLtfFHzZQCcqLly&quot;
    &quot;xXYSqvGgVQzZsBvVDoOdlLbfFGxphHqQPHhmMdDGgHszjJZShXxXYysbBifrRFiIxcChIiHgGQ&quot;
    &quot;qqvVbBEewWQxjJZmPpUuMzXlYyHhLXDvVBbdEsSexsSvtTrReEVnNmMTtXuKkjxXJMyYmZFfzU&quot;
    &quot;MmyVvTtFfYdDExEeXvVooOOjJTtCcUrRSwWsbBbhHtTBGVvgNDdnQqukKGgJOYHFfhKfFkSnNk&quot;
    &quot;KOoOohHsSnNsmmMMvVFGglHxXhLfFPsKkSpfyBbqQqaxXfpPZzbBCggGdDPlBbLaAZzKeEkYJi&quot;
    &quot;IemMtYyTlLjJEjXxsSyLlXxCckKeEuUZzrqQlLxXafFeEVvAiRrIRpmiRrFfbBzZvHhVICcoOM&quot;
    &quot;XxiWwNIinkkKBbgQqGPpLlKWhHwszZSQuUjKkfFJcZzCVvWeEYywtXxTjJzZkSsKfFeEcCrDhX&quot;
    &quot;xMmrRjUuOoYyJQDdqHwWMmLlOodqQMmqGCcgwWpJjqMmQKkPMmpPBbxnNzZyYySscTcCFftwWO&quot;
    &quot;eEoOobSsBSsOoaAGoOgRWwcQUWOokKwuTdUuDtYyYiJjYyIyquqaFfwWAQUZtKkTBbzndDXxjJ&quot;
    &quot;LlJjyxWjJDdLlsSMmGgtiGgIqQpgGTtDdPClLAasyYFlLKoOkfMmFUuBEerRYyGflLFDdnNFfg&quot;
    &quot;FLlXJjxWHhwDOoOodOokKPpMmfoOzZupPUvVjJSBRrbYLlyuUNTXxnNtUuvVVvpPQqQqUuaqQA&quot;
    &quot;lLMBbHhxOfFozZJjXzZhHgqQEPpeVvSsEgGAaeUucCItTiLuUlGSsyYEeRrBbZiIAPpvRrhHzq&quot;
    &quot;EeQqvVBbGgIhHRXxrishHSQNnyYZzxXZpdDPVWXxwMvVmmMByYcCaAEebxXVvKfFlLcCcCkZzz&quot;
    &quot;QqGgFIifPpZNnjJMwsSWwRrWmvHosSOhVIibMmyYQqTtBMoOYOoSsZFKuUkKZzZzxXPpbqAanN&quot;
    &quot;NnQyYsZzShHUuGgSiIsYgGyeeECcsAadGgDOojqQGgSstTPpJSQRrGgUunNqpkKdDZzPhHkSsr&quot;
    &quot;RQwtTXyYxsSZzAaRcUgGvVufNSfFsnFCrXeogGWwQqlLOKbBuUkvWwzZUuEoOKkNneseECcwWw&quot;
    &quot;zbBWiIwDQqdAawWiIwWNnLiQDdqIAatTEOdDoeVkOopPKvQmbBKkvVbyhHYBWwbzZrQqRZDdhp&quot;
    &quot;CcOoXxnayYizZIFfANPKkeELKDdHhvyYVCckkvVKTAadDsSHhAjBbeQqEJpPaJjXxaAAFfXxRr&quot;
    &quot;VpuFWwWwfFoOZRrzPpxHJjhIqQiXfrRkKkKkNnLlKqhhHLNWWKkwwZznvOIioMwWXxeEmYyzZX&quot;
    &quot;cCxVZzmMUuPKYykKyYkpiIlSAaYcCyBCwDwWdWPpcbsghHnNbBsSMlLbBTpPtEeVuUZzfciICE&quot;
    &quot;mMMfFmlLeuwWoOnNUgGJjiybBCJZziZzAaIjQqhHCcaAcnGgjUuPpQqpPhXxHUjJuuxNnXUYyJ&quot;
    &quot;CcLOoImMilBbLlkKGkKPwWEeuUzZHoOqQjJFfGgCckBbKzlwKpQqsSsSViIIirRvbBiZzIZipl&quot;
    &quot;xXLPTjnNJVpPyYvtDyYwqQWdYyarRxXDdALlIDdTtTcClZyYzvVRvVrLtmMkKvTDdxXtVqQlVv&quot;
    &quot;LPNnpoaAdDeELUwWuwxXWlOxXGgiaAITtgGyYuUzZdDynNYGwzZPkqQOoKklLxBbdQqDGyYgXK&quot;
    &quot;zHhRDhHdWzZwbBhvYyVHLHXxhlcaACIidDVbjJxeMmEXJBbtTjBVDdpPsNnSvrRbbBMmyoBbON&quot;
    &quot;nwWJTtOoQqIiVhsSHLlQqHhXxAoOHhTjCcJwWLltFfetTEFWwtTIyYiYyzZvVzZTOobchHCBQS&quot;
    &quot;iIsBbRDAamMJZzjoOJjyYIidHhQqOuUWwOovIiuUCcVoWPhHpwdDJjIvTufFUtWQqvVuUXxwtT&quot;
    &quot;iIVisqyYQiISHLjJGkKcCBAabhHiIKkWCcwpPcChfFHCnNlLcZSBbfFbBgwWzWwZaAZIizGcCm&quot;
    &quot;SsGxpNnPXQhHgGgGFfuJRraAjOouaUuTtAbRBbrjJlUtuUEeTCcwxXrROioZreOlnncKXxkCNK&quot;
    &quot;ZzaAkpKkRcCrRVvrPNuULfCcxdZzDZvVCfFsUuSreFdDafFAfqQWPpTeINniEBArbBRaeJjEbZ&quot;
    &quot;nNsSFflLzZztsPpEeBbwQqwWGgQqoOFfZzWnNSyYsXKkxWwKkkcCONnoNVvGgXxFuQqUkKfjJY&quot;
    &quot;yFeGgEcCnNFfLldyikbiIBhHKjOoJaAIYpPIMmHLlhibBIaJjyrRYbBjJAaASsVvFuUfTMNTtn&quot;
    &quot;nNmFfqQBbJOoCcXIhHgGCciTtSBMiImBYybxLgGlwWXNljuUJjJbBdDyYhHLQqxXmtTMwWqQnx&quot;
    &quot;XWwzSsmMkBbJjeRrsSEDdTtGAagXxKeEJjwuUDdpPdDWTCcKktjmMJjlLXybBYnNMmwoOfTtix&quot;
    &quot;XjJDduMmdzZJjclLqiIQciqQfjJvVFOJHhnNjUuoOoFfDdpkKPHbBhwWLYGvVgSXHsSFfxNnXh&quot;
    &quot;pvVAaSsFZtTFfzXoOxfUJjuYyRrYyqQvVSslLPMbYyBmpIiCdkTtKDcDmiIoOQxXBfSsFHhVtT&quot;
    &quot;vKcwWvVdDlOoHhuUQaTtAqLtTCkQXxEFfeoUunNHhtkKOobBEisSIetTWwTzrlLGgdDRiIelLm&quot;
    &quot;cOoSsYyzOoZPpdgGZzDenNEnyYXbBoUuOwHOYyplLPSsoUuSECdvPpcCVmvVLdDlDdoOUuRpPU&quot;
    &quot;YyurxXleKkeEEAaWwHhOoDrReXxEuULEelCNVvnjJIivVPpmwWeEAabBCcwZSwWsXxyxUuXYuU&quot;
    &quot;dXxoOhHhHggGIPpkKiNQqnSsrReRrEGXxrRfFgQqYyAZLllLzaAxbBNnXRrtTNcyPUumMIipSs&quot;
    &quot;TtYzOnNMmxXwVQsSvVqvJjVBbTtvoOQcCcCVvqWbmMBSkKsoOvVUCTtcuDxiTtIXxCcdlLDxXB&quot;
    &quot;FbBfbpPNfFnfFHhdDBkKowWObUUuuxOrRoDUuQqQHhHhBbqrRdiNnUuFfoOINEenNOAzZakoOh&quot;
    &quot;HJMhHmOoCcaAQIMmiqhHmDYwWdDjJXTtnNTnNpPtCcQqiInNnNXiYtWOYyNoOmRtVvlIiLIpiI&quot;
    &quot;PigetuqQUPqaAUrRvVugGuUsCcYySQzToOwgDdGaiIAWdeAaFfuUtuUequUQZzBbEpbBhHvVFf&quot;
    &quot;WpPXryoOYUcCASsauofnNFiHhInNKfFgGWwWVBSsbBbvMmWNnwQqDdnNDywWWNnwrveEVRgvVF&quot;
    &quot;fGgGfJKkjRgEeYyXxWRrwfFWhHwPIKCcsytTYyYAazXxTtEHheCjJQqoODWwgGdVahHAvcZgdD&quot;
    &quot;EhHuUSsYxXKkyXuGgUsGuUgLjJYRrsqJmMHhjQSfwWFrRaJKkRxXGglLrRDdHhIizZBYyJjbFf&quot;
    &quot;eEmvRPprXxYDdFfyrRMdDQqaAnNKsLpPjJleEctfTtFonNOVENnpnNZAaPjJhrREeVvbBCctEe&quot;
    &quot;IioOuKdDkXxYyJHfPpvVHlLAayaAYhVvZzFfFlWwBLlwWQqyYFPnNpPOopPoyYiIOpJpNiIJjk&quot;
    &quot;KnTcCEuVvtTtSsStjVjpPTCcfFteEtTxJjnxlLgGlLdDwWtLlrRTyIiYMmMmXmdDMDDddHhNuU&quot;
    &quot;vUuJjjJlLWAauUwmUppqQPAaHhtTUuwWJjYydXeELVNneuiqQkkaAaOoKtTkaQEyYeqAdDaTIi&quot;
    &quot;KqQkwWcCGaAQqUuIigGiIRrTLDVvCcdbBJIijhnNHsyYcChHmMSqQcCiIiDkgcCGOomMDkGIiw&quot;
    &quot;WSoOwdjJDLlsZYyzlLIkKivXxrRnNKkMmXmMPpkBrRoOIiHaAxbBXZrRoOzQqwWhXxbQHhqAoP&quot;
    &quot;BbZzQqCcpzFfJcCaAjuUzZZUuzqiIQwGgWjJWwFdDfQaAtTHlLFgGfBbBMmycqQHhSyYdMmyYm&quot;
    &quot;MgUuzZujJhvcnNCPpVPpHgiIGFHhOMmNnfFoGmMvIiHXzZDdnNZzxoiIBbIihUuDmMBbdXxXcC&quot;
    &quot;KkatTAzZFfmCUucTtUuhHCNnjeEoOVIbBjJbBXxYDdXxJjyzZNnVvApPpxXPfFtxXYBbKRrkyT&quot;
    &quot;jiQzOoEoOeSsLtTlZqyhxgGOqQTtOSaAskiWwqGlonNTtfVvvVFOLEegaXxAQRrJztTrROoQqZ&quot;
    &quot;jZzZhHBHhbeXxYQqyxEEexXYYZzyFfDcKkWaAkKwwWOozZIiBuUTtxXoOAHhsSWLCcLlrSssPp&quot;
    &quot;SIbBlkYyXOFCcfxXlfFLOoMmuUohHOmMoGCcgSsJWwjDdLlcpCcPidDwcOoCVvLbpPBEebmMSD&quot;
    &quot;yYeEdnlcCHhPzZtOozZdDhkKHTWwZzwhHBbtDdinyYNjpPJccZzVvYyChHRrDGkKUuxXUuaDdw&quot;
    &quot;QqKuUkLleSsERrRxXnNTxXggGGnNmMSsmpPBGgyYFyiYymMnNeTkKcIiCkKELleLmMgKkcClnF&quot;
    &quot;fEeSsdKLmMlkHDdjJuUiPdoOLlBbXsSxbBojcCJmMOCcUxXnaikwMmMhcZYysiIHhRrCcZzxXn&quot;
    &quot;NyYbQqAajJUurRQuUutTkKUnaAJsSjXRrpPeHJjoOhYyEoOeEUeOFCLAaRrloOFyoOYfWwwSrR&quot;
    &quot;sWwWMiwWQqWwIlLmAaHhRriIOVvQvqQIiotTcCVChKcCsSbBkKkeEFfEePdUwWuDRSiIsCcJAb&quot;
    &quot;HhBeFLlfjkKJqVZtiNnPpiNJjnvVxWwSsXpPINnKEyYpPpPjbnNTtaAWfFwBtTvVJrReOoEcOm&quot;
    &quot;rNnRuUoUuLlnNcYdDMmcCDdLlAiBOoNnbcCZzbENneIiwWsSDgmMGkKwGgEeHxXhyMzZrMmRmn&quot;
    &quot;epoOdDPENIMmiZzYfFVvAnLloONhHaFPKkpHhdjzZJNKkcmMCsSKkLWwKkRrdDlQqHobddDlUu&quot;
    &quot;oajWwmhHMXxLLlnTpSsTtPtTtNeSNnsalLAEjBbGgatTAtTJjJDAnNkinmMNrRSsIkRrtZkKzB&quot;
    &quot;bMmVQDdqvmMuBWkEeEexXKwwPpzZYydxXyYxmoONcCKkRWNnwZzrljJLCVPpvaAtlLwkKWTcbF&quot;
    &quot;fBdrRguUVXdVMLlmvwWVMyeEYmHRuUOcAaCoGoOgyxiBbIXFfuUroAOaAcClLoaeEODdRVvrHC&quot;
    &quot;ZUuzcDWdoOaAUuDOQquLOolUojJSsxXoGgOxMmiIDpPdGguUIidDIixXlLLlmVvpPHhQPaYyAk&quot;
    &quot;KptTXxXjJwLlrRPpCcWwZzqodDPtToOXxPporRMmHdDsSmMsHjJlCxXdyYDzvbBPkKpVvLEekK&quot;
    &quot;eEkSPpZzLlOVvHhCcosbBSJmsOoSNnNnPHhKkaVvZzoOoOaAeoOoAIiaUutTgVvGtTOhHGcCxO&quot;
    &quot;oexXKjJLlkiJqQjDdtTeqdDzQqAaGgZoOMmDyYdIisnyYnuUNWrTvVgLSsllLGgkCcTtoUugGO&quot;
    &quot;KGtCcZzKlLbAXUuWwrRxaexXEUuVqQvBYyYyrRzxXZvNNyYrsSRPpHhChpdDJjPIiKkHhrRHiI&quot;
    &quot;SswCcWwXgKkcCGxUukaAKkKszfBbDdiICSsbBZzwicCjJIfqQbBFZzBbRrJVDoOdEevjuUyYTt&quot;
    &quot;wGBoqQSjJsgGObtDdEeVrfkgGKFUuMmNJjWwHnNtFfTsDdtSsTZxXzWwSYmCcMIiyhnkPpsSOo&quot;
    &quot;KNVwWGgvFUuOofSAHhlLaIiuUAVsSvcBbCVQficoOjJVvCBbUKkdDugGjJPkacCAgkMdDmEeLl&quot;
    &quot;SsKBbKkXevVEZFfbHheTvpPRjJdGasrRSJjAgTJjoObBUurRcWwNnCMmFQquUvbqQBymMYVsOE&quot;
    &quot;eozIiLlZkDSsZzEYyhDuCcxXUOUDduKjJgGzZhHkoddDsSjGzZggJcCSsbrqQReEBPKrRHhkeE&quot;
    &quot;pjIioOowWOAaoOkKhHqGiIkKjJdMkjhalLAHaAlLxvaluLljJLlVvrQqrPwWwWzQqXxkwWXxKZ&quot;
    &quot;tSsTfFuxQqdDfHhFXpPFEembBbEqQeERCcDdxXaAPpsStuBAabGHhgwzZPpxipvVkKeEfoOjtC&quot;
    &quot;cFgGFfdnNoOKVvefFEBbHhkNTtKkrAaZzdDrbBRwwWyYMmdBbjbBfMInvVNEeGnNgiIdDDdRrU&quot;
    &quot;ugxXTtScAaCsuJRrjHhpPUGKZPpzXjXxuWwUcdDCyfFCrRcoORrDQqDdBfSsscCaLliCgGPrai&quot;
    &quot;vxXFfVIAJjRuUEDdepgGZyYzQNVzZvUkKZPxpPXGgRrpzwKsSlLkMmaalLmMDEelLcCTAuUfcC&quot;
    &quot;FoNvVnCcNcbrRSsRTtIiqeEeENnTRrdDkLlJMmjoqhHqQqmMQWBbwEqFaJjIiWwAbzZzCtTgGc&quot;
    &quot;qFtTfGgSswWAnhHNhaAHMKbByYKaAJEzmMdEbBeKkcjoOUTgGtuMmJNZznCvvTtQcCqVitFffF&quot;
    &quot;yhTtTtpZAdDaXqQxWwCvJzaAQqAauUZwGgWjjJnNDMmDdgEUaAsSaeEMmAubBFRrgGHqlGgLyY&quot;
    &quot;NnEiIrBbHhiIKktRrTRNgsIMmMZzmTtnWkKQOohHGgDdbBLlxXqwemjFvgGJjhDiINnHyeKeEm&quot;
    &quot;MaAxXhqQQAaqrRHtTMkKLbBlFfFMmfXhLQqzZMmtKSskDiIbBcClLdpPBbWECUuqQceLRrgqVv&quot;
    &quot;gGQezDdinJDdNPpRrAVvOoaZefsSsdDMmHGFCcfPsaoOAbBVePIgGYVaAOoAdDDTtdIiavAeeG&quot;
    &quot;gGpSscwWCYlLeEyexXIiEPKkeEdDAxRrXaGgsJvxhHHxXllLLhdDPiIUQlLSsqVvflLFVEXsSo&quot;
    &quot;JKkUWwukKjwWsNnrRsQqSStjJdDdDFfdcCAsvSsiMmIlLDfFuUIQIicCqtTRCnNcriVHKVvkhZ&quot;
    &quot;edDERryYyYnNzSqQsTYiHhIXxiqiIgYyoIinQxOoXxiIXVvdDIwWmUuyyYAaJjYGgdDrRSsAZT&quot;
    &quot;tzDdaNYyDXxdxgGgcqyYmMlVsSwnNWQTtTtqvnNqQbBqJZziHyYNnCyYIJjBbDdBDdTzZtuldD&quot;
    &quot;LjbfrRQjJqFBUNnujmHhcIocVnNdDaAtTvCRrgaAGHhOBbsZoOPiIprRksSKLWwXxIioOdHiIG&quot;
    &quot;gLExyYXmOoInNiZzMeGgfFyYIiEgGaAPpVvIYJjbncCNBTtyErRAkKasSeoZzOMUuAmNWwWFAa&quot;
    &quot;YyiIfRxBboOQqeqQluUwzZTMmDHhNbBnzZcCHMmhPIsSiAapDNnqQcfXxxNnrRZzXTtCGmRrtK&quot;
    &quot;kTMZOKknWyeNdJtlLyYgGEDdsSsYyCciTIgbBgGGstefzZZzZzhIijcrRCTtboDdOQqWwWmMSs&quot;
    &quot;uuNkCcDdXxiIHoRMmrENneDdIiVvxUuohHUuOaOolGgYUuyJqQVKkVUGBbgMlLmTtwWWwYyTEd&quot;
    &quot;DeaANnNnRrBAavRrVbHhhbBiFZzfIHtMQWwVXqvTtRrVksSjJDRrPMmhnNaApPtAaXxnNqsSKM&quot;
    &quot;ZcCzYyEjJedDBdDIKtEepPKkQqXxNdDnocGSsgVsmMVveESfUUuuFSvVgGrVvxXvVaFfiaAIku&quot;
    &quot;TtUqQjMmkwRrQqkbBKxZztPbmJSsXpGgHhPnNcJjpdYyDyqTJjeeEdrRJjDXYdDxXAaFxglLfF&quot;
    &quot;mRreEvpPuUtBbUusSPfHhydDYfRrXxqVvQKkYsSyMSSssZbBMUuwBRrrRbiuURrRIxQqwpPKvV&quot;
    &quot;kWfFEFgGpPlGqyEebUuBqZzWEuUYEQdDqLUhKkHRrXCoOwypPJjOoFfzGgaAAaZuFoYygGGgWD&quot;
    &quot;IskKvDdwScGgXwPTwWthjhVAaAakKvnbrRXxysSiUXMmxiIxoOmMweoWyhrBbRVvHYvrcCiIkK&quot;
    &quot;ZiIwVkKvZDdDCiutTUIoOIicdzkKzZhrRMmAaeQqkKBbSsOFfoVvEoOHGDmMKkdiJjuUUeTtim&quot;
    &quot;wWTJoOfSsFjWTtxXwuUuqfFiIQUhmMGgtTHllaAZzpLVOzZHxvhHtTdNnNdPwWLMNnRruUwPpW&quot;
    &quot;OogGVvDeEdnNzZkKkMmDdKnqQhFNYwWgGNqcYyZzRLlrpPkKsSLlLaAAaQsSVuVHhvjJUdVvDq&quot;
    &quot;HiUpsPpSKkNnyZDdAJjaYyYnZzKYyCcvNneEVwWTtdDkNrRXxaInNuxBOUUuuZSPpsSVHhPpjN&quot;
    &quot;nKjqQJuUCtTCcKuFfUNaAxMmgPpDdSEeszZGaAMrqQRvmONdDnpWwNnjJEePvGEewFwZzWjGgc&quot;
    &quot;CIiDkKXxmMGgcCZzkKdCcdDGGSobBvNnVKvVVqQUznlLZzZqQCzZvVmMaLlGgCcJjFMmfvVFso&quot;
    &quot;OSuCcyIzvVqQrCcRNQGDRFfYGJkoDdZzjJToNQqSNnsnDpPdqQTNMmvVfFcwWqTtCDdqaAQGgW&quot;
    &quot;CctTxXCqeEFfVsSaAULrBblnNmMpxXZOozxXPRrSJfFqZzIiwWnYycClYfFrRSsjJyLRrnNFtC&quot;
    &quot;czakYyrkKgGCkKtTcTtQqhwjJjJftYyqQJvVjTTtFOVwWAWwaPbVvyYdDWwrRBoOJjgGRKkUvM&quot;
    &quot;mVurhHyYHuUBfySsYyYqrRwWQTtepmMQikZfFzrRIVwWjoOJhHPpuUawzZWbjqQJdiIDBfFAhS&quot;
    &quot;gfFYlLLhoHhOZzmMoOgGDyYdpPFKkpPgGuUfkKEJrgGUuCEecRJbCcBEuUevmMSsVJwWCchdpP&quot;
    &quot;DYyYtZPpNKIikSslLcCfGqQrRvVQYuUxYpPUUuzHhUuTfFxquRSsdEtlduUDtTMrjJRhHPvJjI&quot;
    &quot;aAQqilbwKrRAaFnuUVvNfYhjcCckKcCcbBCaACmEehHgGQqHBbDdhpPHhnNqQHhcCIizZEespP&quot;
    &quot;SyYtDIeBOorxBXxbJjXKkYyYegYyyCsHhEeSGkKgXxGdCOOOuUobBbnNBVvxXiIFjJxXjqnNkK&quot;
    &quot;OojRrSsJQXxDdrRBRWJjFTyYtfZzTMGqQeEFfNnRrRDPpRrITWwWFdgGDfnBbyYfFBbReEhHfD&quot;
    &quot;dUAaJjkKQvVzZcCquyYvzZRrMgsKWNnwkkKvVPpCcAaFcgRYyrGqfZzzZLlGqMPqQmbFxXaJkK&quot;
    &quot;jFgDpuUbBXxPdGTyYqWwQBAaUtTucFfCACcSsakLMDdykdDfFUuRkKtTvQsKPRuUcFfkOoPpLl&quot;
    &quot;WwmTtiIQqMbIiwWBPCmlLMqQVagGAZzaJsSUQqbXrRTtGOogxrRlJjnNxXBcCaAsSsvgxXGPpV&quot;
    &quot;YyqtTxdixzZXGpNmrRMvHhEeVFzgBbGZBbnOgkIQqiKFfgAadDGBcoOEeCbWLlKkwXoRrcFfHh&quot;
    &quot;YyfyYFGLIKkBeELNNnbnNBbBbztTZtTnNUuBSslcyYnTtEeNHhRrpmMPxWwXGwWokFYyomWwmx&quot;
    &quot;XzZOxdmiTpemCcZzHZzyYetTleELEhjJHsSLlvMneElLBZFaejJxXEKRKkMmAatTrciXMvVUum&quot;
    &quot;xByWwYVaArFiIsSSNSSIiPAgAaRrRXKZdApPaNnDkBbIiCZqBwcCWvVcbnrCcHIigMmgGAabRr&quot;
    &quot;BLlZdDZzhHzOPmMCccamLTtYyTJjWMGgCcCCDdZkKlLtTvVNNnnzBvYyGgPpPAasdHhcCfFsSX&quot;
    &quot;xqQYyOoxrIizZPxXtTdUuDUKkLuRrBbUluUISIisifhHqhHGgWwSDdsDVvwWTrRsStpEcCuxwR&quot;
    &quot;wSsYJjndDCuUcCoMmOIeEisSUuiuUfuBbYdDyHhLvJjxXvVVlUoOZOGBhBbHbLsSlBYyLaAlYy&quot;
    &quot;izjJRrsLxhHIiXcCxvdDjJVGgSLVCcvAalsxXPsSpBbXeiwxNnXsmMhVvHZpcjjJDPpXEcCexg&quot;
    &quot;ERkZzKCNFfSAatNnTqQuOoCcUEeEeCcYPwWVvtdrRHhrRDkKVvNnQqoOIaAUuNeDCKGgkcQqAa&quot;
    &quot;JjmMKuxXzLGgRrvVvVPHhvVwWMwQrnsFYfFaAbDlDvVtXbBpPFfXxxaATnNuUfFhzbSVFfDCgq&quot;
    &quot;fFQpjJLlPynNoMmNNmMwWNQqsSDdnBbnYGSsjJgKOoPQDdsGgSqmMpBbkdDsShTDdtrROJvWwW&quot;
    &quot;pSsuUPwZMvVmzGgLlqQduhUuHYWmrfFnNyqQiiIIYkKRaBXTkKNubUWnNycaACCNSjkflLAdnR&quot;
    &quot;HhaANnqAxUuXMmaSTtsCcIiKkeEAjJaFBLlQPpgOlLsSrzYyEeeEzfFRRXyVoJjOvYtTPpBYzB&quot;
    &quot;DYyhAtGBbMmtTcfFZGfKkWwFWwgzIhZzFBGgxXxUaAiqQRzNLPgGUupBbGglTtcxXxvPGsIaKk&quot;
    &quot;mAaiBEBbnNhxBbZLlwLyYllspwWTEmMmMZmjJMKmXDdxvVHhDddkirRfxFfXrDdkkAalLvVUmn&quot;
    &quot;NHhCcrMjGnEeNSsgYybfSHhpqQUunNMEiRrIeEeqaAeEpqQGMmgVtTvPzZXdDxpaAPVVZzcCRi&quot;
    &quot;IIiryYQqfRcUUIiuohBMmRrfTZgtFvsScqSsgGQQOvBWmzZffFFtiIlEeoOUpPlvVLZjJHhyYx&quot;
    &quot;ZtiIOotTHaAcPXxpCdcCDzZicCXVvGbhGgZOoHhWoOJjPfFBSoOsfIsSiEeFVWnNKTcCeExliI&quot;
    &quot;aAqNTtnPnOvZpAaHyYsSUuCcAVvYBbyaWsSSBbQqshBbgGTNntHiIHJoOjicfFYymMCIhkKuHG&quot;
    &quot;gQoOUzvVKbBKAacuUCAANjJvVnzZwMOkKhHnYiSsqsSuUUujHfFhsgGXxGWwOUapcNmMnTtYTt&quot;
    &quot;XYwglAagwYWwNBZzblEeLGTtgOrljJLOoxsNnQEslfFSsgRrExaAWwaAMxXPbBHdaPpmMjJeBb&quot;
    &quot;ZzExXEezHRrNqOKkExrpZzPNoOnSsfFwMUFfCgPpGtEbVIiIkKoOiaAiZzBHnEuiIUxXQdDCbB&quot;
    &quot;cezsSZQqfodLlQoOkKdDDdiIyqQIaAkxtiXxaaAATnfFUuNVCctQqzZTnkKyesSOlLFfBbkVVe&quot;
    &quot;EXqYyYpkiILEEyYecCAhrRHHhYuQqUyxXFfaNnxXaAHlLBhHbBEqQRrMmetTWwbWwCEtLloKkO&quot;
    &quot;txcCXTpPTecSuUppeEnOoNAaEUueCWDdwckOaysSMuUlskAGgaKXazZIBbHivVIHhtlMqQlGgL&quot;
    &quot;FqBbQVCcOhHMmOcLlnslLaASYyNCxtSsUuWCciCcSsmwWnhWkZzYcCWGgwQAaEePcnNaAtTpPN&quot;
    &quot;QqRrnUuIOuULlTtJaBJjNRsPBcCIGwNnWCsSGgxoOlDuBbqkKKkHdDgGeNnlLROLoOlXFSIisY&quot;
    &quot;ynNSsNOjzoSTzZbBQfVaAvFxXiMuUbBOBIiLyfFIqQiiWwAaEFfuUCVLDdlvOOEpPgxXZzcwWe&quot;
    &quot;EnNhHCUcCUuAatnKkWwRriINUwlRrLWuwzRrZToOtWZggIiGmJjVvMSaAXiKeEkIxivVQqSLls&quot;
    &quot;lLSsQtTqXxtjLNnkKxNnzqQvVOoNxIivlLpdeFfExXDGHdwwWJjWnXgrRGqQlLxTtIiLlhRrMm&quot;
    &quot;VNNEeAQqaXBMcCfrWtFfNDdNSscIwDmMsYtDdTACOfFolUDdszHSseEOJevJxXjbGSsgTtSWwH&quot;
    &quot;RGglLXFfTtcCaAZKKNnVvEeQsRuvPplLfFTtHhyJjHhEzuUiIZYhSGgYVTaATTuUttfFLluUbZ&quot;
    &quot;zBCngGUxwxTRrHmfFeEfWwVvrvDEMmuUuLHCwWYyNncJjHhOoRXxvsShHVrQqiICbBPpIpZjOI&quot;
    &quot;AaibFpPZtTKGMHhwAiIKsSsQzZliPuGgwjAWyYoOwFIAOoFgxbTHbBhtHhuUIiGTkcXNpPQqnL&quot;
    &quot;SsGDagGABbdSsKkNMmnzMNRrzFjJhHfIeEeEGgHhFfZzexLlXNZJrRkQWkiILlFfPCcJQqgFiD&quot;
    &quot;SWICaAObSMmsAatHhTaMjJkGbBvDdVgkeEhkLZfzxXnNaAlNnhMVvdFfbBHhgBwWeEbBbUucCW&quot;
    &quot;wbBeqQEyPpYFMmFFfhHLVvzZAGzbgGBSQqQvPqJjKAanZzwPIxXUHrRtJjaGgEesSgGIPsztpe&quot;
    &quot;sSMmgGwWezlLnnNSsogGOTBCqFkKaHhSgGqlLGgNrVxXpbBbbaALgQqOoVCSslLPprgaZzHhgw&quot;
    &quot;UEeuDUKeEEekcuUAacwKdDHqQhVvsHmMtThIUWFfwEMdDGXxhZGcFuyAaYdDXVfFnnNmMnNXxp&quot;
    &quot;PpPVvAgGfFaNSsWtAapPTAaNqQZznyDPcyYJtUZzhDJIiKkjIifyYFtveCXxuUcCiYyxUuXcBo&quot;
    &quot;ellNnWPpPpFfnLlNIUWXjikKRrCYycfFjqQkKWaZzQqbHhUalLAbCcBGhKwWkWlLcmMClUuLEe&quot;
    &quot;TtVVzBdKwsSWmjlLosSOKkBOogXbzRIYNnNNNHhnWwJHhfunVjJjnNDLlUeEilLSmJAZvVVvza&quot;
    &quot;YzZLlyDdzIFfyVvVCchHgGQqevVEpPnNhrgGWhHwlLQqsDdSYxVvvXxTEbiIBePptlVvajJFfG&quot;
    &quot;gskKmlLeDHcCfFhtuknEomHhMmZbdDBtTLsdGqQXWVvwrRxggxXxqQQqXGxXkKInNBazDvVbBt&quot;
    &quot;aRrUmNnLiIgGrdjECiyGWLsSmeOuUoluvcCVcthHDMmIgGeRrMmXjYyQMJYyYDwwXxWhjCdFJj&quot;
    &quot;rzZpPhHpVvSsfeHhWGgMZzmbBlLHhUeEuHiIRDdqpPQkKliIKkpPQjlLyCmpPcIiUuQqjKwKYy&quot;
    &quot;kDduUiEgGZpPtpeEPNnTlokRrKmMOyYQBYMZzyAaboOLZKfyYFXSaAmMYHhxXgZzGySgqbBgGo&quot;
    &quot;BJjbOkKYyaKfPpOoxXyUuVRrvYQqFmMeEYyWwmrRhivoCcwWOQaHhArRBEKkelLOodDRrgzZiI&quot;
    &quot;uBbUNnLfVooOVXxvOvAaRrBbFBbkXqQrKBEOoebkgyYKnNkuUWwGRoOsSTtKmZzAaoGguBNnBb&quot;
    &quot;mMVwvVPlgHFZIiSTtwWsxXXxUuWrRvLlUtTfhHUuSsIYReEUurCUPIgIzlLJjZiPwWeETthrUi&quot;
    &quot;cWwJjFvLGPpDdcCZtTzhHcrcCRCfHhFlLMbtaAgiBDdlGJoOOoEeeVUbBKkMHjYywgQqGWveEp&quot;
    &quot;PCGgHWNnATtitTPQkkKKaAmxXdDMgGqRrmMKkprhHXxRCWwBqQdjJMBbiIOoSsCcSgvGgXSstd&quot;
    &quot;DTZzqfNnFQeETiuPpPpkyYnElDaPpyYAdsKpfOPpoUuJLludDCyYlxuUXeIhHXTZViIEecCviV&quot;
    &quot;vIzZzfZzsUuSNnqLXjJZUuNmMbBiInzxhwWpmXYynSrRxXgyjJYOopPGsaAxMmGQGNOSgeEMOE&quot;
    &quot;eEfoTtOlEeWNWwLlaRfMdDwIlLTxyYXBbWcyWAaXuUxszZSaoOAZjJBSkKsgbUuDDNKumYxXmN&quot;
    &quot;nLiNnFfIhRvzQZzjBKkbJmOVBbDpPdtTWYKdeEjJuePmMpOoVvDdbJjLlzZFwzlWuUwLnhHpPO&quot;
    &quot;omMcAxGLlOLdDsSlkKiZzwiZzTBEeqQbrRPplnSsNLUuBZxOBiIDdoOjJLlugyQgfjiSoBbOmM&quot;
    &quot;YeJEejrREZnNCczMJxSsbeEvVaVahHynNuNEeqQWtsSTbIAaYyMXiJjIRryYOoWsOpPPIdRAus&quot;
    &quot;EbpEcCrRrjJpPBYPpLUeEtfBbFrRZHoxKsSfFvFBbfVaAmMZzaAbByMtTGgQqZzTiItqMmxnqN&quot;
    &quot;XxknjkcCFDdJjVEeAmMbBSsavhvVHUCOoOJZpHlLvVhHHhPpQlLeKQLlqkQOouUkvVEeeESsHQ&quot;
    &quot;VvZwWEezUVQAQqNlEHlLhewBYSDCUuNUuLlAQqKkBmQAVZWUdDyXxmTtYyRGgTGwWBKkGgHhhK&quot;
    &quot;kbBHGgCMkKmHMEemcxXoJxedDEXsSBqQRLlYyMGgmeERkXxzZUvDMnNJjmWwhlphsHAigNnSsR&quot;
    &quot;rNUQLcCbBkuHhgGtTUNpVWtKkTwivVIGdrFpWwPnLlMmFgGvVDMmqQdpleEaLlAfFKkwWLxXxX&quot;
    &quot;iIzsTYymCyernsBOAaobBRFfayYwwoOvSsSsVWNLYylnNHhFhvksHicpOcaegGHhevxyjjJaaA&quot;
    &quot;fPmOcivaqQfhAagGHEiKrRFuuedDfWwHhKVgdDvVUJjlLTtxgJhdDVhHhHyDdYVHhxAVvVDdva&quot;
    &quot;fFfFKUuTGRLqQRrMmrzQquUMmzZZkgGvNrRZWxHhXWmGoRraAxXOmMXqQKCfLVvzvVNnpPZlUu&quot;
    &quot;hkXukKUZzXbNnnAcdIGioOaAjHhpXxdDRruquUOlLoVTtvTRGRNgGLkKhHJzcUrqQRNcCnDrTs&quot;
    &quot;UzLloKmJjThnNPEeptTHUurVedcCMpPHhCcoOAaNMiILlyYOsSjJqQqQfbBMwtpPKjJkWwvVTC&quot;
    &quot;cDiIjEwfkWwLiIiNnBSkrkIiEejUqQiKkicTeEdDPPpBbhHpBbGZzgJaAMmUxCcPPlKkLKkjJK&quot;
    &quot;kzZUsSCXxhHcbkKmzYpPyCIiWwcZzSsUAkQYqQEfrWcVLlvyVutTUoJpPibSZzQqYdUukGgKKM&quot;
    &quot;QoOqaAwRrlLiIGHhkKxjJXXKQNnuUxhyYopUZzZzKIiYyFXxWwfKxXwWqsSuVvUseEMmGqFfGJ&quot;
    &quot;AaPgxyhHYhquUQWwAAaXfFxEecJyZKkKqQdwxXWPppYCcyPqzbiIunxXfRiJjIebiMmYyABFIi&quot;
    &quot;zBbEeDdZMoOmfgxTdoBdwcXxgNnxXOhHVynwWVjOBbVIiMmYggOiHhIbntCosSOsSGSsgGgUuI&quot;
    &quot;qoCaUuwaAPpWAchWaAgGwHOqsXKyPdHhkKcCDdCiIvxxXEgfmMFaDwWghHMmvrbtJjTINnlIAg&quot;
    &quot;GuRrLlUiIMmairxLaQQuUqQZvVzKhtTkVuUuUvKbBUulKXAKuUkaMGgmonZzOoUuXxyYGELlZm&quot;
    &quot;MlLWmPUuMmuUAaSiwGzgEwvcLlEeTtCYybZznSsNZiImMwXxWgxNnqQJDnUIbqsWDdqdJffEzZ&quot;
    &quot;eQqEfCcFpPtKkTkiIUkqrRXywWwxmyYqQCjJBlJtuUoZjuQdlLdzkKEGgqQsmgGgKkZzxXkxlJ&quot;
    &quot;jKkLXKdsSUuDEqDnUsSfEmtYyfQqmMhfFHCQpEvVeqQMDjhODtaBvVAJjadaQCcqVWwpPsNkKU&quot;
    &quot;qQJoOvzZSswWPpOozUijzZyzRQqsAxXQpPhDdDKkfiIFsoUSoCgWwwltreEOoRcCgGweEuUrVf&quot;
    &quot;soVvaoCcONaMmaAFMhepXVnQqiIlLNtlLCvSUuIiskKZUuLqQrgGzuUVvspSalLDPpfFKDdkdr&quot;
    &quot;erXWwTMaAmvWtTdDhHwnUuNXJFfjyYIRrDNniIdZzoOXcQqczZxfFXERrheJjAPGgQqmMXLOol&quot;
    &quot;UulZzdqQalfGtduUPAUuAWzwWwHULIiluAbBavqQuMmguuNnyYUysqfUGgCUvZRwMmpjvVvKki&quot;
    &quot;AaNmkOVPFQqiUhtTVVvvBbjJGbDwWdwkWIxhyaFIifAGTnwQxXWDfjFVvqFgXxdhHDGrRJjHvk&quot;
    &quot;nNKkLVvlCpPcBjJrjJRrbBRhHZCkQJjqKtoDdPnCSnNsCcEjzhnYyEeKkNdDIUyFLosSkKOlBs&quot;
    &quot;SSKFKkKkVgQqRrMcClCVvhHcozlLXxXOoWwqQuOWwWmtTIiyYyaAPpYuOiepPEIoquUgGuRvVG&quot;
    &quot;TFfvSsVxPIirVvVKFMmVCIyZGJlLjwHmMctTldDJDMmFfuMMIHdLemRhHrSsrfYNEjcjHwWWHS&quot;
    &quot;GghZznNSsHDvVdWwBIiTuwWDaLlkKyYbBTERgANnaEelLzGghCaZAabBhTtLUGguDFRrGTtgfG&quot;
    &quot;zYyZzxgGXZgFfKQnGOoRrqQxXiItMhSIzZNniObvVvVRroRrqaAQBUvVdCtTcjJkKFFpCcCcbB&quot;
    &quot;lLPsSHhLnNzNTStPXIWwitCWlLNnweEcrkHhYPqQtTpXcKwFWqQxcCVulOmvDawWAzNcDvVdEW&quot;
    &quot;wQPpqWwjnuUIdDiCupUBbRoOrpPPvVpFLRcnLJjlqQTVhHAHfAncCNhHIiaoMmpuUApPaPADrp&quot;
    &quot;gwIBbMGgvzZVstTSmAtTivnmuEeZzUbBnDQfFSsqoOHhHHLvVlrOoRbBLSsUuUtThnNLUulMmH&quot;
    &quot;kKuGMmPqSwWwqEKkegeEODqYkMmKbjvRrfFYyVfFeFqQfWoOpPjzjPihXiHhPpHhWqdLlDrRKN&quot;
    &quot;nXxlvvVCuUcZaADdzUUaAuKkGiwxXYyCcWIuvQiXiEELEekbBzZKaEPZfdrKiIWrxXovVZZAZz&quot;
    &quot;xQquULeMjPHRXdqplLPqQQdkgejJxeEyYXYyIJJladTDoOpapEeslTtkmMYatwQqeEbgGgGsSP&quot;
    &quot;pbuBgFLOolSwEpRrENEWwteZCczPNnHRrjEeAafFSkKZzESOokUDAfFVvfwAaWIiUPpzgGuAan&quot;
    &quot;tlHKiLDdnNXFXxfxbBoKdDkOSsHhSTMLURrTtucePRrmMPpoORrhHWwUTkzKRGYqhHQzcChOHk&quot;
    &quot;cyoOEjiQqnEegdDNnGOoRjdDpMTwaArSsWWwnzXZzAMmmMaDdxFqbBiIgGlEPpXZzpPDLkKVvl&quot;
    &quot;mPpobeaAfNkKDbnISDdYSsnNRrvOoToIZoVvGjxRrwVPpPpmPCAvjJZzAlCcMmYtXZWrVvWzMU&quot;
    &quot;IiVVfZzsSFQjJhHqQNRrkKKUOouIijMCcXxtCcrbTtCQqXeIiEDEedstDdHSsfvVTtZyYbHhHd&quot;
    &quot;DMTtovNWwPaXoGHyYFlLNjJJjnLlRrJssvVSniINScCEoeRrAWTtoOYKzVvdxRPZSDdsKqQacC&quot;
    &quot;cuHhCGgcHHsqiZzIKkJvnNjgUuGFUVvufoiCIBIkKRvVmtlBbeExEqoFUumMJHxcZhHJcdjbBJ&quot;
    &quot;DwWdDZqsSXLJjuLzMZwGglVqSIimMkOgmQOCRrcCcnLwELltWUuYRuDtLlTsSeakipPYsSvVyI&quot;
    &quot;PpKGdVEenNvxhHXXgeECpiIqdDFxLGRraZzEfFeEeTzxQkwaAWsgGhHeCHhpvwYWDdPpuUgGWS&quot;
    &quot;sbBwtTwuNnNZzuEJjJNdDVvyVvYneEcaNnAZOBbmMpzXxWkKwOdizMTACuOiIoUQqXoOwyyZzJ&quot;
    &quot;jUvkZhHpPkVtTnqmAaMyxSffJMmZbBrUuRuUCJjpPPcRXiISnEAaDdednqLlLOMmJnNWIuqqQY&quot;
    &quot;uUyZCclLzZfjJoXxORdpPaADQqrUnYxXjkKrAaRJNoOnJdDjyUuPAapXxNuBvzmfMpTfuUiNFN&quot;
    &quot;nmxoFBbfOcCDtmMTnmaQRqbrxOgGgGHiIUCcXzqJWvcCBhHfzZpPGqQbqQFLNHhIinNwWbtTxq&quot;
    &quot;QuUuUIdrpPRHHhRrRxlXtfFHhlzZxcgGxXGgxKkYqQdDyQxjJjuNnhIodwVfjJfFmYyBPpPoOw&quot;
    &quot;VIeEiezpbkBbaALBbWwllCvfSsdZOoJjWuDdUrRvVwlLzyYvYpPjJsSUiIfukuUfFmtTnfKFNZ&quot;
    &quot;gHnPpvEezcbSHXxhsBihZzByYeHhUeuUVvJTtmyrVkEkbgDdwWfPnNfFppvVluTVLlhDdiIbBD&quot;
    &quot;bBqHCcCcKAWwXnCMkKoyjTKsSAtFfZoOziITtNmJQqTnNigkWuUTtwKYeDdECcVXqQdBbhHQsB&quot;
    &quot;WXxmMaDdtTSnyYOAQuJzUCweRrmKFrjxrNNfFnndYeEKkrpPlfFfaAxmMXxPCthHwbcCBEKLev&quot;
    &quot;GLNTDihkKIvQdnXcaAxXCVtaFleMDoOTtQqxXRpbBPRcQdyYZxFSsnNckwWQTQWwdDAafHnFNy&quot;
    &quot;CVvdRrDPWwwZeujJVvwBbWHhkRBVpPVoeEOPpPkKgGrLnLltlLTcCeYyQdgGjqSfBGgVkKTWQE&quot;
    &quot;nNuBbHLVvCcVzZJjNZzAkKVvcJjCcvifwIDdivtTAtNndDFwlOolLjJzAbvjNPxXuFYDdyDdrh&quot;
    &quot;tojCfFcuUUuoOTIjBbxxXXSbBCciZuxkJkKxNDdDNnbBeEdnRHuUsSbBTthHcPWhHsAaSZzZxA&quot;
    &quot;aiqzZfFjJeFxXrnWTtaAIiiScqQuQGgqQDrWwRlyPpYLtTEoBbOpPlLNrDsSdzoWwfEeQDdqsC&quot;
    &quot;cSEkeEBjIhHFssapPtTcxXlMhHmRrMmgRrOohHYKFfvlLmEeBnzJVRxTGHkkKKeEqRrSZPzGgG&quot;
    &quot;aAgZplIyqAamMVvWdddDDKrpdGCeEeVZWwyYzKrLLrWMLNRzAoOagiIAaGNPdLlKLENsRDGwVV&quot;
    &quot;gxXGdAuLlOOnDdLlaUSSssItTmwJVRfcKkCIimMxNnoUhGgSpPjwuceEeaKkrRSscCuUUcZPpS&quot;
    &quot;jjQBvFfSLlHtrRrpffZzLoSNACcnNTtagsrRSJPJTVqQvYyCqjJQRAaBblTVvpEetbBwWLHGZz&quot;
    &quot;LPvVtThHgGCqLzuJjUOCBbDHhHCaXmDsSMJvVAbqQUHhuQqdDGClLwDEedWOoIYwQbQcuJkmxX&quot;
    &quot;MKPUuchHyYhTxTtSsldRrkKDXqQEuMBTpPtJedStTjtTAwWvVLOQZElsSoSbTToJjtTkFYyAaZ&quot;
    &quot;zOyVvVkdDKJKSCcIYtTzZhDPYTUuBboOcmvzzZmdhHGajteEQWwMmMmpPLJjudlLFfHnTxXzZS&quot;
    &quot;bSERrehbKkbdDgGElRKDcxQqXhnBJjQkbvVvqQuFDdfCctHwPSspsSMLxnQboInUAMNnLxPXxb&quot;
    &quot;BXTrgTqLluwZzqQWzbDdsSxXMguTjJstTioOdfFDIRAvhWwnGOzioOIJQqJGeEihTtVNnvfFtB&quot;
    &quot;bwWLxfFhjJHLFyuHKmjaHozLlZNnaFlLWwrtQybBkKerBbXiIgxXAQYxrRxkOqpPbBCcgedDxW&quot;
    &quot;vVhNpBbjJgGfpOoPjUqYjJxhHXtCdvBaAuTzZKpPJkKLFflIatJgGoOrmMRYgGPAJxRlLYrRUu&quot;
    &quot;iILpwQqcCgXxLqQvlYEQBTttRroOCOGPpJaAgDWxAmPhnQqNHfFRjEeGBbCQTtqlUuqQhHAaVq&quot;
    &quot;QnSsNvxXSsuJjURrMmxJjPWYywlLpFfuUwpLlHeJbBjVyYOokQBjzaABvVGIiSdDTtvVhCqSwr&quot;
    &quot;RRRrZzZzonuUNolZymhZqbTtTbBjJVvYyXxoGgzZDdXOhHfFoPwWponlLAUNlJbBjLYXAUuvsS&quot;
    &quot;OYypwsLFfNktkKwBbIioKtBtYyhiIkKHKkThLkjJFaAEzZjJlKMmkKXBJjmjJqGzfyWwnAkDaA&quot;
    &quot;seEUuTtwWsRcCFiINnjJIrsSLlrakfgGPpnTtMfcnaQygGRIiRWwWcKkflkKLBbYyFQUuqJjgG&quot;
    &quot;pPvLlBmFWwpPgGxRKQzuFBcwWRUfePbCcBAquUngGgBVcEiQUuPpDMmyxXYyqpwWiJOoNnwdNV&quot;
    &quot;vSLOaEiIqQezeEZHcQoPClLLuUlcuuqQOoVvsUVvRIVvWdDwwgGaAbXxIKyMmYeDOrRDrOyGgY&quot;
    &quot;aAuzLlNZzAMmpkasSQqNnAxCcXmycCgkZzKvVAYmwRUuKyqytAaDWCqoNiIKkSsnJoOTXIitrd&quot;
    &quot;DRhboDxaAaUuhzfJjQqDDdxhkrbhAaHJjuUGUlVzcMmKIJjiQRrqkdRYQTuZeBMqPvzZOrRMjd&quot;
    &quot;SCDEeVCcEEeULeEEwXxGgXhWeiMmIvVbBJjnsSEXpjJeEOocCXpMaAtTmPaQrOkKoRosXbBXxx&quot;
    &quot;CjJcmMNWwnlgeLQHcCCeETtcRrPzWwsXHjKkqRGouUOoFSTBbbTtBBjvOormMRDdOoVwSZasqs&quot;
    &quot;SJqQNVnMmepXFcCXMdDTHgfFrBJjEQNRrRrhHoOoQCDAaCcdygdRrsCUNwWnXwWxrRoBbiAaIk&quot;
    &quot;aYyTyAaZZhHDVmLuUtPpTmVxXLyYlLohmJQqXkziDpLSYAaynNuDdTtVvEeMmDcCNfFJLljZHh&quot;
    &quot;AaqQWwLlxLlWneErxgnNoNnsIzdtTjJUEOtFduUwWDyoSshLrPbVvoOEeHhvVyMmYSpzsSZPKi&quot;
    &quot;IbBkNnZzLItMzZhUuSsQqHfnLIilYLsmMmYyHhazcmUuswtsKkBbvuUJzKOofFaApEjJgGUBbX&quot;
    &quot;xeEuvSdDsxhHqQXVeeELubBjAFTtfaeEgGtEGzQQryWlLwQYoOcyvzZRXxratmdgGDdmMDMFfm&quot;
    &quot;AFiXxrRwTtzoshjJHSuuiodDOIyYWAYZudzrqujtTmFlNXxABbzZCcdNnQqgriIGkLlPpzdtjl&quot;
    &quot;LPWwkpJjBbawLlUYLzbRTrtTxiPoVGgWrRlndDNEMDRrEpSauLwYcCyWyYtjJTiKkIPpAOokSs&quot;
    &quot;KHMmwtkKoMvWUulLMmeEnNevMGCeYsSJjPqNDdnKkGwWakJPdhbzIZzFIiMXLlhhNmkCVvZMBE&quot;
    &quot;cCvaQXhHKBzpDJmcCMmMaAHhZLsShMmrkKRuHhRChNnHsxMJcwWDdFUuPpJWwHyYGqjzZnNcWP&quot;
    &quot;lgtXxjNSjfNcCjJnPklMXGgkEsSeKSdvVmMDrPiItTpDqQAAagPHxXqCcALlZTtkEGnOaqzHxX&quot;
    &quot;sEeSUMmRrzZgGMmQqdbrsIzcbBClaAHggpEsdDqQwWSHSRraADXHhhHsZpPndDdDllvHEhHehV&quot;
    &quot;MzcCkKZcMJiIAFPpxAaeUlBbbBzVcatHhpgihRwDhHrjJcmTvlMNCQqwmXxMTPpEdCqQcQrXxP&quot;
    &quot;QoOqpDlGgLkKIiXkvasSAVKhNxNnjzWwnNZVvLgGHhlzTULoQqJbedDZZyHhAPVvVnYxYSOeCP&quot;
    &quot;JdDdDpEWwenrRQGxXMOoZziCcIsaAIfBHhkrRSsYyhHCMzeAaeRvVqRGNnuJjUgrQFlLOWTHhj&quot;
    &quot;JuvVGSpDdYZIiXntTNcCAtTrRwikKiwWIzdDZqLZQqvVvIimRCQqnNqaZzgEzAhHcCkGIiaDdN&quot;
    &quot;NnmMSsmMrkpPcCKdfWZYZRrsFfwSFpAuvWRYNbCMgGmKIXFfkEXJTXFPUNzkaZzAKeLEdDPpVU&quot;
    &quot;KrKmMgpVuUnNpaeEgGzQYLloOpPpghFftaZFfVKapWPpwijYyJdZztXywWYxjSspPCAaJWSxcP&quot;
    &quot;pCXlLUhHuJVcsSCBXUuWUlLhQLlUTtOZODdLdwLhxnDCcdVXwlLoaoCtNHhKsSDdkKRykqvQqW&quot;
    &quot;UuUuyclfFLlFACzLtTlWKZpSHbaInbUurSsUuxCcXRJFJlRrLhigFmJYhHdvXlVliIvbHvaAde&quot;
    &quot;XFfGhKWNpPnpPNttTttITtwWijeYysxXLGPvImmtnNDdTLimyLuSptqfFkIYKPMEWUApPaLRoY&quot;
    &quot;THfFIMGgMyjPprJPpiyvVtFfTXxrRjhloOrkPpUdyqQsETLlqTrJjLQqvosSyYHhWYFCiaPfWw&quot;
    &quot;gGZzFpAIwPdOPhgUuXKkxbOpPuQAaqFQbBzZqUgMmBUrRxsSwlLUuTttHhTHOGgFGgfnRaAeEn&quot;
    &quot;qgGlsSPKCckYyVxXXcdDCxQqvpqQZftWhnSsWDtAlLaTgOoxnxVlurzZCcsSvhHVaApPmuzZuu&quot;
    &quot;UrHwXHPFlOzoJSufFPHAaiZZUWoOvMpcYwWOCUmMuqzbBZWJYyBbjaAzZpreEuUoeyKkcCSeEc&quot;
    &quot;mMFslLYykjJKWQyYBnpMOvlLFOrznEYPyrkwJuUjQhEhqSspPNnKfdksLaAVJfFWbUSDJJdNJo&quot;
    &quot;OTNxdTtEvVBXhTtwbeXkKPpuUYVNNnDYxUuoFyYMGVvQqOSOFWtORAaYqQfRXxrHhoOYYyOhrM&quot;
    &quot;KkSmMjJFdFfnBhynqmMiXYQqyxAouRnLxvVNnPSEOiZiIcBILKBbkLyYBdZzDDSkKHhHygvUlt&quot;
    &quot;uUxTtCCcKXnOdIwWONnJyMOKPNlxZzpwdDwfSAHuUhCXxtTJsZrkbBjJxlRrUjJPlIjBbJxXMm&quot;
    &quot;jJizZRrETtUaAfFJjAJLvVFfVAuUbNnSAOENGToFfuhHgDVYyYmMaKkeQbdzZGgPIrbsmeEpPM&quot;
    &quot;MmLoOomxuWJNnFfcoYsSgGyxHhCjJttTxwowRmMzZrTJbBDlNVsiZOoAXJjKOOonIyYiwWRyYI&quot;
    &quot;aupGOPTWfjqQBJbBjKiICFfdHGzFNnssSCdthKSoyIUSUurhebMDdTtINnAsSsmaAQaGQqgAiC&quot;
    &quot;qdXZGsSUcHhItTkKKqpLszXgGxYlcCGEesvUHVyRaArPCAwwWKfgMnsiIXxQqmMUubtSOPVSZG&quot;
    &quot;XxgwPpWMzhMmqQbZzuUbTtYmWwMydtzFvVxXflTJvttTTPpDNThHIhJjHTzpcfojHAvbCBqCFI&quot;
    &quot;jJipPiGKAKkaSskgYoOuYeQhHCcSWTmnIZyhHainyGgZqQqQeVXfAzChHcZyYwDdZiIWwzOkIH&quot;
    &quot;yYnkkYdmhGPxVQXxqJjMmJjlSvHhJSFtNnWKEejfyYFAjJaWJMdgGDHpUWOocBbhPRYyZDafMT&quot;
    &quot;tAHuBWyNMlLfFepPsSbQqdDLADQPBrJjsxcVvlLOeEoxkWeEVJjvVMxXEVOhqQDdFamhHFXbPm&quot;
    &quot;RrsSSVYZFEeONnoQZeZgSsOodzKTtTmMpwWApMIurMHheKOEoOefFokEHHhPpAeEVvOuPRoYLI&quot;
    &quot;kKiQNgFnNKwMDdRNfFRrcKZhUiIUTgJNLxpnjJrKkjJiGkJbBzZMmjkKocCOgGNNLzZlXYLPoO&quot;
    &quot;ANcGbWKhoRPprSZaAzLlzZuexmMVNnsLlSMmaBbFfAvXEvNhgbTkQPaAhnCcNnOoNcwnqyYkcA&quot;
    &quot;IGjcbRrMmdvaOFfogvuqrsdxywKLCCcVvFfMwMdLCcPaHboaAXIOWpPJjIDdQyxZvViMZzPpkR&quot;
    &quot;NnwbBRXLGgXzZHhqhUbJVvtTsSGIfFLdQuUqFfzTZJnNjzrRGgtHVRrFwJyFpPeWzZfcZMmEYz&quot;
    &quot;tWlLvwWrlafPRouUOKVGpZznNPeJwbATyAadLRRWmFfMWTFgGqQERYyitBbgJjSRICQJAawWjw&quot;
    &quot;WORYsgReQSsnNqxYxXLlSKksObBVaAdfFDOowoOxfHhXxFUsZgtzZTgIyPrRUuFpPAafpyMsSr&quot;
    &quot;JphVbBwPIYQqmDvaDZpMmMnNmzZLJaCDQbzZpPWXWGgwXVRVMAasOFynRreBbPQqfZvgjiIJOo&quot;
    &quot;aAhTtaAKAakyoNnOBbIiJjVvVuVElcSsCmdDYyhuaysKmbDqQmMVFfTtGgXxnNodHhiqkiMmYR&quot;
    &quot;mMkbIiqLaUhiyYmXBbgGPwtTqYyQWpwWYyLlYbfkeiHIsSsSyLlVvVGmMXeQkHMGgGaAkvVWwo&quot;
    &quot;rZpPzmnSCFbAExaAuNzetvVTDmEWJoqmMhHYcCrcymTNDJroZfArRzZecaRrcCVkKzaLwAqAaQ&quot;
    &quot;NlVvykDqQqlLlQxikzTwPNBbXxUuxXnprRWtnfXxDhaFaQqCHhDCctBeEknLnBhRrMzZiqQInL&quot;
    &quot;lHVmMoEeSsCzGLHOADuUkVvcCBbEhhQqHMvVTOvVRIEsjCcgGrEDvVdMmPpKJLuLBCJjcfTtsT&quot;
    &quot;UZUVdnUAgpcCPGcCaTYSsgGXInUueFzCVVtcCcZJyKaAdYYvAajmOEWTFEeJjfdhHMyZvVzWMv&quot;
    &quot;VmWTgbLlqQfcJhcJjFfCBbwWFDdvKBbKkkFFfDlLdfvVJdLkAtZzTbchHCcEWpibgWIYyjobBK&quot;
    &quot;tpUuxXZzPOadpPpPzZbSaMwEgaAWDUPpusVIQqiBaAlCUFRSCcUtVXxrRBbLlvICEnTUHhhsAa&quot;
    &quot;vVSHctzVvZDaVvYyiMfjSsJFtTasOoSKkbPpUrLuHCchFvKNnCNnFdDGBhvVZlzZLzHbpPgfcN&quot;
    &quot;nkAaPpVfUlRubBBPMmZzpAfFmIUuVvYyjJAdxuUXTCyGgYutNeceEiTusrfdDucLbvSFfdwGeW&quot;
    &quot;mAGSsgsBDAoTkOsSJVLlvZIiziJjyYwGBIPlLweCBaKlDRrjVDdMbBPpmfHuUjCFqQBGtzZwmM&quot;
    &quot;wYmDnNtweoMJVyyDmNnMlLkYjXkKxzCGgTvvcZsStTfEbBNixSswWFfytuNDvuvVmVvMzFfBbu&quot;
    &quot;GgtLlSJjFblcCUKenMmNjJTtEkgGljbpPBkDdeRJSeirotmasSAqgGQHeKdaTtohVvoOlgRrZM&quot;
    &quot;mYycOvhNBbmHbNcClNKMmkKJrRjbnNTdjJcAfiIAHdFNFDhHdfZKvuUrRVIXDdqLQdKYLnSsaT&quot;
    &quot;tWlATmMtZvACEaFzORjdntfFMYCRQqyQEeOmGgMjwePpMdtEeTEZnUXeaBfcsNMROKgmhKqMmE&quot;
    &quot;xGgQaAoOJjqgvYihIEhOoHKbBfFFByftTFWwxMIqQLlHuAlnNQBKryIKQIDOAavdBMkSIxXiYA&quot;
    &quot;UHMLhsMmSHUbfFBuevUvOoUVvuLloOYlLcCHlsRrLlSLGVzFpwWEvVNYcCfCcoSmvrvxFfWwgX&quot;
    &quot;xGxwCcBqdVvcAbBjloOPzdAVdcCMmyYMyiQqpWvHPjRlLmYmMsSyfPpFYYiGnDdNGzSuXWvoyX&quot;
    &quot;EraAGPpSyroqcQlLqirsGfFTRrTtIOorefEFfeMmtwwrrlDxXYtayAaYBWRrjZzEVZzvpPgvCc&quot;
    &quot;kiIrpFALRVwWwTZyezOowWQqCFwEfYjWfSsSsvhJjZQAdDaqDligsSgGBbXxjBuHQxlxrWrKmI&quot;
    &quot;chHMmCtTzXYqiuUpPPpwnNoZzixOBhApNnNpPnlDmWmBbBbclkWYXDSRQUuhHUVZzGAVDBCJgi&quot;
    &quot;aCKQNWCHpqKtHhBGHBbnYmrRMyVUBbOzZoJiywWYIEejspPYyOHZvVzkwBgCnaplyxnngGKgIC&quot;
    &quot;cRFWwfNYyQqPXlnjGtuuHlLaAzkPpCnrmWkfGnqlyOrRCcrHhpUYyoaQqpPhmRMmUimPIiaoOt&quot;
    &quot;TPtgGkSsZMxXmWwDGzEzqpPfzyvkpPuUKsnDdLlNMdDwWpBxfhHMAeEfHovebBPQqpmkKDdxXn&quot;
    &quot;NvwKXCXSTtRbpMmZEezqdaCclgGmMvVBEmnYtTwbUhaKkmFAdzrMmpHCXxwuiFfIPSRrFfsxXh&quot;
    &quot;mjwJPpYykLlyYwTucCUfsjVsLBbvkKXpgHMDLliIyKGgKNhiKoWDdVvxXdDyYaFxvwWEiLlIQq&quot;
    &quot;wWztTYNIAYzaAiNnNMMmYytwsZzoOqEyUyIfcQbzZcBVahJOFCsSPZtitndVjzZtLWwZTDrRBB&quot;
    &quot;UuYyXxZzHZaAmODdSsozEeWJjwsTtsSvppPosTBrRSEeNmGFkWacpYmMCcvhAaumMVdDSgLSsy&quot;
    &quot;XxQqQqZSlOoKkPewWEQkiCugzxDQcIagLlGAlLnNpPqMSaelLWgGwEimBEHRUusuiYONpPPpns&quot;
    &quot;kHTDVvcSfZghDJjckbJjCcJFoOwqQtpofFgPUAirvSsVrRNMmokxazrgGRISvnLdjtWOWXxQqX&quot;
    &quot;TczZQqXTTttWwOCjPpwUeEXMOlmMmMmMIiSBNnRiHhpDBqEAyQCcqvdSseEmCcMtTGgGUOtEeg&quot;
    &quot;neoasBavljauewWLplPpLXxuLQqXKRzSfFUujctTXxasFWdDZzjJdDWPXLnCcpkomYjowWinND&quot;
    &quot;lLoNxBkKPnNpbkcXTLuuUVGTtYiIhsdbllibCYyzIoTtespDdXlNrUOkKgGaEeIpPQKkNYHNsS&quot;
    &quot;nbDdNDbBfsmRHoyofFOFqQyroTwEefosoKkgmNlLndDvVeEfOrqQRXydnvyxmMEBjJWcCzZHxb&quot;
    &quot;uUWwenNDXntjnMYymDjOojdqQEesuogGUuOBwPpjvlSYyKDFiIkQHeHqSsHhWKRYpEeyeNZRof&quot;
    &quot;DdEGgeVomPZzeENrRbVvBbqkKwcCSfkKCsdDYGgEORPwQcoyAaCPfFmVwOMmouJmMjzzIXxRrb&quot;
    &quot;JjBfFhpUSssjnNOQqZoLfphMmxWhRUJrRjvVsLlSUMJjGgzZRULvXNXGdwxXNHwTFzkKEeLQNr&quot;
    &quot;mMNohGgWQqXSsubGufUkKoBzZbBGHpoyYDpWjJZzcfSsywOVVvlfgjJGyzEzZeZYFHhRtQteSD&quot;
    &quot;dFfYDuKRjJLHJWMmwbBYIjRyYJYmbBEemqQiIkKihtZzyOrluOowehHmpkyiKmMmMwWQTiIPsU&quot;
    &quot;lYBbMIlMMpPOoiVpglSTtEJTTTndaADwkeEHgxdDEYyMmDVhBVLvbBLxQqVDyGgjMfGIHTtjfH&quot;
    &quot;hAajUuOoBNzZZzdDbBiWwyYLlAgGBhsCcBbDQYxXyqdPzkwaAIiRrBZzbFfoOZcCcafBbLnNCY&quot;
    &quot;wHhVQKYroOkOolLnEeTcOAOWxXxvNIiXRrHlWUuSsDlozouqsSHuwxbvjTtsdDZGgzwpHhPjcJ&quot;
    &quot;TDIVBbvPAkvzATHGPhHyqZJjAPGgvPGkRjJjgGeEJkuvCceUWwulEZnPpupfxFcCftjxeKxikL&quot;
    &quot;GSoOsglaALlcBnyFPpqfFQfrlXHhxLEewVjJwWNnUsSyYaPrFfRfsWcCSzyzwlLFDcRrNVtTvf&quot;
    &quot;FnCRlLnAgXxKaZenOxXodDmxXkTtKMNGAQcrMVPpxXOozlQkKtTZzBbiIIMmKkWauUAzZPpaYy&quot;
    &quot;TnNtxRKkqQrzPhHpyJjhHPszZgUTttwoqQfYyrEOoEWwZFfmceEKLlbFWwizZSsShHmgqqQPpN&quot;
    &quot;PGgjpcEBbosyXyNoOFfvpaNnYvVwWzzVqQvEBwiIWjOhHlutOoWwqQZJXnHXxPpxQqdmMdDRhH&quot;
    &quot;qDetWcnmLGgLhHlVFflLeEtMCRdWrHIGPTNnACvZxXhHZzLuEXfajIimCmLLuUNzSVvxdFfshT&quot;
    &quot;teobBOHhPGyYGhnNuULZJYyjiSRBDuQvVqhZQsSAoNgeKzaQhDdpvVGJbBjeElLaYydhHmMRkK&quot;
    &quot;sxmLKpNnFJzZsnJPpTGLpDdwFfoOCJQghEejKkfNnSsChHtTjmoOXSbBcrUVvHJjlzaAjdPZqQ&quot;
    &quot;bjJkKkxqAVoOebmzcKMnfFHHGgxmfiZBHdDDpjKAgoOQpyEwWcgmVEuUwXxgGVCcmOQIikKqTS&quot;
    &quot;sWqQoOhalUAsPedmksSKeLwvOpIOoXRtrBZRruUlyuJjWAPKplLJTDZeEKgRZzGDanmMLfmMMJ&quot;
    &quot;UQKeEzZknNbBNnRZDUzyJjawlLUUOZWIDxXdfUjJwWuMzHhZmaEeMTObBoOopPEeAPpVYCoOyq&quot;
    &quot;YHhRSsbBqXxqLlZgeTAauUKUOxFfXouBbRrkUgGuJBbUDdlzZeEPbDdZzvVBmMkZjFfVeQqaAL&quot;
    &quot;sSrRlrRSTWZzSMCZAOokKMSlMmRrIiyNFsSmTilUuvVssZzSBpRlHOYPpkKfToeuDZPpiSaAOg&quot;
    &quot;GGXRNwXMmqRpPUuUurQAazHhqQdHhDNnndUAaoORraSsAslPyYdkKMmIZKxjNnMHOZzlvheNnE&quot;
    &quot;HMjJUulMvpsSPEedwWhcCHVvDdzDdzYtAKuyYUOxXnnCfFcNNucpPSRrDSsGYcqOnqebRzZGaA&quot;
    &quot;htmmMFfxpPdhwWzZmFfMHKkDfxPEgGdDNvRroOwWEeUunjQDdSAZzzsiIWSmMsJboOtsOkKofO&quot;
    &quot;fFgRsSrrQJBbhBbxOPpoSZpPphnIiNqlEGMmLpaAPIiSOJjqAlLLlxSsHhnQlLqNGgPJjxeNat&quot;
    &quot;TApPWwEwyYHzZxWeluzZeRPprvcCdcsDJeyYEmoVmMpZPpzQmbEzUtqyrDVjJvCZZzvyYLfFug&quot;
    &quot;BRKZzzZIiHXhHDddFUuZHAPpUnNjJuXdOBNnHTxtWEewjOfFQdDcwgGdTYnNQYZzAaUukrWQqM&quot;
    &quot;yzYiIyZaGYMKPaUlufFULunZVvUoRbBdodpPEyUpPuaAYkiBWuUirnyyYYkKNqQuqQSUeEUUup&quot;
    &quot;OsSqCVJjmMvQQqLlqhAolsnDWaAjOaACcoIPQFMmfTtvhHVYdGgqIefFCvfOoCFOofcqQyYFbG&quot;
    &quot;NQapcCEFMmGgurCbWcCwfUZyYqrRkrXeEfMHhbVyYCQqwrrQqYqANqQCFmGgCcNFKARwWxXRfF&quot;
    &quot;ijJfrSsSTtzZnNSHhdKhHaeENYTtFZgAaQMbxFsCcSfqQkRrXPpxLevViIfVvKlIiHcCbSvVsT&quot;
    &quot;kOWwHCPpchWcCTKnlSWPorRcCVaxynuaNOxOzZDdaAAcCaHhtBQzHMYTtzLOOrgGbBWsQcHLls&quot;
    &quot;KWwkgvVbxXZJPpbqKvNnEYPpkKyhPWQqXnNLzZjJcgJrpMafFVvXxgGXwdGGgjgYcCyochHTbq&quot;
    &quot;eyxXLVlGaAWPlyrXjSsSsapyjTAiVvUujMmkBbIiFftUAawWiIJjwWbJCcjVDnNcTyQuJFPnHw&quot;
    &quot;XYyEGQoKXXyqaGTtBzZbxRFfEsSYqiIfFjJTRsSfWwAlLdDGgOhAMmdDJMvVkhUYRrflXleEwS&quot;
    &quot;sWTHIgjBbSsjYyZoVvgNwVvWmMQqCcHVpParStUGmBiIIiZUQtGRtxwWpXQqlBLlbmadDuNiOB&quot;
    &quot;qNXlmbBpPWhAaqQTUVBKqoObNYyHMmCdkIirLFfUueSshSQqsHBBHsPpBstqQNhXxDUlMmrRqn&quot;
    &quot;NTJAghHDnNqQMZEScCseVMCtyTtptTdscCSlGgUuLHIiyPhHqZzqQQpiskjYyuUvYofkKvaeEa&quot;
    &quot;UuAAVKOroORHhtkKtBsOxXfFLWwezqvVoFBaoMmVTtvOAbRrflaJsDEjbmUexdCcOoDRPprLXt&quot;
    &quot;HGgCpjGLlgUwWCqBqWyicgkKOoBaIijwOoWmdMxTEtAchdfFRrcJjoZeElEZzKkeQHhcCfFcmM&quot;
    &quot;ZzjJpRrlAYyaghpPlBbTPQqpgGPyYtLPpqQrkKciIAuUatjpBXxbOojGnsgGOjJliFFYyffIFF&quot;
    &quot;PRThsVbwWAFsSOofaqFEeXxfEeJJszCxqYymMQXSsJjVvuuUcUuQqCeEmMAgaAGEdDCSsBbUWJ&quot;
    &quot;sHHHNnhhuMmaAOHhjJXFfFrvjyYQquUaAWMhHUuiybBYuANozZomMUUuaMmDvSXPpAlLEeaxsv&quot;
    &quot;WgdrSneEfFMmYyelkDxXpnZrZmMSLlsznuiIUlQqmCcwgGRSslldDfFnNRkHhvEcgDPRRrkDTt&quot;
    &quot;OrRoYywLzZlQYSsieELYyzsQhgtlLXrtTvjZNbMlLVFMmfZWwzgGkyGuURrLStTsCRyYbSsgGB&quot;
    &quot;rAdaADScHBcCbhvVAauUbkKBCwWSfQMmqiJkKbTtKevVpPKkFoOOZnNOoRnelIiwWLdqUCsIlL&quot;
    &quot;yYwoONIZziRfEzYySsZQIXzEemoOMwBbpHhEeCvVYyhJjrXtbBTUujKXUzIBpPbsJitvvVVCcJ&quot;
    &quot;OTHQqfFRfZzXtiITxUMmpnJVBaeEUuZuUeJjELWfZzNztcCTZnTLlaVWFIVPpCanvlhhHUeUuE&quot;
    &quot;ePpqwtvbbBFgGshHQJHhcCkKDIwWSdviIVVvDsinKkNqErHhRNlRBbpvvbrKUEzWbMmBvkKVpc&quot;
    &quot;EeYnfNGghUUuuFEedDNnjYyJbBqtqKvVCaKkAfqcCQVvqQXzDqCwWrrVhHaArRvcCdmEQqLbBK&quot;
    &quot;kHhHhfAZhHzTvxKkNDqGPpgViJjHIdtBzZbndDllLcCgUuVEJjSAaslkKaAeEkeUJNnjuEeWmM&quot;
    &quot;TcpiINngGXFYyLfFRyDlLHfFhRXJRfkMEWiIUumMcukKkQqKZjUqaoNsAXxwPpbSqDUuzZVvxv&quot;
    &quot;yGnNIQqtjMnTaktJYOmcNxazZkhvVYyQdmHhHrUuRhMgGPpDdHvMUumtULPrRFGTXxtTtBKLlz&quot;
    &quot;ZeKvRYMTfFDnNUudoOtjIiuUNyYtTnvVEufFHhEbYYyPpyHIjCZzMtTmcuUJwWCBbqQZVNhhHG&quot;
    &quot;znfkFNdMmdDDuDdUMKUFnNuLlyVCcdDEpPeDyYFVLlcLJjzZUuZzuUHhwWZzKBeEPuUZUuEvWp&quot;
    &quot;bMFVvvWhHFflLDrROYyiQqHLlUgGJXqQqXCbTtrRBXuUEQqeADdLlaLLlTxLXpDDddWwPyhQqH&quot;
    &quot;YrhDiiIODdoXlLBnlTtfFfBgzZUuFRrwWFfbZzVDdwjQZONnQqoxuhzZoXRBQrqAMYyNdUUuuX&quot;
    &quot;bBMfnCShHscIFxXzZynNKkFwWfuUtTXxYtRrPmGgFkKMZVbFzQekKEUiwlLjolQNjJDNsxwWrC&quot;
    &quot;pgFfGPtTpczZziIjFFsXYmMQQqNvKzKVuyYUueEYYWxuUcatmZIDaAoYyZPomMzCNQeRrqQEqn&quot;
    &quot;jeUxXiInaAUVyYvyjJBkKbWVPDvkKVdVXxvcZzErRaASCcKqVvXnNZFiIFfftJkKjxXAUuggGl&quot;
    &quot;XfQyYGgPcGdDxDgAEzZMmMmdUrywTcCFfSsegGiIWzZlNeEbBCcoqMGoRrKiIsQvsSLWzmTGgt&quot;
    &quot;ZOoEelUlxtTsSRrQzsSCjmTtMzCXyYhTtjThHtsSfrRrROQDdeJjMmGgXmMLThlLHMaAribicI&quot;
    &quot;rROhHMOoGgPcCCcpmJVjQAYyLxXlacCShsShUCSsAkzprXDZZzkywqQbBaEUuOeVkKvbIiBjBc&quot;
    &quot;CbfhTtLlFfgYyJRYoCcCOoTtYycOyrkGiIAagKjfFOAaxApnVOmhaABKkzZzGgiIsaYyASFAah&quot;
    &quot;TSDfFPpkKDddmMxpPcbBBtTmMRTmJNnkfFnqvvuCcwWmZwkKkKRwzxcCxXTyLzZaVcCalLpPcp&quot;
    &quot;MSsvWXJgPpOziOwWtOoKnNkVfFyIyYisiNBdYqQyxXUunFnNEtTcCBuEeLlUPpOpPMEedoOxUu&quot;
    &quot;FfeLQfZNwRWtKkmcCAHEehacCPJrNIVvJeYCKhoHZyKkKkjJgaArkZeEKrRtuKkpEfFmuxXCcU&quot;
    &quot;MCjJlmUutscCYyOoSsQqIiOmMlLoFfYylIkhLKaAkTvzZVqQNEeWwsSUZLlSsHdDhuFasSpPdu&quot;
    &quot;KNnsekKsDdJhpEKkThHeHhneBbPXxeTaAtWsWLldDTtwfGoOeEbUBBwWuUuUXxHhoTtOWTAyMm&quot;
    &quot;ZHhzKLSPAPdgGtDzZAXxLjjiELlOoMmGKDDxrhHWwWwJvjOoJaAVjhpJmNnEcdDBbChHOoQqYy&quot;
    &quot;uHhUlQqXazzOJYyjRZzzZwkRDFxXzpeArRBsYIiySblXxeeIxIqVvVaHhARrUgvVuIhHaALliV&quot;
    &quot;YyLTIihRrHtkJjQwIxHITtpJpwWPZSuUsJjJZaDZzDddAzwiIEgGJRPprByWwAaZaAzQdBhHFf&quot;
    &quot;fFMmboMljJLmGWwEFfeQWHhsQsSAapgllLvVXxdDhhdNMoOmMNVIaoOnNiWGPRdYyaSsUlLrDY&quot;
    &quot;GgylLzZdRuhHOAKkaWwFfFhaAUuDdaPwWvVpvPptdfCcFDfFNCrlfKkgYyLpPlGUusSHhqQuPU&quot;
    &quot;cOogGNJeCyYnZaSsFdDfTtAdgGIiVMoLlLpbBPUvVvMxXmMmkKXaNnrRKkAwdDfYcCLlfFEeyW&quot;
    &quot;kLlmcCMCxGhHgyKdHhDRBbTrRxeEppPTstnZAalffEeFfDubOBosIisSavVAHNnmTbBgNqgcCG&quot;
    &quot;kEeyYTtuUnYXxeEfFyNHhoOdlHzZzgGAcNnHGgZGretQqAdcClLUkKtbMXxmkKshvVwSshJCnN&quot;
    &quot;JtTenyFRMNnElDhWwimhHQqvVjJmUFgGfSsdjLChWjJgzYijlLJEecvfkvRQlSsDdLqpXtgrGg&quot;
    &quot;UQUyYMwcCoUxZOLmGGgvTtfFfpPksbfYqQuiHZJeAacNpRrOTuUczYhHybCcFfjpPPpJKVyYGg&quot;
    &quot;hrXxRfuUQyYiIfOoJFdwqWmgGMNtgYHXiwKWkDUudKqyYQBMmgGvhHVYFfRrhHzqQZyIiggGHw&quot;
    &quot;WuSpQqPsIfpvoicsSpPCIpPKMnIVIivVJIiPWrzVujJcuFgGNnQSYUGUQqVQqhWWwZwauUapDp&quot;
    &quot;PTNngFSsLlLAfFcCRrZztTDLxiIdDpaEKkHeCEefFCxbBiRrxoOVuUttTxYyRERbBMVvmqQGgX&quot;
    &quot;xRrAsLlbBPSjJZRVwWvlwDdWzAaVVvzZKkcHhnNTvxPEuUepPEHhHnNmfKSlLsYykALaAaAlnA&quot;
    &quot;EeuUOslLSVvSFfDdFvRWSsqiIQdDSsTaALWGcOsuOSdHqaCcSrOoZYpPLlJGgwWWwIuKkYyZnN&quot;
    &quot;WwVgGpPJjiIjungyYmMGhHSviIVTtvALlDbATdKkXxqnNQoHJdmPFpPfOoqcFTMbBeFumMCcNd&quot;
    &quot;RrIieEpPQtTeiIzZGMSMlLmeuUZDDdesHhSEDqUJSszOXxTjLSsbLHKuUkhlcqQMXgGWwmMjJH&quot;
    &quot;huUWhHYxMmQVvIicKMjiIJmkAaCKxXuKQqcwWCeQqFFjDQwSQBtFfBbTiuRrUueEXxNncCXxNK&quot;
    &quot;kPTtpsRrwWScCYydjXGzBVWeGgGZgCcWIsQZzqDrGgRdTxXHhEetpYyYyMwNnEevVzebZzBgGX&quot;
    &quot;xgEetTyYBblLNOVvVLlvxkSsoOLGgoKBbkOHfFIOoinNiIkezZkKERwWMmVvpPeErqPpqqQAlX&quot;
    &quot;RLtTinNcCBRJjVIiGdIiAGecCXVcyYFfJjDpYkxSjJnNtTQQicYQqVvyDxXdTNBLloGGyvoOpP&quot;
    &quot;vVoJvNlNnLGgIiwBbWYvoGkKpPCWDbODjJtiIJjXGtpPvVTrRbauUIBErFNThHPuFEeiIfUPpp&quot;
    &quot;gRrGPptSsUIZzFfiDPpWwQqdaAKqQkAaVveElLBUuZFfQpPoODgaAgGGkHhrRtTzvVYXxXZzxu&quot;
    &quot;UrRCcjCaHCuUcQtTUuqTtXGpAajgQgSQxXkJjArRakuPwWOHjJFfhHXjYyUuJqkxgWmGiIgkZz&quot;
    &quot;dDDysBIjDdOvYOoJjZzYKkJjyCcCwRFeyqKyYauAazZZMyYBupjTtbBTtJpvVXuwWZwWzjGgxX&quot;
    &quot;ZzGgPItTPpiptWwuUCxXIaegGEAyYzSHhbBsZHhIwWuJKRugHhGUDdgXxGGNngpPfFiIdDKcQq&quot;
    &quot;GgCvVsPpboODsSMmdDlLdIlKFWeJOoddDWmFnNEIRrieouUHhgGfVvGgLlYyAaFgGYxXJYQqyj&quot;
    &quot;ymLlPpJjnBYhHybDTtdvVtTvVcCIiqbBQmDEvRaAtdDMkOZuoOStRdiIuCZjlRrUvVuPprRnNn&quot;
    &quot;rgrtVvCcQCXxcUPnNYyJIPpgiDCdDaYyNCcBGgxxSBbsKHFckYhHyEpPQqexdFfDGgEeKkgMww&quot;
    &quot;znVKRlFfvVExRYyrdDoOGgtTiLbBlIXergvVtwWHhkIirHhRXvhHvMmHjGXYuUNnyuGvsSWwrR&quot;
    &quot;kFnNEfFUUkKBbmMfkIeFAVIsSuUcCRrCbgGhHBuUqQoMrRpFRrAJfFYtTXVpPhHEEACniINoPC&quot;
    &quot;IDdhSsSKVHzZfJjqQKknyYmSsMWANaAnhHrbSAarRNREvVYLlqQcPpiIMHVvhtMmRrTtSAaZlv&quot;
    &quot;VLPfOoNfRtWwyZSszYTcCDVvbBYoOyKkgvPnaLlAKlqdDunGIahnNSDdHXxPLHIidSsVurRKmM&quot;
    &quot;rrbjeEOChTtcbwWgtrMYuwzvuUHhaqMIibQqaaAncdsybWLwWnVaqvxXuiIqhMJjmKKkJjqtXx&quot;
    &quot;TEqhPZzgqeEQGzjocCuUcrRKJjkuTuUtRrfHhKJqQLlrRNRXxrRrLlKqQFfnQoOZzPXxoOfTtF&quot;
    &quot;gGpNjJXVvQeEmXDGgdaAeEeyYExYkIXxyYeEiXOkKhzLZztTNnleETqQuloOyZzbeERQqePBpP&quot;
    &quot;lLelLSULlZzarDGejEUNnoXxWwOugiGgFfpBboSIikKwWwxmiBOlLiIVvXGgxouUwnUYWwtTmt&quot;
    &quot;TMAqQvoBbFWwfogGIXhnNHxiOOABZzXjmyswVvWGgIJaAPpFbBGqYGUbnNoXzbxXtcCvVvVIPp&quot;
    &quot;zZWJHhjIfFaELleAhHLxWYywXVvPplHhogxXOoCcXaCNZWfBMmEUIhHihHDkywQrRqvoyYMqZV&quot;
    &quot;rHlMFfyMUknddBGVvbzrRwkTtKYCiIwLTtlKktirREeHhgGWmFrAxZzAalLXoOnwLSdDIisKkF&quot;
    &quot;lLeomGsowzZWpFfPngqBbgXNxMPHaASshHvvVVRsSrhHlQFWeEwtSzVvCcZJgxXGGgVvjoOsxF&quot;
    &quot;fHhicAaCFfELPkKpcqyRrYQUjAaFbBPkSzZLeZNbBnzNIihHwWoSsATWPpmMwtaDFfZzMmMmdO&quot;
    &quot;KVvrnNRhHUItxYyoOVGsIVvBcCbiyYvVOomDYybcGoVvOghHPmMpIzZmuUMawhcVpPJhQqXtTx&quot;
    &quot;ZzmdDnNCTtcuIcCibBvEEejgLbBGgbIGbbBBTKkFfBiIXvVKVvYykxmglVfCeEipNnPrRIzZcC&quot;
    &quot;pPNnINniIuoOSsRWwlGgLHpGipucyiYyFQquCxXcVXxGgwIdDiKLVvlFfkftTFEezfhBbGxXLJ&quot;
    &quot;jpWvblLGgUOhHPpoOZzMkEbBexWwKLjJlNnfrRWQXxqEDdefaAFwFlzZGjBbJRrmMNntPpTtTb&quot;
    &quot;qDnNdxFfXdDVIHqQrvVRMkBbszZwWJGgVFfvjSAaaAJjBbAQGfFQqMmsUuEdDesxgGOobBZXxz&quot;
    &quot;kzlxXBTtYIimjJyeEbJZzsSjqJjhHcCLzeGgIvVqQWkvVJoOCjJCcSsUuQqMuRrgHfFqQRrhGU&quot;
    &quot;cYKkuZzzZQqJjUJDdlLkKqLrhYyluyYULYywHhtTbBElLYyaAnNFOotgGObBoTKkPRrOpPotTk&quot;
    &quot;XxKRfLlFfDWwcJOqRrQoHdxXDWlLqQDXxddyjmQqqQYyYyqJMmxCcdoODVvbBlLFfIiuUEYyoO&quot;
    &quot;pPwrRIiWJjidHhTCULcbBCxXEMlwgYqumMBbpPYyUQIInNiMZzmsSegGeEvVEceRrqQPpJDRlM&quot;
    &quot;uATGTCyYcWwzZtgdjJZAbiSsCiIcdDDSlzsSMOeNKUTTkKEetzZLlUudFIifTttcCTEeyYEBbM&quot;
    &quot;IiPpSpPALjJVXyRHpPvYioOZNnvhHVRrjMsItTudFfJjJvdDNUlLFjnUDdunyiMmcCrWwBdtTD&quot;
    &quot;bZBxCcGbJomMhHOMkbmMBVAavBbDbZoORsSrwWqQvUgGubBqQztTZMmSsvYyFfwUuHghkKHuBA&quot;
    &quot;jJwXxJIJvVxPpwPpKlZzLLlkuiCciNnIwNnLLEObCIcENnVTyYdoOnNIRriHuTjCDdpzuUZJjd&quot;
    &quot;YDBbdLlwvQqDdmMxUgGfCgzHrRgmePrRpuKkigGSQqQqkWCjJrNPpZznRBbYyCSsudWGmMzZAG&quot;
    &quot;RQqcvGmMLlldDBBUQquPvfFRnQsAnNfqQQMmcgpPGbtyWwMmYNkKiIQyYcLbBlCqvVZEEsSZzP&quot;
    &quot;TZSJjVcCvpleEZzLisSAEhHeThRrrRWwjoOLlNnJuiKvVkpWNkQMmEeHhpVUuqQqsRKCckrGgo&quot;
    &quot;OZbnNwWBpPgOJjoLlWwaJjIilffsbBMmSGDCcgGmpPKEeQvVqkHLZBbaRrAFzdDeElKDdHKMmK&quot;
    &quot;JBbjPpnNmAVtTvBoUpPHMmVvhfFqQuqQEeoOsSciXtTxwsdIfGjpKwqKjaAzxXnEiZAtTvVanE&quot;
    &quot;emZAaVvKXxkTtgWwlxCFAaYykKfKtlLWwfFBbgTtBXuUGfcCaiuFJMmVvjfUgHhGOofaJWFfat&quot;
    &quot;oOTAUdDpILcCwCIicWBFfoBHhbObKEekqSkzZjJaCcpIiMmPpPWmguUkzfdDBxXtToJYyzPich&quot;
    &quot;lyYAaJjUeHhdfFHhlLEeVRvVFmMJSsjMgGhtXtQqJjTWXPjJphHuvBbpPqQVSsNctvyTdDtsPp&quot;
    &quot;HCgGcwWWwybBeYNnYOoSsyVUIirSqvVoOoOjVjJvJkkzDqSzZsDMmdQdSsejtTGgJEfFxrhsSs&quot;
    &quot;BqQVEpPjJjJjwWohvVZvVAaSuHhLcaNNnnmMyMmkqQYDdyzOoPpnPpNZKSdWiCSstJjTkKcCnc&quot;
    &quot;CneExXTpPOsSoUuHhJzZjpPwRFCcJjHhHhmEeYycCbxpPnnEjkKJevHRrNlLDhgyYPlyYLVXnn&quot;
    &quot;NvVcCZpPkkKKJlLqQjzZXGglFfJTFeQqhfFHEHbBTtGgKkhRQqrfKwWrRsSWwkIcCDdfFBbAac&quot;
    &quot;CgEeGsqQGzTrRujJqQGeoopPceIYHhuUlIywWYQqiQqbompPwWLlBbIeEqILlitsONnZZzJonf&quot;
    &quot;kKxtTRroHhrEkKePdgFfGDpEdDhUukKQUdrRLFfXcgeEibpSrqQdDJjwTtWnbAjoKOocCkiCcC&quot;
    &quot;pUuqIaAiyoDdOsGgEeSKwHHhNMIwTXoZzaAociQqIufFKkUCvfmLTwWVgeEGvjJfFhjJiBbAnh&quot;
    &quot;MvVjJmHNxwWsmMSSLZDdzKkmQqYcCAsSoUuKlLPPshPpGRrBxXbgEoOcCRreoOelcCBSsbKPyQ&quot;
    &quot;pPxtXxTvvbZzBKoWwEtTGMmEegkKHhFfYnNcCAsSJhHjaRrjJkKNLaBQKkkKqbAlvBTtbnNtyw&quot;
    &quot;WYuUpPpPITQqoOXzZKiYqQYTtyqDOFEqlLWKkkKzZzRrZMRrXxmwmMdDLleNcChuMmDdUAabIK&quot;
    &quot;keEvBFfTteqQSsRrRrToOcuDdmkKWNnRPpjJBbvVXesoOSTtUuoRrQnHhhZfFAgGDPphpuUmQq&quot;
    &quot;dDXkKnNeGLvVeExXSAaieEIeiIqNnUujJSBbUwWuKkoObBXRvVoGgnklLKOoYyGgSVdDLlGBbB&quot;
    &quot;bgZzvsnNLRJjBmMDdMmAarRDdbrlyWPpKCckbBDqQduUtTGFrRMmfaAoOLGWysSxyCPrLKkAab&quot;
    &quot;BoOlsSrRRANQqnuogYyCcSkKdfFDJLIOoiCcKklDdQpPHhJjIvVyjJNtToeEOoBbmoOZzWLliQ&quot;
    &quot;qaAIaxlLQqXakkZuqhUBoOFfXxcKkCiISsDdbwhAoOKkwWaPzrRBXSseEuUxbVoQqNpQLXtLlk&quot;
    &quot;uUwRrvfJjXxSDdsFaAbFfpjJJjwOoEezHxXBgcCJjsSxIHhdqQDhTzXYyaAzXxuLOoCcwWnNTV&quot;
    &quot;vMwDdbVoqNnCYVvyIiSFfsVOVdDvofTGztFbiIMmOowWHOaAuCUurIiSsuUFVvIivdDvRpPdIk&quot;
    &quot;KiDrlLHaARrjJlLhnNeEBbfFQuUBbmSsPsFBJRrmRCvVRGsSgrpPcOowQqFfWMuKKRFIKDHhMf&quot;
    &quot;FkzetPSGgLDdgGWUuzcCXHeDtTdbIMARrIiiSgpVSsXCnZrIuXZzbycjkKJCYCcfaAKkHDXxdi&quot;
    &quot;BLlbNnCgXxTOoavVHVvuUdbZnfFNwWyiIRiIpbBgGPUusSrrhEeHRbXxBbiItUHhuIiTgGfFhH&quot;
    &quot;qHKoOtTkhQxrrZjJZRoGqbKkfaAEeQrNDaaAMCXqQxcmFyYKJsncRLlCRQqsSrcoOrAasSYwuB&quot;
    &quot;RrFfHDHhdhUntgGkKxbPzpPZpkKiIiItTAZzqQJAarRXxjMrRwBbyepPFfEYyZzwWrRTtUDdDV&quot;
    &quot;joHfFyDdhHQqnqQGgAaHQqhOYGcUudCcvsCiIxXczZkKoDdOBZHwWEPDdpeYyPpwWdDmFRrfMj&quot;
    &quot;JYAayqKkQdtTLdByfSNeEjlLJwWRzZrRqfFWmFfKkOopEelZUktTqQdEeEndDrRKsSkiTpyELl&quot;
    &quot;hHeoOsncreaUuAGrJjRIidJChlLHPhHzSrRqlLsSXxzZQWQqIuajJAUkKwWlLEvDdVkWuUEewK&quot;
    &quot;lSzZOoZIYyzZbwWDdMmgrRozOoovVOUuFIcNwWOoyhcCHWrWcCjJXUpPrReXxWxXgGwPTlLhHo&quot;
    &quot;AoOaOUuuUtdiIQFFfNntLlaHhxXASsTupenNERMmXdDDSpdwgGWDSJjsNnrRrRVLlbBbccmwtU&quot;
    &quot;udDcClMTtACWwjJsSpPpLWwsSloWwrRSsCcRrGnNgGuUhgDdGPpRzZNPpBoKkOCbQzFfsKkDdS&quot;
    &quot;PpchHKxXzUUdDuuYyaAsSkxKkrRrNaAnXTtxGnNCcxXaaAOopdDOowWCcssSsnVvsfpPRvbeEI&quot;
    &quot;bBCkaADdxWDdNEenwRrKkEeXAZFfDtpPWwTdzGgOobBfEezZYyzbhHtTNmEtTecCqQVPphRBnN&quot;
    &quot;bryYMpPSsrREAaAaPtKkQqIRJjrsgpPGSMfFpfHhFMmVfFMmvVWIZtTzaAiwkKvBbPDnNdDQqW&quot;
    &quot;WwwhHXZzoHhCsScFIiXxfzZMWwHUuhMOSJjsySsYfKlLHhOweEdDWWwgCLbBNnnLllbiUXxulv&quot;
    &quot;VgCOMmgIiGqQUuxGbBAaGgoNmMfMmnPWwgnNIqsLlLlUJjuSQCcDXqQHzZgCcnNGHhhVvQSbLB&quot;
    &quot;uOfYyBbQsSqFXxojAgGvrRqdDQcvlLVxXpKGgEUuekGgKCrpXxMmkSLlNHFfVvhnqVrbBtTaAZ&quot;
    &quot;jkcCKJEemijJIMzKYJjJjEeVXTtxAavmlCcKwWnPJjpNCcvVbqGwWgQSWwaloOLAstfAxXWwfW&quot;
    &quot;wBDdSsfFUuMqQpmQgFwWZzQCkKxGbBcCgWwnNAaXSsfSGmwWiIVFfFuUeiIEpPZzrpPTtNwaAu&quot;
    &quot;UGyYJjgeZzEfQTtqWwFTtAatiAaSMmGgoOsNndrtTsSQqgKkmwWXuUlLxmMlLAaHhCctXxwWwr&quot;
    &quot;RriIEeJjbfFOofFJMmqqLKklQQQqfOoCcWwoocDgSscYGEyRbEidTEJjebbBBjJWwMILlivVJH&quot;
    &quot;XxyFflxXPUGrdYyDcRrCUKkuNnoORgIiuIipjJPpLkqRrQWPpBzZpPLlLlLZzVDdpLlmsSNnuU&quot;
    &quot;iILTqQeMmCcsSmMDfFrIFfivnjJjJNtTjJiIjnNsSJVUGgQXZztDdZFfSsHhqrgGRQvOoxXSCc&quot;
    &quot;sVuGZqQxXzgEeNnSsyXERrdDDdqQWweMmVDdLltTvkyYKiIGgbBSsKkcUutTHhOoCuaAUkKyvd&quot;
    &quot;DVgvVGqkBbCcKiIvVxNnuUdeEDXglLFnPVvpzAaZzSspHhCcPHhPpXNnfFZzzZxjJaWwATFfbB&quot;
    &quot;yHLljUuGjJzZuUguUfLlFBbOvVoPBbdDpjjlaALejJPpHTtQqCcRVvrlyeExXGHfMHhmgGFhvV&quot;
    &quot;sHMmviPpKIqRrPiIIiEFuUaxXwWAbhCcpvpvVPooOWBrRbHyYRKwhHWbBAZTfkKNhHwWkXpmMP&quot;
    &quot;KkxKQjsLUumoOMzZRlxbBXbBuvrfFRBEebQPpcwcbpeEPBQCPpgGrnNRntOHfFrCcRgGhtbiIB&quot;
    &quot;OdxXNnDgoOVvUujJGKjgyrdGgMmgqmMnRrZpPjvCcVXxeEJgEeSsGihHYcCUfAFfxYyXcziIuU&quot;
    &quot;oONZuJjzZvkOsgeEzZVviIBfFoObnNglxXwLlWFfIiLlJeEjFftTZzLLlIrkzZKRcaACiuUdpz&quot;
    &quot;ZPVhHqwWQvqQDJPpfWgFfVBbNnoMVmXqNnRrAaQOonQqMLlmUukckJvszobXtTmMjJeEUiAVMm&quot;
    &quot;vyziIUoOuzZYPuICrRchTdDtbBTtXxQvHhbBQqGRrgAaqjJlOocfFCCbCcBQnyndDFvVffHNbx&quot;
    &quot;HhhHIiTtlLXMmBmqQlnSsIhHitTNBbHhpSsDnDVXIisShovlqQPEeLLdtTOoZoOzDoZzOtMIhH&quot;
    &quot;chzZHLlDdCEuoNnOIOozZgWwvVvVWzdDvVRSsVwWwbByrRYVvrRvVfFONnzZEtTEeWXDNndcCu&quot;
    &quot;LlrRoOpZzGgbBChHcPTtWzBbwWGFfgZUGguwIDdsSsSFfYLlsSrkKRzZBNUuVsSLGglSsnNvHJ&quot;
    &quot;HpfFWeEjJxCMhHmMmRruUuonNrRjuUJOUXxSsgGPAaBbCcZzpsQqoOLlWVwWyLlIiYSxXidtrx&quot;
    &quot;XRTDKkDdkKdwwWUuOfUXXxxJwWOojYWQqOoOocNVvnwWxpPrRueEwWsPpYySFfwWBblKaAkjJZ&quot;
    &quot;OVvozDdYaARCccCreEyRrARraepiIPoOjJHhEeRryUuwWeoOfFwkKGGggPpQYGgQgBbLFffhKk&quot;
    &quot;HkKeysSYGgQPpnNqXkKqQwWirzZCwacdDeECAOoWcTtgbBGeEIWwWmzmFHhsSFfsSFnNFYCcaA&quot;
    &quot;yfpwWdiIDTBbhHWwdDVCiItTcHhMgoOjJtRAnNlLarTGGXHhfgGlLyxESswWFftSQqsQYJjlrR&quot;
    &quot;LIiPCjJxiItTuUjxdDXMcCBUurRTtpTXEZzeaAYEeyWDdKMmJiDdIUuEeVvkKHhVvKVvAQKkqf&quot;
    &quot;uUxXFRWyYwvUudDVslLvCcZzVvwsSWCOTDdkzYKkyZibKkmZkcCKzOoQqrRvVkQQqpTtFfZzkK&quot;
    &quot;NnPpMmPnNTHWErReXxrRwpdToOoOtKpghuUsSHGLlwWPiITiItQxvdvKkVOoxnNXDqmuyYvvjq&quot;
    &quot;QvVhHLAXzZfFGgWwpPHhOKkmMKkhpPEeTtXxKngGVvUUEewBJUuZmMzxXHFIifdDFbBsSiIRqq&quot;
    &quot;QQruUEDKkdTyoOYSSsSsvVidsSrRcFfCPplLDVvZzNntJAAaajrnNRecCEISeTlLjZzXyYxDnE&quot;
    &quot;YUhHNAanuwfBbjJFNZzoEaAhHezgcpMDdmnNPHGguUhwWLlcCcCFCLlddtWvVLLsSlJjGgEXdD&quot;
    &quot;oOLwWjBbJjjCcJDdJWWwwlVvkKUurXOGEeIigoNiInVMmvxCcbWwBwnbMmbHhBBMaPpmyYvVrR&quot;
    &quot;iOAZzaogVvkKrRGWwZzWqQpPpPweHhybWwKdDkBzZLlNneEMsSxXmYlhTbBtxXDlIiONnozSGg&quot;
    &quot;fFPyYcjJCXxpiuKOokUCWvVwcCTtnbBNbHhBPpMMmJJYyTtrXxTtzZRUIibicusSUhIKkaAoOu&quot;
    &quot;UjQLyjJYQCsSGXsxXSnuVvUKkyYxXWAEeazZwXxEejLpaAPlMmbBhHAlLPpaSsJMwGrRGggXxp&quot;
    &quot;aAPWiPpUDdvVFfubBqNkKlxXeEeEDfFdirRIDdgGeEveEVpPCcrUpPlkKLuNnRjJmIiAnNtTaM&quot;
    &quot;DdbBLIiVvOGSsLloOaAQLlIwWyOocCtLzZlvdVmMSAaaDTORxXaRrArxevuzZpvVXcCIeEiVhH&quot;
    &quot;CaAcbBjSoKkDdOBbgEFQqfEaJjfYtwQqWTzZzZyFAcCyYjJarRqsSQywWilKkLpJjEQqmMdDaA&quot;
    &quot;vaASpEebBhHXPpsSxgqQUuhKkFfvVhHSxXmMYyFEzEenNJjazZAIWwhHSsWwZxkKiIXEyYeEKk&quot;
    &quot;GwIiWNncCAlLtyYTalzRrZbBVvcCuxXUHhwEwWeBnNbLlXxDTQqbBtrRgnNGdWwTVvdDlUuHxm&quot;
    &quot;kkKyYEYhkKsXxSKCckdzZmMHhHqQVFlLJjXxzZfUXAauURNnrxXxyYoOuMmVvmMHhfSsdeEDNn&quot;
    &quot;JrRMsSENnUueEMmNnWWwKNVvngGkkKwwWZzNQqivVQjJqtTYySGZzncpWwPCeuNnUFaAcCfQSs&quot;
    &quot;LxXefFELllqmMUujJHhhHQnNlmPwWpMnuUNRrEeVvAaLnNoOhfoOeGdqQVJjpPcbByYDdzrRPp&quot;
    &quot;RrHhfKhcCwWHFfQqjJkFPHZzYXZzjJeExpPTIVGgRrHRrOohUutWwTDPplNnLvVZejkvGgVyXx&quot;
    &quot;NEenHrRhNZzXxnwWWwYkNFfnmITtinIiNqQaGgQZqGgQRrBvkKvVJKkjVfiIQezZpPQOKkKqQo&quot;
    &quot;EAIiDdaGgYyoOeOtQKknhHNhHrjJfFBfFHWwCchCnOGgLljJadMmDtCcDdGgeEnNkCcKdAAmDd&quot;
    &quot;iIMZzKkWQquOoSsxXOogGXAaQqxoOhHEenNnqlLcIcCAlLHhtTzBbyYDdZfFtTzGgZYyEeSFPx&quot;
    &quot;XpaAgGbdWwSsyYYJpHgjJGhVvHhPEexyYMmkSsnRrLlNxXVVytTeEbBYTtiIAaQLlkKqjJOovv&quot;
    &quot;eGgEfFIpPizZimFZzJoODDdJjWdGgDgGRnkDdByYbKDfuUQqTJwWFPIIiXWbzZByaAYwWxXUuI&quot;
    &quot;iSsUsCAOoWwaWwcSyeEYLlTWwlLreBMKkrRLlakKAfNnoOjJUiIpPCcrRQqvZzgGVwWpRnNRUL&quot;
    &quot;AmMBzZPpbVWwXwWJRBbrEesSHKkhjJqQKmDrRAagjJkweEWKQuUGvVmAaMHpPhJvVHcCekKdbB&quot;
    &quot;KcCyFfAaAaYSftXxDkKrKeEcCWwMmkVsRrStEBmMovVMmdDOzxGMmKpgDdGHcChaAIrRFqbBbB&quot;
    &quot;dDsSBbQqDrCcRIIiqQiiIxXdvVvavVmlLMgZzsSEegGGTJjMHRrhmYJjyFftTtsfFSCcsnlLiO&quot;
    &quot;oIKkvwjJWgGmMOoRrVVvfYyrQqROoZzFRgGvTgxKBbNnkbxXBBbOoUXxubBTtgnNGXYyJjWSbB&quot;
    &quot;iIsWEecPpFZSsSzZWHhSeEJjJCcjsDdzZcnnVAakeERUunNQUuqRrwNSeEHhwWQqQRrEuUfFId&quot;
    &quot;DBkKbNUungGoOwoOWQqlLEQiIqXgtTEApfFMiIjPDdpRrsOfFlLoWwKvVlByYbVmfFMMmZcvbB&quot;
    &quot;VIiTtLlLbBCcHXxoOhhpPShyLtTOolYOpOQiIWTtxjJJjTtyFfYAaAEeQqSszIiZaRvVUurvVv&quot;
    &quot;MmVYyqMYVtgcCGTvyXwAaqqQQdhdeEDCfFcRIiYoODdAarWwMmhnNjJJjeEpPICciMVcCvmhHG&quot;
    &quot;gvEevVDxvGDSkKsnMXDWlLwWbDCcdUPpmFdDfDdMbBRrTKTtUQquCczZlLTtiKkIEeKwobBOWa&quot;
    &quot;drRpPlHhJZfRrFzBbAOlqQLKkXxYyLSsMmIzZiDFfpPoOEeBOiIhIiOonDfOoOoqQDdWqQdBJj&quot;
    &quot;AaIayCVjJvyYOAalLoyYOnNAaFnNvVflLMowWLlNnKkjJKkKknNCiIekIZzwEeWjJiHRrhIeET&quot;
    &quot;iwWIOhHozDdvVvWwXxokxXKOQEbBajyYrqQpXNVvmMnxElgGTtLeGgiIHNncUuvDdbBOVqaTte&quot;
    &quot;EAwWUuQqQqGPpOogGgLlhmMhHHqQowfFHhWXxcBbYyfopPEEeuUuuUxNsSAaAzZUufFdDaKWwb&quot;
    &quot;BWwkqrTtRIZziiIgGCmMhHpPcKkBJjxEeDhbBHfFdAhHMmalLsoOIiSXyYSvVzoOlcCLUuhHWw&quot;
    &quot;CHxXWwhLlVOovWKkwHmdDWKmMIeEANOouDpmMaAIhldDlLLDCcNLvVcCcyhoOHYRrMmCIiGlbB&quot;
    &quot;XxtElLIYwWwWuUfzBbZTtgGbMCcqQtPpWgGkKwrWAaxXvVIiDhthlLgaAGHzZnNBbwWTHlCczh&quot;
    &quot;HFZzfCczZZMKkmqQXFOofxEeGQqgLdAgdAaCIiXKkcCZzxjYyTtJITiISwWscEeCWaAOotTzRr&quot;
    &quot;PpZtTlWwLmMpUuLtTtJjTNkKszZAMmaBtHcOhHLloCglLGcChTlWOohHzZIiITtCxLlPpfFtTK&quot;
    &quot;LiEeMmeEUlLdDuuUoTtnNOfFRlSswzZcGgCamMfMmFHhbIiCugGvVtTUuPXxpUBbjJwWzIiEeZ&quot;
    &quot;dVCuUcvkKGgyXxIiXxhHzZEeeKkcCXEeEXxzXxYyjJseESIlLEeVvIiKohHxXBvVboOGgQHhqg&quot;
    &quot;GoNnQqXWbBwCcHHDdhRrYlLyYYgGyIJLAaXxlcCaYyisSDeEaAbBdMmoOvAaJcbBDdMxvVjJHD&quot;
    &quot;zZABbJFfIijatTdOcChqQjJPqOoQpOozZVgfzZXeExUAaUyYXbPpBxuBbMmWwGfFDgGZzbFfBu&quot;
    &quot;UsXxCDkKdYmMlbBEeLJjbhLlUuJjOoqZdDiItTOaeBbLlEhHJvVjXxKxvVVmUuxXMuUTtpZzPS&quot;
    &quot;UuWcCfFFuUfoOgTtGUuJjgGkAajJKTEetsAagKcCbBdOhHoKhtBbwWrRTHIiDddIltfoOFgWwt&quot;
    &quot;AAKKIUZkKzHjJduUDGgNnyYjJWwYdDyRrxGgpQgGqPmMVvXrRGgQqhKwnNWRUurbGgBaZQqRpP&quot;
    &quot;rzAeEkxXEvnNpcMmnNeECPdDRrlCcxVvXxDPMmvVNLKuUxXFfIiklnofFgGWwOPpdDGgyYpPsS&quot;
    &quot;YyuUhHTtFfOiIomOohHcyYCMoOhHmYZzyOgGaAOoYyohHMnNUuSfFsPxXpnmMNnGgLlNMmuwWZ&quot;
    &quot;zKkZzMVzZqQcCjJRJjrWYHaAhVvywXvVaAMmMmHhUuJIiqQwuUWvJTssSHkvVKCchTUNAaDsDd&quot;
    &quot;bBSdnXxRresStNnPLljTtfbsSkKEejJLbBOoLCuUcaARrlDdXGNngxHtThkKhbBjZzugGUUTCs&quot;
    &quot;SgGckKHrRHhpbBzZzPeEeNLloOZzneEvrQqWwRyYNDdJjnRrTaAuUOiIocDdjJCNnCSgGDPGgp&quot;
    &quot;dkmLUulVngGNMgGrFfjAykKHhlLuUoOAaetTElSxeIHhiWwpPHzZwWjJaAhGzZSWgGIGpPgsSi&quot;
    &quot;LlEewcjJCUVvuBbAasSqAaQpPkuUUlLuKkXxEelLiNnMSsCcTtJjDdwWDdmBbIwWiyYDdpGrFY&quot;
    &quot;dYyNnDBhHdDOobdPsqQSKsSdDHhkgGZztTiDmMjvVJjJTtdIsSFfphHOowkGSsgOsSbBRxzZNn&quot;
    &quot;JjUTtuqQIiwvVBbJjVvfFEeNkKnoTtfFqfjJLlFQOtgGTPTEGgaACcHhDYytTtUuZlLHhpmuUM&quot;
    &quot;KkWwTlRrXxMaAmeEQqyYXxLWwEMwWwWmBfFDdbGiITQqriIBbMnbBYJjMmSsbByolLmhHMWwHw&quot;
    &quot;WhxKkXKOokkOoXxxXKwIiTyjJUWKkwuBbIxyYuUxytkKBbhHTdaABmLlwWMpPMyYTtmVveEbsM&quot;
    &quot;mSFfMMmcCzZjMhHmPpKuzZUVvkSQqsiIXxuUMmKuUSshyYrRHPpXxongGMmilksSKLYyovVOIX&quot;
    &quot;iIMmNnVvCGxXgVvrPpRpPcxXYFfyXdpPQqIioHoOqQhgNvVsSnGyYZAabBmPpyYzMmZGgwWMdD&quot;
    &quot;oOCnaeEGDfFziaAXYyxICcWMlLcEetTUHhUuSsuuUfiIVAavFNvVnrRLIiliIduUnNLDhEeHzZ&quot;
    &quot;NnXxdTtMGjJWwgDcyYejJshfFMLlmPpWXxRryYxBrRbUuDRrhHdNUujAaJAdDaCxvVXxSsXsSM&quot;
    &quot;ENnZOSsqYynvVNBbMyYEeDdhEeHmBbblLVvqeEYyOobBuUCcCcCjJcSjJsuaAUMjJyYRrdPMUu&quot;
    &quot;mYJjyxMihHIHhkpPPpKeXoOxEIigKkGgGmaAsylwWMmIMmNnCIfFiCJjMcCmDYyUKRrkWwRrsS&quot;
    &quot;hHIhHFWxNnPpuRrMMmmMUAaumXlLHhKSsvVSskxUkdDKqBbQpSstUuTvVokKOPkKrUuRgGJZvV&quot;
    &quot;tTbsbBvVUuHhhHxUWwiIhHFfKkumMjAatMmlLKkiDfdDLkKAaevVZzZzpVvGgboOBPEliInKiI&quot;
    &quot;STtXqnNQxBNnVvbWwBboOwERcnNzfFZzhFfHPrUUuuRpDDHhddRrXFNncCoEWwEeRzEeEOoCqQ&quot;
    &quot;cTjJtUuKkFfeOZzRrIDdGZzkKgUpVvPGgvVHhuotTLlHAahAaOoxXlUuLYyBViouUOIvbPpWuU&quot;
    &quot;uROorUiIuLdDQqTtLlVvXxBOocCkjJKzZGgJjbBDdUDPpdBbjJHhUqgMTQqiIvVtRtTrsRrzUu&quot;
    &quot;hmMHvVHhglxXQgGjxXMmyLlYlLPpyYJqJfFjhgGsSxXrWwFfyYLlVvqdTtxXeEgGihHfFIIitT&quot;
    &quot;jJpPwWBbYySsbBrRDjJgGNnfFvxXgGfwWSsFSsjyYJVaAtxXfeEeEkKaNnUfFuvOosGgSjYsSa&quot;
    &quot;AnNBfFvrZPpwWnNTtSsgMmGgqQTtRrMmwPpSsWhRrvViEeIHhHHhqaAQGJjzkKppPBbPZpaAZz&quot;
    &quot;MmUuWgsVvmMcCgGLlbbdDBdEeGgDbvVhAaHdDGgBBlWprRPEewEsSYyEepPeEeLSrRuUIWwXxi&quot;
    &quot;zsQpPkKqfFSeEUdDZlHhLNnzuPWwcCnNmMJjrRkWLqQJjYyixXvVIVvPpOcQqjoOiEeIeEJCoZ&quot;
    &quot;hyYpgxUVvugjJGXbBkKLqQlETBuUbteUroOVvRBbiIdDZWwznNBGgDdsSbuNvVsSIieKiIGgjJ&quot;
    &quot;dPoOpWwDyfFpPYIikdDTtpPEaUuAIizZUpPuYsSCcYyIFvNOoutTUfFyYHhWxXqQoyYOwaAvVy&quot;
    &quot;YKkngGJjmGHAaiICcSRApPJjeEaSsiIeIiEdDrsQHhWwKkYyuUscCFVvfSAwoOyYWaYyeEUnNC&quot;
    &quot;BbsLIilSvZNnzUuVuUpqQZzLlPcCsScpEBbNdDnegBbTtGPyOoYyYPvawDdWtJjlkKQlLKkhHq&quot;
    &quot;WwSsLlfjPpKkJFjJRrEeHvFfVEQKkqdDJjXLhHlTtJjxLlWtRrTIlLiZhJjiIHzwxXjJKcMyYm&quot;
    &quot;CCcHhksSLlenNWRrwScZzCDdsrqQRgGzPsSpBALlFfacCEzZOomMiIejGgtTJoOlLBbsSbzZpP&quot;
    &quot;BZzTtJWwjLSslbBMsqQSsqGgQGgSqlayYeEAQFNnfqhHJjPpAadDvEeVcCbBpPKgGoOkRQqrer&quot;
    &quot;REGwWfZzFeEgwmMZpPIiUWwuAazpbBvVqQPtTWStEeTvVaAskXRrxHhKbNnqQBIpPiebIgGasS&quot;
    &quot;ACciEwOoSsWiIZzeBMcCmpCcPEFEefrRCZzcVqAaQJjvJjKZznaAaANAakoOPpbJjBDUvVudDd&quot;
    &quot;YsSyIiBbZWSAaAaHhValLAwWAavLlHxXheEeEVixXjJIEyYxXiIxkKwvVRrOorRWwWQlLqLlUu&quot;
    &quot;sSJjbBhlLZgGzGgncPpCNjlXKkxLoORrJHnPVEekKvpNWqKvVTJjtEuiIUwWwWCcyYPWwpcCji&quot;
    &quot;ITtYcCyECceJjpnNPJBkhHfBbzkKMDHhdmJHhjtTFfyJjHhdUujyYXxJKkQqDMwWuUmmukKUZz&quot;
    &quot;jJuUHOoOoDdqQqQaAUuyYrHhRkKbBWwhazloiIhHRrOLPpDNnZZzLzgGZYNnqQylfFaAeEiICc&quot;
    &quot;zdmoOLeElmMnWLlwvvrRVaAVPsSqQpuUzYyRrZBboOKkgGTNGgntMmssSbtLfmMFciICdDloOT&quot;
    &quot;fYyPpSNFfnWwiuUIBwNnAaWkZUuIiQqzKXxvoOtTmMbGgcTYydDRHtThrQqlLwAaalLALAalvV&quot;
    &quot;XYNnNPpuUKkNLlpPkKnhtTHtTXxlEnNeAHhaUuVAavLHhBbzTtFfZGBbaAJjvEeVxXZzgKHhkg&quot;
    &quot;pPxXPfFeEpGcCCDdDdreJjErRHhxBbzZXxXCaAyYclLDvPpVtTdCkDdJjKmmMlIiLMmMKkYXmM&quot;
    &quot;QVvXxUuREeJVvqQLlBVvZzbjOGgSSsoOsGgHheEdDoRtTrXxWoOwOjJoYyMmVvAaFBbfEeTtqK&quot;
    &quot;zZkIEepPNuUnEeGbBlLcFrEeREwWqhHQmOoMXxeAQPjJpJjCcoBbYypNYynWwIiaVvAcjJeEAp&quot;
    &quot;PRrNnICcxXiaANnakKEehHRrgGCPoOsEeStTdfFDpPAaNnNIiTtZznPoOpiISsXxjIMpPmtcCT&quot;
    &quot;ieIHhSlLgBbGglLLlheEtspPxXSTTrRlUDdupyYYyhHUNnFfpiIxXTMmtfXxxXFPeEmxXVKkfF&quot;
    &quot;vCcrWLVvlwRqRrQFfPVvFfFlLZzdDfpHhbBWwyxQqXZmMVgbBGvlUuLxXYyzAabBCkQqZqQiIm&quot;
    &quot;RnNrRhcCHrMpPQIiHDdhqdqQMmigGrRIiTtlLZwWYyEPpekHOohVvKDdRfSspiIPZLlzFrNnmw&quot;
    &quot;WtTMnNrReXxifFIsSwuUWEOYyKrRkfrfcCFtTCcwNSsnWJOojOUXsSxBbjXxjJJuFfYMmCcyGt&quot;
    &quot;WwTbBLnNyYlOohHSsLlgSDdoOHhhHsMQqYytTHtTjJOoLlhKkowWUbBTtsWwSuNnLlxXrROcyY&quot;
    &quot;ZfFzvVCZzHhqHhNeiIckKVvuUuJjiIJjUXxzZCEGHiIyYhgDsSHLlfFUuhrNnRaApAsSaPXxdk&quot;
    &quot;dDGgKzZntWwTkKbpvVuUGgPQcCqUHhuWwNnuUEelLYVvhHyBvGgVrRBbreEWwRsiIHYJjAIiat&quot;
    &quot;DdaATWwyOohEdmMDYyTtYyDdJKkKGgkXLFflwEeWUuGgfVqQvBbFYyeEtrRCTHhvVTtpPtdMmD&quot;
    &quot;iINnrHhQqfFrcCRdQqkCmMtTYyeEcGWwtTlgSrDdVvRsGgaARrOAaTtEjJQHhqeoWffFFuUwRJ&quot;
    &quot;tTcuUCjruUmCcLjfFVhHXxrsSRnNuUVvaTtBnRrNiIbBbAxBbpPGuUgBbXbByYqQkKqQaDdALl&quot;
    &quot;IiprTtROoPwDdGbBpPIigWxCcCtTcImSsYyMJjuJjUmMpPtMmhHpPTGgjJpPaAcHhCiTfFEcCe&quot;
    &quot;tVwWvKTtkKkiItKkIiyYQqOoTVxXgGJXsSxWwrREeJzZjpRoOrPnNjvoOqQruURNnhHmJjMKkX&quot;
    &quot;FOMmofFfNnbBZzJjpwWBbxXPYytTzZuUYEeyraARNnpKVSsvkFfVvAQnNqBbitTfFgmMGIoOPp&quot;
    &quot;hHaTtTtMidDIWwRDdrRrcCvVqQqyYmeEMWeErRwcCXxBbryYKkRxXRHhmeEMmsSMSsruUFAFfm&quot;
    &quot;tTMabIilLFWRrwfkIiYyeEPpKfFGgFffFTtBaAQLEelPyVvYpXlLPpYyxqxXVgGwIiWkLlKfkK&quot;
    &quot;zZFZzwWVwWLlvvgUDduaAdWwDWDdwDdDqQdsSlLvVvVqQCcuUkKsSzZGjJoOfMOojJmlLjqQJj&quot;
    &quot;JQtTVvapPCcAJXxjXxerRhHESsmxJjnNWhHyYwXOoSsYyxXeSsxXZzZzLlhXxHEGjJgjiIJGha&quot;
    &quot;AsbBvVeuUFzZfZzESgaZzAzzZvVZbAaBGtTHrGgRrRBhHnaANbcsxXSApPonNObmMBanNtTkKY&quot;
    &quot;WwaArKuUmMoOyYKkkbBWwfFRrRTtGgTpPeEtsWNNnnRroOjrRJwNcDduUCnORBbrGguUoZzsSs&quot;
    &quot;SUNnuAaPpIYysSiNnhHdDFfkKSsQCXxaAEUuecxrHkKMmhHaAhQqtxXaAOHGghZTtzoTFfOoiI&quot;
    &quot;cChHnNUmMuYyRJjdMmDPsSXxTtppPqQJjlLZCcHhqQgGzXPTtpMbBmqqQQAuUTdrRDnNxXWwtv&quot;
    &quot;VYyiIIigGOoVvYyHhagGZzKkqVvrlLdDROGgovVKpPkBbwWOotTOrRgGWwHhfFKkgTtGWwNnwi&quot;
    &quot;UiIuIQDdKkSsSsYQOoVvHhaABbsSDGguUsSCzZcIxXidziYyrrRRIqrRGgQWwMjJmFfZJjnNhq&quot;
    &quot;QmiIYyAaMhnNHiInNMyqQkKIGgiYQXxqoOTpPtmyAaYpPqcbBCQqXxpPQExXexXiIHLzZSswWl&quot;
    &quot;LlJUugGjoOrRJjqYyrxXRkoObFfDdBWwKkkKnBgGUubsSNqQpkcCKgGPdDgfFGxuUmCcfFmMSB&quot;
    &quot;LlDdPRrkzZKIigGfNiInFYyGtTbBgnsSzZhHoONgOoGbBTFfrRzZFfgQqGyYmsSMtnNCwpPWwW&quot;
    &quot;rQqRcoOBbhnNHjJpTtTtdbBfFSsDEebfFLlBbmGTtgMHhaAhHS&quot;;

int main() {

  int64_t input_len = sizeof(input) - 1;
  char *s = input;

  int64_t i = 0;
  while (i &lt; input_len) {
    if (abs(s[i] - s[i + 1]) == 32) {
      memmove(s + i, s + i + 2, input_len - i - 2);
      input_len -= 2;
      i = i &gt; 0 ? i - 1 : 0;
    } else
      i++;
  }

  printf(&quot;`%zu`\n&quot;, input_len);
}
</code></pre>
<h3>The x64 implementation</h3>
<pre><code class="language-x86asm">BITS 64
CPU X64

%define SYSCALL_EXIT 60
%define SYSCALL_WRITE 1

section .data


prefix: db 1
input: db &quot;xPGgpXlvVLLPplNSiIsWwaAEeMmJjyYfFWfFwpPqcCYvVySsAUuaCcDdHlLSshxKkMmXQnNKkrRptBbTqQEevKkkKVsSmMmMvqFfGFSsfZzgQTtFLlfsSFBTtbfbBiIAHhzZaVNbBOonsfFSBYGgRryvaAVTtbFfqaAEetqQUubBTyYAWwzZeENRrgGaAfFnNnpPJjulLEeUaQqnNJjQtTPTaqQAoOEerRtnVaALlhDdPpHvvVrRsFVvfsMcCvkPZzpKbBOofZzyYFzZsAjJavGgkKRrVwWSYygFfGLrRLlgGlVaAXZzHuULDpPdoOlhgGVoOKkVvaAhOoHIiBNnxsSXbBbvVFfvtTUvVlaALPptTGguPpjJFmRrMqjJOOqQZzooQRVvrKkpVvPOopPKKbBkYykYQqPpPpoKkOihHIECcJjeyvsSVpbBPGKkgfVvHhiIvGgViXxlLdDIgGKMCncCNcmfFDDdSsXxqQtTaAdenNdDVvPuUpVvtTZzEQqyoOvVTxXtbBnDdcCZWwrRzNaeEAlDZzeEdJlelLEzZhHhOoHYyKkLjWwNnLAjJaiHhIvhHHhEhHeSsSKksXxVvzZEevVzpliIRPprLPcOHhsSoRSsTtrlLCiISsJjMmZvnNoOVclLCVzZMmKhHkqWufFmMSmMkKsiFfoRrOIUozZyYNnSNnqQsTrRtSHhNniIbGgCcnNBxXSFYyWwfgFRrfaROorAsxXSGsSKBbkspPIeoOHhEiXxVvpPUfFuyYypPynNYpPSskdDKjJCeErRtxXTHIzjJZihoOZvoOGfFWwgVzCUuaXxAeEnBVvbNiIAaRdDxXrmMcgCyYceyYyYEEMmgWwGOoKkqQkeEVvGgrRJjrYyEeRKYyOPZzJjpooOcCrgGtTOoRNneHiIXxnNIQqzZiHhZgGZzyYeEuUOmMbZzUjaAJuPpBozZzlfFLiIphHsvVSvVUTtuDdPhPVDdPpvYyvDgGCcdTSstaHhcCHhAJgGLOOoaARVCclgGLvrsSolAPpUuaXxaAkoOPpeEzGgZcCjJHhKkKlYUuyMQIiqSiqQBbIsGLLGgvWwTtVlpyTtYgAaGPSeEfFsDdgGkVbBNnvQrLlRqYWwyEqQLlsSSVvstTghHGeKkKQqhHHhmMoYyhsSAaHdDuUKkOMmDdMmgGgQqRnNTtVvryYlDdrnNLlRUcCurRgGZuUWwMmbBTtjJzjJbBdDaAwWLjJKDpPpcCDdHhPRrhHRzjeEJZmMcNfVvlLvtTVSsxXFnVvTxtTKkjkAaKhzZxXfFHuBbkKTeEyrRcCYTtGgtuZDdjJzUUcSsCqQgGuUqUulLRrwWQeHOohSXxNnisSIWHhwiuUIfFVMxUaAuGdDgXmdHhDUuTFWwftbBvVKAakvrqQAayYWwRCcIvVijJhHrSNnsDaAdBbHLlhRPpAqZzQSsaQmOpPozQLlqhHZIDdisdDSyFpPfEJjeYowWhHrnNRRUuhHLeEdDlkKyYkKqQCcEexXifFIYfFqQyFzDdZcCorRgGzqQZDdzIiMmwWrRIIjJihlLHoOyYDzrRuUKbBvMmeEKkFffFsSVcYJuUjQqMHEeeEhbBYyucCfFGDdqQRmMHhhHqWwoOQTtrBhHxXCcbggGGpgGPgEecCYyEeEesSisSeOovVcwWCEIPJjnlLTtyYNLtfFHzZQCcqLlyxXYSqvGgVQzZsBvVDoOdlLbfFGxphHqQPHhmMdDGgHszjJZShXxXYysbBifrRFiIxcChIiHgGQqqvVbBEewWQxjJZmPpUuMzXlYyHhLXDvVBbdEsSexsSvtTrReEVnNmMTtXuKkjxXJMyYmZFfzUMmyVvTtFfYdDExEeXvVooOOjJTtCcUrRSwWsbBbhHtTBGVvgNDdnQqukKGgJOYHFfhKfFkSnNkKOoOohHsSnNsmmMMvVFGglHxXhLfFPsKkSpfyBbqQqaxXfpPZzbBCggGdDPlBbLaAZzKeEkYJiIemMtYyTlLjJEjXxsSyLlXxCckKeEuUZzrqQlLxXafFeEVvAiRrIRpmiRrFfbBzZvHhVICcoOMXxiWwNIinkkKBbgQqGPpLlKWhHwszZSQuUjKkfFJcZzCVvWeEYywtXxTjJzZkSsKfFeEcCrDhXxMmrRjUuOoYyJQDdqHwWMmLlOodqQMmqGCcgwWpJjqMmQKkPMmpPBbxnNzZyYySscTcCFftwWOeEoOobSsBSsOoaAGoOgRWwcQUWOokKwuTdUuDtYyYiJjYyIyquqaFfwWAQUZtKkTBbzndDXxjJLlJjyxWjJDdLlsSMmGgtiGgIqQpgGTtDdPClLAasyYFlLKoOkfMmFUuBEerRYyGflLFDdnNFfgFLlXJjxWHhwDOoOodOokKPpMmfoOzZupPUvVjJSBRrbYLlyuUNTXxnNtUuvVVvpPQqQqUuaqQAlLMBbHhxOfFozZJjXzZhHgqQEPpeVvSsEgGAaeUucCItTiLuUlGSsyYEeRrBbZiIAPpvRrhHzqEeQqvVBbGgIhHRXxrishHSQNnyYZzxXZpdDPVWXxwMvVmmMByYcCaAEebxXVvKfFlLcCcCkZzzQqGgFIifPpZNnjJMwsSWwRrWmvHosSOhVIibMmyYQqTtBMoOYOoSsZFKuUkKZzZzxXPpbqAanNNnQyYsZzShHUuGgSiIsYgGyeeECcsAadGgDOojqQGgSstTPpJSQRrGgUunNqpkKdDZzPhHkSsrRQwtTXyYxsSZzAaRcUgGvVufNSfFsnFCrXeogGWwQqlLOKbBuUkvWwzZUuEoOKkNneseECcwWwzbBWiIwDQqdAawWiIwWNnLiQDdqIAatTEOdDoeVkOopPKvQmbBKkvVbyhHYBWwbzZrQqRZDdhpCcOoXxnayYizZIFfANPKkeELKDdHhvyYVCckkvVKTAadDsSHhAjBbeQqEJpPaJjXxaAAFfXxRrVpuFWwWwfFoOZRrzPpxHJjhIqQiXfrRkKkKkNnLlKqhhHLNWWKkwwZznvOIioMwWXxeEmYyzZXcCxVZzmMUuPKYykKyYkpiIlSAaYcCyBCwDwWdWPpcbsghHnNbBsSMlLbBTpPtEeVuUZzfciICEmMMfFmlLeuwWoOnNUgGJjiybBCJZziZzAaIjQqhHCcaAcnGgjUuPpQqpPhXxHUjJuuxNnXUYyJCcLOoImMilBbLlkKGkKPwWEeuUzZHoOqQjJFfGgCckBbKzlwKpQqsSsSViIIirRvbBiZzIZiplxXLPTjnNJVpPyYvtDyYwqQWdYyarRxXDdALlIDdTtTcClZyYzvVRvVrLtmMkKvTDdxXtVqQlVvLPNnpoaAdDeELUwWuwxXWlOxXGgiaAITtgGyYuUzZdDynNYGwzZPkqQOoKklLxBbdQqDGyYgXKzHhRDhHdWzZwbBhvYyVHLHXxhlcaACIidDVbjJxeMmEXJBbtTjBVDdpPsNnSvrRbbBMmyoBbONnwWJTtOoQqIiVhsSHLlQqHhXxAoOHhTjCcJwWLltFfetTEFWwtTIyYiYyzZvVzZTOobchHCBQSiIsBbRDAamMJZzjoOJjyYIidHhQqOuUWwOovIiuUCcVoWPhHpwdDJjIvTufFUtWQqvVuUXxwtTiIVisqyYQiISHLjJGkKcCBAabhHiIKkWCcwpPcChfFHCnNlLcZSBbfFbBgwWzWwZaAZIizGcCmSsGxpNnPXQhHgGgGFfuJRraAjOouaUuTtAbRBbrjJlUtuUEeTCcwxXrROioZreOlnncKXxkCNKZzaAkpKkRcCrRVvrPNuULfCcxdZzDZvVCfFsUuSreFdDafFAfqQWPpTeINniEBArbBRaeJjEbZnNsSFflLzZztsPpEeBbwQqwWGgQqoOFfZzWnNSyYsXKkxWwKkkcCONnoNVvGgXxFuQqUkKfjJYyFeGgEcCnNFfLldyikbiIBhHKjOoJaAIYpPIMmHLlhibBIaJjyrRYbBjJAaASsVvFuUfTMNTtnnNmFfqQBbJOoCcXIhHgGCciTtSBMiImBYybxLgGlwWXNljuUJjJbBdDyYhHLQqxXmtTMwWqQnxXWwzSsmMkBbJjeRrsSEDdTtGAagXxKeEJjwuUDdpPdDWTCcKktjmMJjlLXybBYnNMmwoOfTtixXjJDduMmdzZJjclLqiIQciqQfjJvVFOJHhnNjUuoOoFfDdpkKPHbBhwWLYGvVgSXHsSFfxNnXhpvVAaSsFZtTFfzXoOxfUJjuYyRrYyqQvVSslLPMbYyBmpIiCdkTtKDcDmiIoOQxXBfSsFHhVtTvKcwWvVdDlOoHhuUQaTtAqLtTCkQXxEFfeoUunNHhtkKOobBEisSIetTWwTzrlLGgdDRiIelLmcOoSsYyzOoZPpdgGZzDenNEnyYXbBoUuOwHOYyplLPSsoUuSECdvPpcCVmvVLdDlDdoOUuRpPUYyurxXleKkeEEAaWwHhOoDrReXxEuULEelCNVvnjJIivVPpmwWeEAabBCcwZSwWsXxyxUuXYuUdXxoOhHhHggGIPpkKiNQqnSsrReRrEGXxrRfFgQqYyAZLllLzaAxbBNnXRrtTNcyPUumMIipSsTtYzOnNMmxXwVQsSvVqvJjVBbTtvoOQcCcCVvqWbmMBSkKsoOvVUCTtcuDxiTtIXxCcdlLDxXBFbBfbpPNfFnfFHhdDBkKowWObUUuuxOrRoDUuQqQHhHhBbqrRdiNnUuFfoOINEenNOAzZakoOhHJMhHmOoCcaAQIMmiqhHmDYwWdDjJXTtnNTnNpPtCcQqiInNnNXiYtWOYyNoOmRtVvlIiLIpiIPigetuqQUPqaAUrRvVugGuUsCcYySQzToOwgDdGaiIAWdeAaFfuUtuUequUQZzBbEpbBhHvVFfWpPXryoOYUcCASsauofnNFiHhInNKfFgGWwWVBSsbBbvMmWNnwQqDdnNDywWWNnwrveEVRgvVFfGgGfJKkjRgEeYyXxWRrwfFWhHwPIKCcsytTYyYAazXxTtEHheCjJQqoODWwgGdVahHAvcZgdDEhHuUSsYxXKkyXuGgUsGuUgLjJYRrsqJmMHhjQSfwWFrRaJKkRxXGglLrRDdHhIizZBYyJjbFfeEmvRPprXxYDdFfyrRMdDQqaAnNKsLpPjJleEctfTtFonNOVENnpnNZAaPjJhrREeVvbBCctEeIioOuKdDkXxYyJHfPpvVHlLAayaAYhVvZzFfFlWwBLlwWQqyYFPnNpPOopPoyYiIOpJpNiIJjkKnTcCEuVvtTtSsStjVjpPTCcfFteEtTxJjnxlLgGlLdDwWtLlrRTyIiYMmMmXmdDMDDddHhNuUvUuJjjJlLWAauUwmUppqQPAaHhtTUuwWJjYydXeELVNneuiqQkkaAaOoKtTkaQEyYeqAdDaTIiKqQkwWcCGaAQqUuIigGiIRrTLDVvCcdbBJIijhnNHsyYcChHmMSqQcCiIiDkgcCGOomMDkGIiwWSoOwdjJDLlsZYyzlLIkKivXxrRnNKkMmXmMPpkBrRoOIiHaAxbBXZrRoOzQqwWhXxbQHhqAoPBbZzQqCcpzFfJcCaAjuUzZZUuzqiIQwGgWjJWwFdDfQaAtTHlLFgGfBbBMmycqQHhSyYdMmyYmMgUuzZujJhvcnNCPpVPpHgiIGFHhOMmNnfFoGmMvIiHXzZDdnNZzxoiIBbIihUuDmMBbdXxXcCKkatTAzZFfmCUucTtUuhHCNnjeEoOVIbBjJbBXxYDdXxJjyzZNnVvApPpxXPfFtxXYBbKRrkyTjiQzOoEoOeSsLtTlZqyhxgGOqQTtOSaAskiWwqGlonNTtfVvvVFOLEegaXxAQRrJztTrROoQqZjZzZhHBHhbeXxYQqyxEEexXYYZzyFfDcKkWaAkKwwWOozZIiBuUTtxXoOAHhsSWLCcLlrSssPpSIbBlkYyXOFCcfxXlfFLOoMmuUohHOmMoGCcgSsJWwjDdLlcpCcPidDwcOoCVvLbpPBEebmMSDyYeEdnlcCHhPzZtOozZdDhkKHTWwZzwhHBbtDdinyYNjpPJccZzVvYyChHRrDGkKUuxXUuaDdwQqKuUkLleSsERrRxXnNTxXggGGnNmMSsmpPBGgyYFyiYymMnNeTkKcIiCkKELleLmMgKkcClnFfEeSsdKLmMlkHDdjJuUiPdoOLlBbXsSxbBojcCJmMOCcUxXnaikwMmMhcZYysiIHhRrCcZzxXnNyYbQqAajJUurRQuUutTkKUnaAJsSjXRrpPeHJjoOhYyEoOeEUeOFCLAaRrloOFyoOYfWwwSrRsWwWMiwWQqWwIlLmAaHhRriIOVvQvqQIiotTcCVChKcCsSbBkKkeEFfEePdUwWuDRSiIsCcJAbHhBeFLlfjkKJqVZtiNnPpiNJjnvVxWwSsXpPINnKEyYpPpPjbnNTtaAWfFwBtTvVJrReOoEcOmrNnRuUoUuLlnNcYdDMmcCDdLlAiBOoNnbcCZzbENneIiwWsSDgmMGkKwGgEeHxXhyMzZrMmRmnepoOdDPENIMmiZzYfFVvAnLloONhHaFPKkpHhdjzZJNKkcmMCsSKkLWwKkRrdDlQqHobddDlUuoajWwmhHMXxLLlnTpSsTtPtTtNeSNnsalLAEjBbGgatTAtTJjJDAnNkinmMNrRSsIkRrtZkKzBbMmVQDdqvmMuBWkEeEexXKwwPpzZYydxXyYxmoONcCKkRWNnwZzrljJLCVPpvaAtlLwkKWTcbFfBdrRguUVXdVMLlmvwWVMyeEYmHRuUOcAaCoGoOgyxiBbIXFfuUroAOaAcClLoaeEODdRVvrHCZUuzcDWdoOaAUuDOQquLOolUojJSsxXoGgOxMmiIDpPdGguUIidDIixXlLLlmVvpPHhQPaYyAkKptTXxXjJwLlrRPpCcWwZzqodDPtToOXxPporRMmHdDsSmMsHjJlCxXdyYDzvbBPkKpVvLEekKeEkSPpZzLlOVvHhCcosbBSJmsOoSNnNnPHhKkaVvZzoOoOaAeoOoAIiaUutTgVvGtTOhHGcCxOoexXKjJLlkiJqQjDdtTeqdDzQqAaGgZoOMmDyYdIisnyYnuUNWrTvVgLSsllLGgkCcTtoUugGOKGtCcZzKlLbAXUuWwrRxaexXEUuVqQvBYyYyrRzxXZvNNyYrsSRPpHhChpdDJjPIiKkHhrRHiISswCcWwXgKkcCGxUukaAKkKszfBbDdiICSsbBZzwicCjJIfqQbBFZzBbRrJVDoOdEevjuUyYTtwGBoqQSjJsgGObtDdEeVrfkgGKFUuMmNJjWwHnNtFfTsDdtSsTZxXzWwSYmCcMIiyhnkPpsSOoKNVwWGgvFUuOofSAHhlLaIiuUAVsSvcBbCVQficoOjJVvCBbUKkdDugGjJPkacCAgkMdDmEeLlSsKBbKkXevVEZFfbHheTvpPRjJdGasrRSJjAgTJjoObBUurRcWwNnCMmFQquUvbqQBymMYVsOEeozIiLlZkDSsZzEYyhDuCcxXUOUDduKjJgGzZhHkoddDsSjGzZggJcCSsbrqQReEBPKrRHhkeEpjIioOowWOAaoOkKhHqGiIkKjJdMkjhalLAHaAlLxvaluLljJLlVvrQqrPwWwWzQqXxkwWXxKZtSsTfFuxQqdDfHhFXpPFEembBbEqQeERCcDdxXaAPpsStuBAabGHhgwzZPpxipvVkKeEfoOjtCcFgGFfdnNoOKVvefFEBbHhkNTtKkrAaZzdDrbBRwwWyYMmdBbjbBfMInvVNEeGnNgiIdDDdRrUugxXTtScAaCsuJRrjHhpPUGKZPpzXjXxuWwUcdDCyfFCrRcoORrDQqDdBfSsscCaLliCgGPraivxXFfVIAJjRuUEDdepgGZyYzQNVzZvUkKZPxpPXGgRrpzwKsSlLkMmaalLmMDEelLcCTAuUfcCFoNvVnCcNcbrRSsRTtIiqeEeENnTRrdDkLlJMmjoqhHqQqmMQWBbwEqFaJjIiWwAbzZzCtTgGcqFtTfGgSswWAnhHNhaAHMKbByYKaAJEzmMdEbBeKkcjoOUTgGtuMmJNZznCvvTtQcCqVitFffFyhTtTtpZAdDaXqQxWwCvJzaAQqAauUZwGgWjjJnNDMmDdgEUaAsSaeEMmAubBFRrgGHqlGgLyYNnEiIrBbHhiIKktRrTRNgsIMmMZzmTtnWkKQOohHGgDdbBLlxXqwemjFvgGJjhDiINnHyeKeEmMaAxXhqQQAaqrRHtTMkKLbBlFfFMmfXhLQqzZMmtKSskDiIbBcClLdpPBbWECUuqQceLRrgqVvgGQezDdinJDdNPpRrAVvOoaZefsSsdDMmHGFCcfPsaoOAbBVePIgGYVaAOoAdDDTtdIiavAeeGgGpSscwWCYlLeEyexXIiEPKkeEdDAxRrXaGgsJvxhHHxXllLLhdDPiIUQlLSsqVvflLFVEXsSoJKkUWwukKjwWsNnrRsQqSStjJdDdDFfdcCAsvSsiMmIlLDfFuUIQIicCqtTRCnNcriVHKVvkhZedDERryYyYnNzSqQsTYiHhIXxiqiIgYyoIinQxOoXxiIXVvdDIwWmUuyyYAaJjYGgdDrRSsAZTtzDdaNYyDXxdxgGgcqyYmMlVsSwnNWQTtTtqvnNqQbBqJZziHyYNnCyYIJjBbDdBDdTzZtuldDLjbfrRQjJqFBUNnujmHhcIocVnNdDaAtTvCRrgaAGHhOBbsZoOPiIprRksSKLWwXxIioOdHiIGgLExyYXmOoInNiZzMeGgfFyYIiEgGaAPpVvIYJjbncCNBTtyErRAkKasSeoZzOMUuAmNWwWFAaYyiIfRxBboOQqeqQluUwzZTMmDHhNbBnzZcCHMmhPIsSiAapDNnqQcfXxxNnrRZzXTtCGmRrtKkTMZOKknWyeNdJtlLyYgGEDdsSsYyCciTIgbBgGGstefzZZzZzhIijcrRCTtboDdOQqWwWmMSsuuNkCcDdXxiIHoRMmrENneDdIiVvxUuohHUuOaOolGgYUuyJqQVKkVUGBbgMlLmTtwWWwYyTEdDeaANnNnRrBAavRrVbHhhbBiFZzfIHtMQWwVXqvTtRrVksSjJDRrPMmhnNaApPtAaXxnNqsSKMZcCzYyEjJedDBdDIKtEepPKkQqXxNdDnocGSsgVsmMVveESfUUuuFSvVgGrVvxXvVaFfiaAIkuTtUqQjMmkwRrQqkbBKxZztPbmJSsXpGgHhPnNcJjpdYyDyqTJjeeEdrRJjDXYdDxXAaFxglLfFmRreEvpPuUtBbUusSPfHhydDYfRrXxqVvQKkYsSyMSSssZbBMUuwBRrrRbiuURrRIxQqwpPKvVkWfFEFgGpPlGqyEebUuBqZzWEuUYEQdDqLUhKkHRrXCoOwypPJjOoFfzGgaAAaZuFoYygGGgWDIskKvDdwScGgXwPTwWthjhVAaAakKvnbrRXxysSiUXMmxiIxoOmMweoWyhrBbRVvHYvrcCiIkKZiIwVkKvZDdDCiutTUIoOIicdzkKzZhrRMmAaeQqkKBbSsOFfoVvEoOHGDmMKkdiJjuUUeTtimwWTJoOfSsFjWTtxXwuUuqfFiIQUhmMGgtTHllaAZzpLVOzZHxvhHtTdNnNdPwWLMNnRruUwPpWOogGVvDeEdnNzZkKkMmDdKnqQhFNYwWgGNqcYyZzRLlrpPkKsSLlLaAAaQsSVuVHhvjJUdVvDqHiUpsPpSKkNnyZDdAJjaYyYnZzKYyCcvNneEVwWTtdDkNrRXxaInNuxBOUUuuZSPpsSVHhPpjNnKjqQJuUCtTCcKuFfUNaAxMmgPpDdSEeszZGaAMrqQRvmONdDnpWwNnjJEePvGEewFwZzWjGgcCIiDkKXxmMGgcCZzkKdCcdDGGSobBvNnVKvVVqQUznlLZzZqQCzZvVmMaLlGgCcJjFMmfvVFsoOSuCcyIzvVqQrCcRNQGDRFfYGJkoDdZzjJToNQqSNnsnDpPdqQTNMmvVfFcwWqTtCDdqaAQGgWCctTxXCqeEFfVsSaAULrBblnNmMpxXZOozxXPRrSJfFqZzIiwWnYycClYfFrRSsjJyLRrnNFtCczakYyrkKgGCkKtTcTtQqhwjJjJftYyqQJvVjTTtFOVwWAWwaPbVvyYdDWwrRBoOJjgGRKkUvMmVurhHyYHuUBfySsYyYqrRwWQTtepmMQikZfFzrRIVwWjoOJhHPpuUawzZWbjqQJdiIDBfFAhSgfFYlLLhoHhOZzmMoOgGDyYdpPFKkpPgGuUfkKEJrgGUuCEecRJbCcBEuUevmMSsVJwWCchdpPDYyYtZPpNKIikSslLcCfGqQrRvVQYuUxYpPUUuzHhUuTfFxquRSsdEtlduUDtTMrjJRhHPvJjIaAQqilbwKrRAaFnuUVvNfYhjcCckKcCcbBCaACmEehHgGQqHBbDdhpPHhnNqQHhcCIizZEespPSyYtDIeBOorxBXxbJjXKkYyYegYyyCsHhEeSGkKgXxGdCOOOuUobBbnNBVvxXiIFjJxXjqnNkKOojRrSsJQXxDdrRBRWJjFTyYtfZzTMGqQeEFfNnRrRDPpRrITWwWFdgGDfnBbyYfFBbReEhHfDdUAaJjkKQvVzZcCquyYvzZRrMgsKWNnwkkKvVPpCcAaFcgRYyrGqfZzzZLlGqMPqQmbFxXaJkKjFgDpuUbBXxPdGTyYqWwQBAaUtTucFfCACcSsakLMDdykdDfFUuRkKtTvQsKPRuUcFfkOoPpLlWwmTtiIQqMbIiwWBPCmlLMqQVagGAZzaJsSUQqbXrRTtGOogxrRlJjnNxXBcCaAsSsvgxXGPpVYyqtTxdixzZXGpNmrRMvHhEeVFzgBbGZBbnOgkIQqiKFfgAadDGBcoOEeCbWLlKkwXoRrcFfHhYyfyYFGLIKkBeELNNnbnNBbBbztTZtTnNUuBSslcyYnTtEeNHhRrpmMPxWwXGwWokFYyomWwmxXzZOxdmiTpemCcZzHZzyYetTleELEhjJHsSLlvMneElLBZFaejJxXEKRKkMmAatTrciXMvVUumxByWwYVaArFiIsSSNSSIiPAgAaRrRXKZdApPaNnDkBbIiCZqBwcCWvVcbnrCcHIigMmgGAabRrBLlZdDZzhHzOPmMCccamLTtYyTJjWMGgCcCCDdZkKlLtTvVNNnnzBvYyGgPpPAasdHhcCfFsSXxqQYyOoxrIizZPxXtTdUuDUKkLuRrBbUluUISIisifhHqhHGgWwSDdsDVvwWTrRsStpEcCuxwRwSsYJjndDCuUcCoMmOIeEisSUuiuUfuBbYdDyHhLvJjxXvVVlUoOZOGBhBbHbLsSlBYyLaAlYyizjJRrsLxhHIiXcCxvdDjJVGgSLVCcvAalsxXPsSpBbXeiwxNnXsmMhVvHZpcjjJDPpXEcCexgERkZzKCNFfSAatNnTqQuOoCcUEeEeCcYPwWVvtdrRHhrRDkKVvNnQqoOIaAUuNeDCKGgkcQqAaJjmMKuxXzLGgRrvVvVPHhvVwWMwQrnsFYfFaAbDlDvVtXbBpPFfXxxaATnNuUfFhzbSVFfDCgqfFQpjJLlPynNoMmNNmMwWNQqsSDdnBbnYGSsjJgKOoPQDdsGgSqmMpBbkdDsShTDdtrROJvWwWpSsuUPwZMvVmzGgLlqQduhUuHYWmrfFnNyqQiiIIYkKRaBXTkKNubUWnNycaACCNSjkflLAdnRHhaANnqAxUuXMmaSTtsCcIiKkeEAjJaFBLlQPpgOlLsSrzYyEeeEzfFRRXyVoJjOvYtTPpBYzBDYyhAtGBbMmtTcfFZGfKkWwFWwgzIhZzFBGgxXxUaAiqQRzNLPgGUupBbGglTtcxXxvPGsIaKkmAaiBEBbnNhxBbZLlwLyYllspwWTEmMmMZmjJMKmXDdxvVHhDddkirRfxFfXrDdkkAalLvVUmnNHhCcrMjGnEeNSsgYybfSHhpqQUunNMEiRrIeEeqaAeEpqQGMmgVtTvPzZXdDxpaAPVVZzcCRiIIiryYQqfRcUUIiuohBMmRrfTZgtFvsScqSsgGQQOvBWmzZffFFtiIlEeoOUpPlvVLZjJHhyYxZtiIOotTHaAcPXxpCdcCDzZicCXVvGbhGgZOoHhWoOJjPfFBSoOsfIsSiEeFVWnNKTcCeExliIaAqNTtnPnOvZpAaHyYsSUuCcAVvYBbyaWsSSBbQqshBbgGTNntHiIHJoOjicfFYymMCIhkKuHGgQoOUzvVKbBKAacuUCAANjJvVnzZwMOkKhHnYiSsqsSuUUujHfFhsgGXxGWwOUapcNmMnTtYTtXYwglAagwYWwNBZzblEeLGTtgOrljJLOoxsNnQEslfFSsgRrExaAWwaAMxXPbBHdaPpmMjJeBbZzExXEezHRrNqOKkExrpZzPNoOnSsfFwMUFfCgPpGtEbVIiIkKoOiaAiZzBHnEuiIUxXQdDCbBcezsSZQqfodLlQoOkKdDDdiIyqQIaAkxtiXxaaAATnfFUuNVCctQqzZTnkKyesSOlLFfBbkVVeEXqYyYpkiILEEyYecCAhrRHHhYuQqUyxXFfaNnxXaAHlLBhHbBEqQRrMmetTWwbWwCEtLloKkOtxcCXTpPTecSuUppeEnOoNAaEUueCWDdwckOaysSMuUlskAGgaKXazZIBbHivVIHhtlMqQlGgLFqBbQVCcOhHMmOcLlnslLaASYyNCxtSsUuWCciCcSsmwWnhWkZzYcCWGgwQAaEePcnNaAtTpPNQqRrnUuIOuULlTtJaBJjNRsPBcCIGwNnWCsSGgxoOlDuBbqkKKkHdDgGeNnlLROLoOlXFSIisYynNSsNOjzoSTzZbBQfVaAvFxXiMuUbBOBIiLyfFIqQiiWwAaEFfuUCVLDdlvOOEpPgxXZzcwWeEnNhHCUcCUuAatnKkWwRriINUwlRrLWuwzRrZToOtWZggIiGmJjVvMSaAXiKeEkIxivVQqSLlslLSsQtTqXxtjLNnkKxNnzqQvVOoNxIivlLpdeFfExXDGHdwwWJjWnXgrRGqQlLxTtIiLlhRrMmVNNEeAQqaXBMcCfrWtFfNDdNSscIwDmMsYtDdTACOfFolUDdszHSseEOJevJxXjbGSsgTtSWwHRGglLXFfTtcCaAZKKNnVvEeQsRuvPplLfFTtHhyJjHhEzuUiIZYhSGgYVTaATTuUttfFLluUbZzBCngGUxwxTRrHmfFeEfWwVvrvDEMmuUuLHCwWYyNncJjHhOoRXxvsShHVrQqiICbBPpIpZjOIAaibFpPZtTKGMHhwAiIKsSsQzZliPuGgwjAWyYoOwFIAOoFgxbTHbBhtHhuUIiGTkcXNpPQqnLSsGDagGABbdSsKkNMmnzMNRrzFjJhHfIeEeEGgHhFfZzexLlXNZJrRkQWkiILlFfPCcJQqgFiDSWICaAObSMmsAatHhTaMjJkGbBvDdVgkeEhkLZfzxXnNaAlNnhMVvdFfbBHhgBwWeEbBbUucCWwbBeqQEyPpYFMmFFfhHLVvzZAGzbgGBSQqQvPqJjKAanZzwPIxXUHrRtJjaGgEesSgGIPsztpesSMmgGwWezlLnnNSsogGOTBCqFkKaHhSgGqlLGgNrVxXpbBbbaALgQqOoVCSslLPprgaZzHhgwUEeuDUKeEEekcuUAacwKdDHqQhVvsHmMtThIUWFfwEMdDGXxhZGcFuyAaYdDXVfFnnNmMnNXxpPpPVvAgGfFaNSsWtAapPTAaNqQZznyDPcyYJtUZzhDJIiKkjIifyYFtveCXxuUcCiYyxUuXcBoellNnWPpPpFfnLlNIUWXjikKRrCYycfFjqQkKWaZzQqbHhUalLAbCcBGhKwWkWlLcmMClUuLEeTtVVzBdKwsSWmjlLosSOKkBOogXbzRIYNnNNNHhnWwJHhfunVjJjnNDLlUeEilLSmJAZvVVvzaYzZLlyDdzIFfyVvVCchHgGQqevVEpPnNhrgGWhHwlLQqsDdSYxVvvXxTEbiIBePptlVvajJFfGgskKmlLeDHcCfFhtuknEomHhMmZbdDBtTLsdGqQXWVvwrRxggxXxqQQqXGxXkKInNBazDvVbBtaRrUmNnLiIgGrdjECiyGWLsSmeOuUoluvcCVcthHDMmIgGeRrMmXjYyQMJYyYDwwXxWhjCdFJjrzZpPhHpVvSsfeHhWGgMZzmbBlLHhUeEuHiIRDdqpPQkKliIKkpPQjlLyCmpPcIiUuQqjKwKYykDduUiEgGZpPtpeEPNnTlokRrKmMOyYQBYMZzyAaboOLZKfyYFXSaAmMYHhxXgZzGySgqbBgGoBJjbOkKYyaKfPpOoxXyUuVRrvYQqFmMeEYyWwmrRhivoCcwWOQaHhArRBEKkelLOodDRrgzZiIuBbUNnLfVooOVXxvOvAaRrBbFBbkXqQrKBEOoebkgyYKnNkuUWwGRoOsSTtKmZzAaoGguBNnBbmMVwvVPlgHFZIiSTtwWsxXXxUuWrRvLlUtTfhHUuSsIYReEUurCUPIgIzlLJjZiPwWeETthrUicWwJjFvLGPpDdcCZtTzhHcrcCRCfHhFlLMbtaAgiBDdlGJoOOoEeeVUbBKkMHjYywgQqGWveEpPCGgHWNnATtitTPQkkKKaAmxXdDMgGqRrmMKkprhHXxRCWwBqQdjJMBbiIOoSsCcSgvGgXSstdDTZzqfNnFQeETiuPpPpkyYnElDaPpyYAdsKpfOPpoUuJLludDCyYlxuUXeIhHXTZViIEecCviVvIzZzfZzsUuSNnqLXjJZUuNmMbBiInzxhwWpmXYynSrRxXgyjJYOopPGsaAxMmGQGNOSgeEMOEeEfoTtOlEeWNWwLlaRfMdDwIlLTxyYXBbWcyWAaXuUxszZSaoOAZjJBSkKsgbUuDDNKumYxXmNnLiNnFfIhRvzQZzjBKkbJmOVBbDpPdtTWYKdeEjJuePmMpOoVvDdbJjLlzZFwzlWuUwLnhHpPOomMcAxGLlOLdDsSlkKiZzwiZzTBEeqQbrRPplnSsNLUuBZxOBiIDdoOjJLlugyQgfjiSoBbOmMYeJEejrREZnNCczMJxSsbeEvVaVahHynNuNEeqQWtsSTbIAaYyMXiJjIRryYOoWsOpPPIdRAusEbpEcCrRrjJpPBYPpLUeEtfBbFrRZHoxKsSfFvFBbfVaAmMZzaAbByMtTGgQqZzTiItqMmxnqNXxknjkcCFDdJjVEeAmMbBSsavhvVHUCOoOJZpHlLvVhHHhPpQlLeKQLlqkQOouUkvVEeeESsHQVvZwWEezUVQAQqNlEHlLhewBYSDCUuNUuLlAQqKkBmQAVZWUdDyXxmTtYyRGgTGwWBKkGgHhhKkbBHGgCMkKmHMEemcxXoJxedDEXsSBqQRLlYyMGgmeERkXxzZUvDMnNJjmWwhlphsHAigNnSsRrNUQLcCbBkuHhgGtTUNpVWtKkTwivVIGdrFpWwPnLlMmFgGvVDMmqQdpleEaLlAfFKkwWLxXxXiIzsTYymCyernsBOAaobBRFfayYwwoOvSsSsVWNLYylnNHhFhvksHicpOcaegGHhevxyjjJaaAfPmOcivaqQfhAagGHEiKrRFuuedDfWwHhKVgdDvVUJjlLTtxgJhdDVhHhHyDdYVHhxAVvVDdvafFfFKUuTGRLqQRrMmrzQquUMmzZZkgGvNrRZWxHhXWmGoRraAxXOmMXqQKCfLVvzvVNnpPZlUuhkXukKUZzXbNnnAcdIGioOaAjHhpXxdDRruquUOlLoVTtvTRGRNgGLkKhHJzcUrqQRNcCnDrTsUzLloKmJjThnNPEeptTHUurVedcCMpPHhCcoOAaNMiILlyYOsSjJqQqQfbBMwtpPKjJkWwvVTCcDiIjEwfkWwLiIiNnBSkrkIiEejUqQiKkicTeEdDPPpBbhHpBbGZzgJaAMmUxCcPPlKkLKkjJKkzZUsSCXxhHcbkKmzYpPyCIiWwcZzSsUAkQYqQEfrWcVLlvyVutTUoJpPibSZzQqYdUukGgKKMQoOqaAwRrlLiIGHhkKxjJXXKQNnuUxhyYopUZzZzKIiYyFXxWwfKxXwWqsSuVvUseEMmGqFfGJAaPgxyhHYhquUQWwAAaXfFxEecJyZKkKqQdwxXWPppYCcyPqzbiIunxXfRiJjIebiMmYyABFIizBbEeDdZMoOmfgxTdoBdwcXxgNnxXOhHVynwWVjOBbVIiMmYggOiHhIbntCosSOsSGSsgGgUuIqoCaUuwaAPpWAchWaAgGwHOqsXKyPdHhkKcCDdCiIvxxXEgfmMFaDwWghHMmvrbtJjTINnlIAgGuRrLlUiIMmairxLaQQuUqQZvVzKhtTkVuUuUvKbBUulKXAKuUkaMGgmonZzOoUuXxyYGELlZmMlLWmPUuMmuUAaSiwGzgEwvcLlEeTtCYybZznSsNZiImMwXxWgxNnqQJDnUIbqsWDdqdJffEzZeQqEfCcFpPtKkTkiIUkqrRXywWwxmyYqQCjJBlJtuUoZjuQdlLdzkKEGgqQsmgGgKkZzxXkxlJjKkLXKdsSUuDEqDnUsSfEmtYyfQqmMhfFHCQpEvVeqQMDjhODtaBvVAJjadaQCcqVWwpPsNkKUqQJoOvzZSswWPpOozUijzZyzRQqsAxXQpPhDdDKkfiIFsoUSoCgWwwltreEOoRcCgGweEuUrVfsoVvaoCcONaMmaAFMhepXVnQqiIlLNtlLCvSUuIiskKZUuLqQrgGzuUVvspSalLDPpfFKDdkdrerXWwTMaAmvWtTdDhHwnUuNXJFfjyYIRrDNniIdZzoOXcQqczZxfFXERrheJjAPGgQqmMXLOolUulZzdqQalfGtduUPAUuAWzwWwHULIiluAbBavqQuMmguuNnyYUysqfUGgCUvZRwMmpjvVvKkiAaNmkOVPFQqiUhtTVVvvBbjJGbDwWdwkWIxhyaFIifAGTnwQxXWDfjFVvqFgXxdhHDGrRJjHvknNKkLVvlCpPcBjJrjJRrbBRhHZCkQJjqKtoDdPnCSnNsCcEjzhnYyEeKkNdDIUyFLosSkKOlBsSSKFKkKkVgQqRrMcClCVvhHcozlLXxXOoWwqQuOWwWmtTIiyYyaAPpYuOiepPEIoquUgGuRvVGTFfvSsVxPIirVvVKFMmVCIyZGJlLjwHmMctTldDJDMmFfuMMIHdLemRhHrSsrfYNEjcjHwWWHSGghZznNSsHDvVdWwBIiTuwWDaLlkKyYbBTERgANnaEelLzGghCaZAabBhTtLUGguDFRrGTtgfGzYyZzxgGXZgFfKQnGOoRrqQxXiItMhSIzZNniObvVvVRroRrqaAQBUvVdCtTcjJkKFFpCcCcbBlLPsSHhLnNzNTStPXIWwitCWlLNnweEcrkHhYPqQtTpXcKwFWqQxcCVulOmvDawWAzNcDvVdEWwQPpqWwjnuUIdDiCupUBbRoOrpPPvVpFLRcnLJjlqQTVhHAHfAncCNhHIiaoMmpuUApPaPADrpgwIBbMGgvzZVstTSmAtTivnmuEeZzUbBnDQfFSsqoOHhHHLvVlrOoRbBLSsUuUtThnNLUulMmHkKuGMmPqSwWwqEKkegeEODqYkMmKbjvRrfFYyVfFeFqQfWoOpPjzjPihXiHhPpHhWqdLlDrRKNnXxlvvVCuUcZaADdzUUaAuKkGiwxXYyCcWIuvQiXiEELEekbBzZKaEPZfdrKiIWrxXovVZZAZzxQquULeMjPHRXdqplLPqQQdkgejJxeEyYXYyIJJladTDoOpapEeslTtkmMYatwQqeEbgGgGsSPpbuBgFLOolSwEpRrENEWwteZCczPNnHRrjEeAafFSkKZzESOokUDAfFVvfwAaWIiUPpzgGuAantlHKiLDdnNXFXxfxbBoKdDkOSsHhSTMLURrTtucePRrmMPpoORrhHWwUTkzKRGYqhHQzcChOHkcyoOEjiQqnEegdDNnGOoRjdDpMTwaArSsWWwnzXZzAMmmMaDdxFqbBiIgGlEPpXZzpPDLkKVvlmPpobeaAfNkKDbnISDdYSsnNRrvOoToIZoVvGjxRrwVPpPpmPCAvjJZzAlCcMmYtXZWrVvWzMUIiVVfZzsSFQjJhHqQNRrkKKUOouIijMCcXxtCcrbTtCQqXeIiEDEedstDdHSsfvVTtZyYbHhHdDMTtovNWwPaXoGHyYFlLNjJJjnLlRrJssvVSniINScCEoeRrAWTtoOYKzVvdxRPZSDdsKqQacCcuHhCGgcHHsqiZzIKkJvnNjgUuGFUVvufoiCIBIkKRvVmtlBbeExEqoFUumMJHxcZhHJcdjbBJDwWdDZqsSXLJjuLzMZwGglVqSIimMkOgmQOCRrcCcnLwELltWUuYRuDtLlTsSeakipPYsSvVyIPpKGdVEenNvxhHXXgeECpiIqdDFxLGRraZzEfFeEeTzxQkwaAWsgGhHeCHhpvwYWDdPpuUgGWSsbBwtTwuNnNZzuEJjJNdDVvyVvYneEcaNnAZOBbmMpzXxWkKwOdizMTACuOiIoUQqXoOwyyZzJjUvkZhHpPkVtTnqmAaMyxSffJMmZbBrUuRuUCJjpPPcRXiISnEAaDdednqLlLOMmJnNWIuqqQYuUyZCclLzZfjJoXxORdpPaADQqrUnYxXjkKrAaRJNoOnJdDjyUuPAapXxNuBvzmfMpTfuUiNFNnmxoFBbfOcCDtmMTnmaQRqbrxOgGgGHiIUCcXzqJWvcCBhHfzZpPGqQbqQFLNHhIinNwWbtTxqQuUuUIdrpPRHHhRrRxlXtfFHhlzZxcgGxXGgxKkYqQdDyQxjJjuNnhIodwVfjJfFmYyBPpPoOwVIeEiezpbkBbaALBbWwllCvfSsdZOoJjWuDdUrRvVwlLzyYvYpPjJsSUiIfukuUfFmtTnfKFNZgHnPpvEezcbSHXxhsBihZzByYeHhUeuUVvJTtmyrVkEkbgDdwWfPnNfFppvVluTVLlhDdiIbBDbBqHCcCcKAWwXnCMkKoyjTKsSAtFfZoOziITtNmJQqTnNigkWuUTtwKYeDdECcVXqQdBbhHQsBWXxmMaDdtTSnyYOAQuJzUCweRrmKFrjxrNNfFnndYeEKkrpPlfFfaAxmMXxPCthHwbcCBEKLevGLNTDihkKIvQdnXcaAxXCVtaFleMDoOTtQqxXRpbBPRcQdyYZxFSsnNckwWQTQWwdDAafHnFNyCVvdRrDPWwwZeujJVvwBbWHhkRBVpPVoeEOPpPkKgGrLnLltlLTcCeYyQdgGjqSfBGgVkKTWQEnNuBbHLVvCcVzZJjNZzAkKVvcJjCcvifwIDdivtTAtNndDFwlOolLjJzAbvjNPxXuFYDdyDdrhtojCfFcuUUuoOTIjBbxxXXSbBCciZuxkJkKxNDdDNnbBeEdnRHuUsSbBTthHcPWhHsAaSZzZxAaiqzZfFjJeFxXrnWTtaAIiiScqQuQGgqQDrWwRlyPpYLtTEoBbOpPlLNrDsSdzoWwfEeQDdqsCcSEkeEBjIhHFssapPtTcxXlMhHmRrMmgRrOohHYKFfvlLmEeBnzJVRxTGHkkKKeEqRrSZPzGgGaAgZplIyqAamMVvWdddDDKrpdGCeEeVZWwyYzKrLLrWMLNRzAoOagiIAaGNPdLlKLENsRDGwVVgxXGdAuLlOOnDdLlaUSSssItTmwJVRfcKkCIimMxNnoUhGgSpPjwuceEeaKkrRSscCuUUcZPpSjjQBvFfSLlHtrRrpffZzLoSNACcnNTtagsrRSJPJTVqQvYyCqjJQRAaBblTVvpEetbBwWLHGZzLPvVtThHgGCqLzuJjUOCBbDHhHCaXmDsSMJvVAbqQUHhuQqdDGClLwDEedWOoIYwQbQcuJkmxXMKPUuchHyYhTxTtSsldRrkKDXqQEuMBTpPtJedStTjtTAwWvVLOQZElsSoSbTToJjtTkFYyAaZzOyVvVkdDKJKSCcIYtTzZhDPYTUuBboOcmvzzZmdhHGajteEQWwMmMmpPLJjudlLFfHnTxXzZSbSERrehbKkbdDgGElRKDcxQqXhnBJjQkbvVvqQuFDdfCctHwPSspsSMLxnQboInUAMNnLxPXxbBXTrgTqLluwZzqQWzbDdsSxXMguTjJstTioOdfFDIRAvhWwnGOzioOIJQqJGeEihTtVNnvfFtBbwWLxfFhjJHLFyuHKmjaHozLlZNnaFlLWwrtQybBkKerBbXiIgxXAQYxrRxkOqpPbBCcgedDxWvVhNpBbjJgGfpOoPjUqYjJxhHXtCdvBaAuTzZKpPJkKLFflIatJgGoOrmMRYgGPAJxRlLYrRUuiILpwQqcCgXxLqQvlYEQBTttRroOCOGPpJaAgDWxAmPhnQqNHfFRjEeGBbCQTtqlUuqQhHAaVqQnSsNvxXSsuJjURrMmxJjPWYywlLpFfuUwpLlHeJbBjVyYOokQBjzaABvVGIiSdDTtvVhCqSwrRRRrZzZzonuUNolZymhZqbTtTbBjJVvYyXxoGgzZDdXOhHfFoPwWponlLAUNlJbBjLYXAUuvsSOYypwsLFfNktkKwBbIioKtBtYyhiIkKHKkThLkjJFaAEzZjJlKMmkKXBJjmjJqGzfyWwnAkDaAseEUuTtwWsRcCFiINnjJIrsSLlrakfgGPpnTtMfcnaQygGRIiRWwWcKkflkKLBbYyFQUuqJjgGpPvLlBmFWwpPgGxRKQzuFBcwWRUfePbCcBAquUngGgBVcEiQUuPpDMmyxXYyqpwWiJOoNnwdNVvSLOaEiIqQezeEZHcQoPClLLuUlcuuqQOoVvsUVvRIVvWdDwwgGaAbXxIKyMmYeDOrRDrOyGgYaAuzLlNZzAMmpkasSQqNnAxCcXmycCgkZzKvVAYmwRUuKyqytAaDWCqoNiIKkSsnJoOTXIitrdDRhboDxaAaUuhzfJjQqDDdxhkrbhAaHJjuUGUlVzcMmKIJjiQRrqkdRYQTuZeBMqPvzZOrRMjdSCDEeVCcEEeULeEEwXxGgXhWeiMmIvVbBJjnsSEXpjJeEOocCXpMaAtTmPaQrOkKoRosXbBXxxCjJcmMNWwnlgeLQHcCCeETtcRrPzWwsXHjKkqRGouUOoFSTBbbTtBBjvOormMRDdOoVwSZasqsSJqQNVnMmepXFcCXMdDTHgfFrBJjEQNRrRrhHoOoQCDAaCcdygdRrsCUNwWnXwWxrRoBbiAaIkaYyTyAaZZhHDVmLuUtPpTmVxXLyYlLohmJQqXkziDpLSYAaynNuDdTtVvEeMmDcCNfFJLljZHhAaqQWwLlxLlWneErxgnNoNnsIzdtTjJUEOtFduUwWDyoSshLrPbVvoOEeHhvVyMmYSpzsSZPKiIbBkNnZzLItMzZhUuSsQqHfnLIilYLsmMmYyHhazcmUuswtsKkBbvuUJzKOofFaApEjJgGUBbXxeEuvSdDsxhHqQXVeeELubBjAFTtfaeEgGtEGzQQryWlLwQYoOcyvzZRXxratmdgGDdmMDMFfmAFiXxrRwTtzoshjJHSuuiodDOIyYWAYZudzrqujtTmFlNXxABbzZCcdNnQqgriIGkLlPpzdtjlLPWwkpJjBbawLlUYLzbRTrtTxiPoVGgWrRlndDNEMDRrEpSauLwYcCyWyYtjJTiKkIPpAOokSsKHMmwtkKoMvWUulLMmeEnNevMGCeYsSJjPqNDdnKkGwWakJPdhbzIZzFIiMXLlhhNmkCVvZMBEcCvaQXhHKBzpDJmcCMmMaAHhZLsShMmrkKRuHhRChNnHsxMJcwWDdFUuPpJWwHyYGqjzZnNcWPlgtXxjNSjfNcCjJnPklMXGgkEsSeKSdvVmMDrPiItTpDqQAAagPHxXqCcALlZTtkEGnOaqzHxXsEeSUMmRrzZgGMmQqdbrsIzcbBClaAHggpEsdDqQwWSHSRraADXHhhHsZpPndDdDllvHEhHehVMzcCkKZcMJiIAFPpxAaeUlBbbBzVcatHhpgihRwDhHrjJcmTvlMNCQqwmXxMTPpEdCqQcQrXxPQoOqpDlGgLkKIiXkvasSAVKhNxNnjzWwnNZVvLgGHhlzTULoQqJbedDZZyHhAPVvVnYxYSOeCPJdDdDpEWwenrRQGxXMOoZziCcIsaAIfBHhkrRSsYyhHCMzeAaeRvVqRGNnuJjUgrQFlLOWTHhjJuvVGSpDdYZIiXntTNcCAtTrRwikKiwWIzdDZqLZQqvVvIimRCQqnNqaZzgEzAhHcCkGIiaDdNNnmMSsmMrkpPcCKdfWZYZRrsFfwSFpAuvWRYNbCMgGmKIXFfkEXJTXFPUNzkaZzAKeLEdDPpVUKrKmMgpVuUnNpaeEgGzQYLloOpPpghFftaZFfVKapWPpwijYyJdZztXywWYxjSspPCAaJWSxcPpCXlLUhHuJVcsSCBXUuWUlLhQLlUTtOZODdLdwLhxnDCcdVXwlLoaoCtNHhKsSDdkKRykqvQqWUuUuyclfFLlFACzLtTlWKZpSHbaInbUurSsUuxCcXRJFJlRrLhigFmJYhHdvXlVliIvbHvaAdeXFfGhKWNpPnpPNttTttITtwWijeYysxXLGPvImmtnNDdTLimyLuSptqfFkIYKPMEWUApPaLRoYTHfFIMGgMyjPprJPpiyvVtFfTXxrRjhloOrkPpUdyqQsETLlqTrJjLQqvosSyYHhWYFCiaPfWwgGZzFpAIwPdOPhgUuXKkxbOpPuQAaqFQbBzZqUgMmBUrRxsSwlLUuTttHhTHOGgFGgfnRaAeEnqgGlsSPKCckYyVxXXcdDCxQqvpqQZftWhnSsWDtAlLaTgOoxnxVlurzZCcsSvhHVaApPmuzZuuUrHwXHPFlOzoJSufFPHAaiZZUWoOvMpcYwWOCUmMuqzbBZWJYyBbjaAzZpreEuUoeyKkcCSeEcmMFslLYykjJKWQyYBnpMOvlLFOrznEYPyrkwJuUjQhEhqSspPNnKfdksLaAVJfFWbUSDJJdNJoOTNxdTtEvVBXhTtwbeXkKPpuUYVNNnDYxUuoFyYMGVvQqOSOFWtORAaYqQfRXxrHhoOYYyOhrMKkSmMjJFdFfnBhynqmMiXYQqyxAouRnLxvVNnPSEOiZiIcBILKBbkLyYBdZzDDSkKHhHygvUltuUxTtCCcKXnOdIwWONnJyMOKPNlxZzpwdDwfSAHuUhCXxtTJsZrkbBjJxlRrUjJPlIjBbJxXMmjJizZRrETtUaAfFJjAJLvVFfVAuUbNnSAOENGToFfuhHgDVYyYmMaKkeQbdzZGgPIrbsmeEpPMMmLoOomxuWJNnFfcoYsSgGyxHhCjJttTxwowRmMzZrTJbBDlNVsiZOoAXJjKOOonIyYiwWRyYIaupGOPTWfjqQBJbBjKiICFfdHGzFNnssSCdthKSoyIUSUurhebMDdTtINnAsSsmaAQaGQqgAiCqdXZGsSUcHhItTkKKqpLszXgGxYlcCGEesvUHVyRaArPCAwwWKfgMnsiIXxQqmMUubtSOPVSZGXxgwPpWMzhMmqQbZzuUbTtYmWwMydtzFvVxXflTJvttTTPpDNThHIhJjHTzpcfojHAvbCBqCFIjJipPiGKAKkaSskgYoOuYeQhHCcSWTmnIZyhHainyGgZqQqQeVXfAzChHcZyYwDdZiIWwzOkIHyYnkkYdmhGPxVQXxqJjMmJjlSvHhJSFtNnWKEejfyYFAjJaWJMdgGDHpUWOocBbhPRYyZDafMTtAHuBWyNMlLfFepPsSbQqdDLADQPBrJjsxcVvlLOeEoxkWeEVJjvVMxXEVOhqQDdFamhHFXbPmRrsSSVYZFEeONnoQZeZgSsOodzKTtTmMpwWApMIurMHheKOEoOefFokEHHhPpAeEVvOuPRoYLIkKiQNgFnNKwMDdRNfFRrcKZhUiIUTgJNLxpnjJrKkjJiGkJbBzZMmjkKocCOgGNNLzZlXYLPoOANcGbWKhoRPprSZaAzLlzZuexmMVNnsLlSMmaBbFfAvXEvNhgbTkQPaAhnCcNnOoNcwnqyYkcAIGjcbRrMmdvaOFfogvuqrsdxywKLCCcVvFfMwMdLCcPaHboaAXIOWpPJjIDdQyxZvViMZzPpkRNnwbBRXLGgXzZHhqhUbJVvtTsSGIfFLdQuUqFfzTZJnNjzrRGgtHVRrFwJyFpPeWzZfcZMmEYztWlLvwWrlafPRouUOKVGpZznNPeJwbATyAadLRRWmFfMWTFgGqQERYyitBbgJjSRICQJAawWjwWORYsgReQSsnNqxYxXLlSKksObBVaAdfFDOowoOxfHhXxFUsZgtzZTgIyPrRUuFpPAafpyMsSrJphVbBwPIYQqmDvaDZpMmMnNmzZLJaCDQbzZpPWXWGgwXVRVMAasOFynRreBbPQqfZvgjiIJOoaAhTtaAKAakyoNnOBbIiJjVvVuVElcSsCmdDYyhuaysKmbDqQmMVFfTtGgXxnNodHhiqkiMmYRmMkbIiqLaUhiyYmXBbgGPwtTqYyQWpwWYyLlYbfkeiHIsSsSyLlVvVGmMXeQkHMGgGaAkvVWworZpPzmnSCFbAExaAuNzetvVTDmEWJoqmMhHYcCrcymTNDJroZfArRzZecaRrcCVkKzaLwAqAaQNlVvykDqQqlLlQxikzTwPNBbXxUuxXnprRWtnfXxDhaFaQqCHhDCctBeEknLnBhRrMzZiqQInLlHVmMoEeSsCzGLHOADuUkVvcCBbEhhQqHMvVTOvVRIEsjCcgGrEDvVdMmPpKJLuLBCJjcfTtsTUZUVdnUAgpcCPGcCaTYSsgGXInUueFzCVVtcCcZJyKaAdYYvAajmOEWTFEeJjfdhHMyZvVzWMvVmWTgbLlqQfcJhcJjFfCBbwWFDdvKBbKkkFFfDlLdfvVJdLkAtZzTbchHCcEWpibgWIYyjobBKtpUuxXZzPOadpPpPzZbSaMwEgaAWDUPpusVIQqiBaAlCUFRSCcUtVXxrRBbLlvICEnTUHhhsAavVSHctzVvZDaVvYyiMfjSsJFtTasOoSKkbPpUrLuHCchFvKNnCNnFdDGBhvVZlzZLzHbpPgfcNnkAaPpVfUlRubBBPMmZzpAfFmIUuVvYyjJAdxuUXTCyGgYutNeceEiTusrfdDucLbvSFfdwGeWmAGSsgsBDAoTkOsSJVLlvZIiziJjyYwGBIPlLweCBaKlDRrjVDdMbBPpmfHuUjCFqQBGtzZwmMwYmDnNtweoMJVyyDmNnMlLkYjXkKxzCGgTvvcZsStTfEbBNixSswWFfytuNDvuvVmVvMzFfBbuGgtLlSJjFblcCUKenMmNjJTtEkgGljbpPBkDdeRJSeirotmasSAqgGQHeKdaTtohVvoOlgRrZMmYycOvhNBbmHbNcClNKMmkKJrRjbnNTdjJcAfiIAHdFNFDhHdfZKvuUrRVIXDdqLQdKYLnSsaTtWlATmMtZvACEaFzORjdntfFMYCRQqyQEeOmGgMjwePpMdtEeTEZnUXeaBfcsNMROKgmhKqMmExGgQaAoOJjqgvYihIEhOoHKbBfFFByftTFWwxMIqQLlHuAlnNQBKryIKQIDOAavdBMkSIxXiYAUHMLhsMmSHUbfFBuevUvOoUVvuLloOYlLcCHlsRrLlSLGVzFpwWEvVNYcCfCcoSmvrvxFfWwgXxGxwCcBqdVvcAbBjloOPzdAVdcCMmyYMyiQqpWvHPjRlLmYmMsSyfPpFYYiGnDdNGzSuXWvoyXEraAGPpSyroqcQlLqirsGfFTRrTtIOorefEFfeMmtwwrrlDxXYtayAaYBWRrjZzEVZzvpPgvCckiIrpFALRVwWwTZyezOowWQqCFwEfYjWfSsSsvhJjZQAdDaqDligsSgGBbXxjBuHQxlxrWrKmIchHMmCtTzXYqiuUpPPpwnNoZzixOBhApNnNpPnlDmWmBbBbclkWYXDSRQUuhHUVZzGAVDBCJgiaCKQNWCHpqKtHhBGHBbnYmrRMyVUBbOzZoJiywWYIEejspPYyOHZvVzkwBgCnaplyxnngGKgICcRFWwfNYyQqPXlnjGtuuHlLaAzkPpCnrmWkfGnqlyOrRCcrHhpUYyoaQqpPhmRMmUimPIiaoOtTPtgGkSsZMxXmWwDGzEzqpPfzyvkpPuUKsnDdLlNMdDwWpBxfhHMAeEfHovebBPQqpmkKDdxXnNvwKXCXSTtRbpMmZEezqdaCclgGmMvVBEmnYtTwbUhaKkmFAdzrMmpHCXxwuiFfIPSRrFfsxXhmjwJPpYykLlyYwTucCUfsjVsLBbvkKXpgHMDLliIyKGgKNhiKoWDdVvxXdDyYaFxvwWEiLlIQqwWztTYNIAYzaAiNnNMMmYytwsZzoOqEyUyIfcQbzZcBVahJOFCsSPZtitndVjzZtLWwZTDrRBBUuYyXxZzHZaAmODdSsozEeWJjwsTtsSvppPosTBrRSEeNmGFkWacpYmMCcvhAaumMVdDSgLSsyXxQqQqZSlOoKkPewWEQkiCugzxDQcIagLlGAlLnNpPqMSaelLWgGwEimBEHRUusuiYONpPPpnskHTDVvcSfZghDJjckbJjCcJFoOwqQtpofFgPUAirvSsVrRNMmokxazrgGRISvnLdjtWOWXxQqXTczZQqXTTttWwOCjPpwUeEXMOlmMmMmMIiSBNnRiHhpDBqEAyQCcqvdSseEmCcMtTGgGUOtEegneoasBavljauewWLplPpLXxuLQqXKRzSfFUujctTXxasFWdDZzjJdDWPXLnCcpkomYjowWinNDlLoNxBkKPnNpbkcXTLuuUVGTtYiIhsdbllibCYyzIoTtespDdXlNrUOkKgGaEeIpPQKkNYHNsSnbDdNDbBfsmRHoyofFOFqQyroTwEefosoKkgmNlLndDvVeEfOrqQRXydnvyxmMEBjJWcCzZHxbuUWwenNDXntjnMYymDjOojdqQEesuogGUuOBwPpjvlSYyKDFiIkQHeHqSsHhWKRYpEeyeNZRofDdEGgeVomPZzeENrRbVvBbqkKwcCSfkKCsdDYGgEORPwQcoyAaCPfFmVwOMmouJmMjzzIXxRrbJjBfFhpUSssjnNOQqZoLfphMmxWhRUJrRjvVsLlSUMJjGgzZRULvXNXGdwxXNHwTFzkKEeLQNrmMNohGgWQqXSsubGufUkKoBzZbBGHpoyYDpWjJZzcfSsywOVVvlfgjJGyzEzZeZYFHhRtQteSDdFfYDuKRjJLHJWMmwbBYIjRyYJYmbBEemqQiIkKihtZzyOrluOowehHmpkyiKmMmMwWQTiIPsUlYBbMIlMMpPOoiVpglSTtEJTTTndaADwkeEHgxdDEYyMmDVhBVLvbBLxQqVDyGgjMfGIHTtjfHhAajUuOoBNzZZzdDbBiWwyYLlAgGBhsCcBbDQYxXyqdPzkwaAIiRrBZzbFfoOZcCcafBbLnNCYwHhVQKYroOkOolLnEeTcOAOWxXxvNIiXRrHlWUuSsDlozouqsSHuwxbvjTtsdDZGgzwpHhPjcJTDIVBbvPAkvzATHGPhHyqZJjAPGgvPGkRjJjgGeEJkuvCceUWwulEZnPpupfxFcCftjxeKxikLGSoOsglaALlcBnyFPpqfFQfrlXHhxLEewVjJwWNnUsSyYaPrFfRfsWcCSzyzwlLFDcRrNVtTvfFnCRlLnAgXxKaZenOxXodDmxXkTtKMNGAQcrMVPpxXOozlQkKtTZzBbiIIMmKkWauUAzZPpaYyTnNtxRKkqQrzPhHpyJjhHPszZgUTttwoqQfYyrEOoEWwZFfmceEKLlbFWwizZSsShHmgqqQPpNPGgjpcEBbosyXyNoOFfvpaNnYvVwWzzVqQvEBwiIWjOhHlutOoWwqQZJXnHXxPpxQqdmMdDRhHqDetWcnmLGgLhHlVFflLeEtMCRdWrHIGPTNnACvZxXhHZzLuEXfajIimCmLLuUNzSVvxdFfshTteobBOHhPGyYGhnNuULZJYyjiSRBDuQvVqhZQsSAoNgeKzaQhDdpvVGJbBjeElLaYydhHmMRkKsxmLKpNnFJzZsnJPpTGLpDdwFfoOCJQghEejKkfNnSsChHtTjmoOXSbBcrUVvHJjlzaAjdPZqQbjJkKkxqAVoOebmzcKMnfFHHGgxmfiZBHdDDpjKAgoOQpyEwWcgmVEuUwXxgGVCcmOQIikKqTSsWqQoOhalUAsPedmksSKeLwvOpIOoXRtrBZRruUlyuJjWAPKplLJTDZeEKgRZzGDanmMLfmMMJUQKeEzZknNbBNnRZDUzyJjawlLUUOZWIDxXdfUjJwWuMzHhZmaEeMTObBoOopPEeAPpVYCoOyqYHhRSsbBqXxqLlZgeTAauUKUOxFfXouBbRrkUgGuJBbUDdlzZeEPbDdZzvVBmMkZjFfVeQqaALsSrRlrRSTWZzSMCZAOokKMSlMmRrIiyNFsSmTilUuvVssZzSBpRlHOYPpkKfToeuDZPpiSaAOgGGXRNwXMmqRpPUuUurQAazHhqQdHhDNnndUAaoORraSsAslPyYdkKMmIZKxjNnMHOZzlvheNnEHMjJUulMvpsSPEedwWhcCHVvDdzDdzYtAKuyYUOxXnnCfFcNNucpPSRrDSsGYcqOnqebRzZGaAhtmmMFfxpPdhwWzZmFfMHKkDfxPEgGdDNvRroOwWEeUunjQDdSAZzzsiIWSmMsJboOtsOkKofOfFgRsSrrQJBbhBbxOPpoSZpPphnIiNqlEGMmLpaAPIiSOJjqAlLLlxSsHhnQlLqNGgPJjxeNatTApPWwEwyYHzZxWeluzZeRPprvcCdcsDJeyYEmoVmMpZPpzQmbEzUtqyrDVjJvCZZzvyYLfFugBRKZzzZIiHXhHDddFUuZHAPpUnNjJuXdOBNnHTxtWEewjOfFQdDcwgGdTYnNQYZzAaUukrWQqMyzYiIyZaGYMKPaUlufFULunZVvUoRbBdodpPEyUpPuaAYkiBWuUirnyyYYkKNqQuqQSUeEUUupOsSqCVJjmMvQQqLlqhAolsnDWaAjOaACcoIPQFMmfTtvhHVYdGgqIefFCvfOoCFOofcqQyYFbGNQapcCEFMmGgurCbWcCwfUZyYqrRkrXeEfMHhbVyYCQqwrrQqYqANqQCFmGgCcNFKARwWxXRfFijJfrSsSTtzZnNSHhdKhHaeENYTtFZgAaQMbxFsCcSfqQkRrXPpxLevViIfVvKlIiHcCbSvVsTkOWwHCPpchWcCTKnlSWPorRcCVaxynuaNOxOzZDdaAAcCaHhtBQzHMYTtzLOOrgGbBWsQcHLlsKWwkgvVbxXZJPpbqKvNnEYPpkKyhPWQqXnNLzZjJcgJrpMafFVvXxgGXwdGGgjgYcCyochHTbqeyxXLVlGaAWPlyrXjSsSsapyjTAiVvUujMmkBbIiFftUAawWiIJjwWbJCcjVDnNcTyQuJFPnHwXYyEGQoKXXyqaGTtBzZbxRFfEsSYqiIfFjJTRsSfWwAlLdDGgOhAMmdDJMvVkhUYRrflXleEwSsWTHIgjBbSsjYyZoVvgNwVvWmMQqCcHVpParStUGmBiIIiZUQtGRtxwWpXQqlBLlbmadDuNiOBqNXlmbBpPWhAaqQTUVBKqoObNYyHMmCdkIirLFfUueSshSQqsHBBHsPpBstqQNhXxDUlMmrRqnNTJAghHDnNqQMZEScCseVMCtyTtptTdscCSlGgUuLHIiyPhHqZzqQQpiskjYyuUvYofkKvaeEaUuAAVKOroORHhtkKtBsOxXfFLWwezqvVoFBaoMmVTtvOAbRrflaJsDEjbmUexdCcOoDRPprLXtHGgCpjGLlgUwWCqBqWyicgkKOoBaIijwOoWmdMxTEtAchdfFRrcJjoZeElEZzKkeQHhcCfFcmMZzjJpRrlAYyaghpPlBbTPQqpgGPyYtLPpqQrkKciIAuUatjpBXxbOojGnsgGOjJliFFYyffIFFPRThsVbwWAFsSOofaqFEeXxfEeJJszCxqYymMQXSsJjVvuuUcUuQqCeEmMAgaAGEdDCSsBbUWJsHHHNnhhuMmaAOHhjJXFfFrvjyYQquUaAWMhHUuiybBYuANozZomMUUuaMmDvSXPpAlLEeaxsvWgdrSneEfFMmYyelkDxXpnZrZmMSLlsznuiIUlQqmCcwgGRSslldDfFnNRkHhvEcgDPRRrkDTtOrRoYywLzZlQYSsieELYyzsQhgtlLXrtTvjZNbMlLVFMmfZWwzgGkyGuURrLStTsCRyYbSsgGBrAdaADScHBcCbhvVAauUbkKBCwWSfQMmqiJkKbTtKevVpPKkFoOOZnNOoRnelIiwWLdqUCsIlLyYwoONIZziRfEzYySsZQIXzEemoOMwBbpHhEeCvVYyhJjrXtbBTUujKXUzIBpPbsJitvvVVCcJOTHQqfFRfZzXtiITxUMmpnJVBaeEUuZuUeJjELWfZzNztcCTZnTLlaVWFIVPpCanvlhhHUeUuEePpqwtvbbBFgGshHQJHhcCkKDIwWSdviIVVvDsinKkNqErHhRNlRBbpvvbrKUEzWbMmBvkKVpcEeYnfNGghUUuuFEedDNnjYyJbBqtqKvVCaKkAfqcCQVvqQXzDqCwWrrVhHaArRvcCdmEQqLbBKkHhHhfAZhHzTvxKkNDqGPpgViJjHIdtBzZbndDllLcCgUuVEJjSAaslkKaAeEkeUJNnjuEeWmMTcpiINngGXFYyLfFRyDlLHfFhRXJRfkMEWiIUumMcukKkQqKZjUqaoNsAXxwPpbSqDUuzZVvxvyGnNIQqtjMnTaktJYOmcNxazZkhvVYyQdmHhHrUuRhMgGPpDdHvMUumtULPrRFGTXxtTtBKLlzZeKvRYMTfFDnNUudoOtjIiuUNyYtTnvVEufFHhEbYYyPpyHIjCZzMtTmcuUJwWCBbqQZVNhhHGznfkFNdMmdDDuDdUMKUFnNuLlyVCcdDEpPeDyYFVLlcLJjzZUuZzuUHhwWZzKBeEPuUZUuEvWpbMFVvvWhHFflLDrROYyiQqHLlUgGJXqQqXCbTtrRBXuUEQqeADdLlaLLlTxLXpDDddWwPyhQqHYrhDiiIODdoXlLBnlTtfFfBgzZUuFRrwWFfbZzVDdwjQZONnQqoxuhzZoXRBQrqAMYyNdUUuuXbBMfnCShHscIFxXzZynNKkFwWfuUtTXxYtRrPmGgFkKMZVbFzQekKEUiwlLjolQNjJDNsxwWrCpgFfGPtTpczZziIjFFsXYmMQQqNvKzKVuyYUueEYYWxuUcatmZIDaAoYyZPomMzCNQeRrqQEqnjeUxXiInaAUVyYvyjJBkKbWVPDvkKVdVXxvcZzErRaASCcKqVvXnNZFiIFfftJkKjxXAUuggGlXfQyYGgPcGdDxDgAEzZMmMmdUrywTcCFfSsegGiIWzZlNeEbBCcoqMGoRrKiIsQvsSLWzmTGgtZOoEelUlxtTsSRrQzsSCjmTtMzCXyYhTtjThHtsSfrRrROQDdeJjMmGgXmMLThlLHMaAribicIrROhHMOoGgPcCCcpmJVjQAYyLxXlacCShsShUCSsAkzprXDZZzkywqQbBaEUuOeVkKvbIiBjBcCbfhTtLlFfgYyJRYoCcCOoTtYycOyrkGiIAagKjfFOAaxApnVOmhaABKkzZzGgiIsaYyASFAahTSDfFPpkKDddmMxpPcbBBtTmMRTmJNnkfFnqvvuCcwWmZwkKkKRwzxcCxXTyLzZaVcCalLpPcpMSsvWXJgPpOziOwWtOoKnNkVfFyIyYisiNBdYqQyxXUunFnNEtTcCBuEeLlUPpOpPMEedoOxUuFfeLQfZNwRWtKkmcCAHEehacCPJrNIVvJeYCKhoHZyKkKkjJgaArkZeEKrRtuKkpEfFmuxXCcUMCjJlmUutscCYyOoSsQqIiOmMlLoFfYylIkhLKaAkTvzZVqQNEeWwsSUZLlSsHdDhuFasSpPduKNnsekKsDdJhpEKkThHeHhneBbPXxeTaAtWsWLldDTtwfGoOeEbUBBwWuUuUXxHhoTtOWTAyMmZHhzKLSPAPdgGtDzZAXxLjjiELlOoMmGKDDxrhHWwWwJvjOoJaAVjhpJmNnEcdDBbChHOoQqYyuHhUlQqXazzOJYyjRZzzZwkRDFxXzpeArRBsYIiySblXxeeIxIqVvVaHhARrUgvVuIhHaALliVYyLTIihRrHtkJjQwIxHITtpJpwWPZSuUsJjJZaDZzDddAzwiIEgGJRPprByWwAaZaAzQdBhHFffFMmboMljJLmGWwEFfeQWHhsQsSAapgllLvVXxdDhhdNMoOmMNVIaoOnNiWGPRdYyaSsUlLrDYGgylLzZdRuhHOAKkaWwFfFhaAUuDdaPwWvVpvPptdfCcFDfFNCrlfKkgYyLpPlGUusSHhqQuPUcOogGNJeCyYnZaSsFdDfTtAdgGIiVMoLlLpbBPUvVvMxXmMmkKXaNnrRKkAwdDfYcCLlfFEeyWkLlmcCMCxGhHgyKdHhDRBbTrRxeEppPTstnZAalffEeFfDubOBosIisSavVAHNnmTbBgNqgcCGkEeyYTtuUnYXxeEfFyNHhoOdlHzZzgGAcNnHGgZGretQqAdcClLUkKtbMXxmkKshvVwSshJCnNJtTenyFRMNnElDhWwimhHQqvVjJmUFgGfSsdjLChWjJgzYijlLJEecvfkvRQlSsDdLqpXtgrGgUQUyYMwcCoUxZOLmGGgvTtfFfpPksbfYqQuiHZJeAacNpRrOTuUczYhHybCcFfjpPPpJKVyYGghrXxRfuUQyYiIfOoJFdwqWmgGMNtgYHXiwKWkDUudKqyYQBMmgGvhHVYFfRrhHzqQZyIiggGHwWuSpQqPsIfpvoicsSpPCIpPKMnIVIivVJIiPWrzVujJcuFgGNnQSYUGUQqVQqhWWwZwauUapDpPTNngFSsLlLAfFcCRrZztTDLxiIdDpaEKkHeCEefFCxbBiRrxoOVuUttTxYyRERbBMVvmqQGgXxRrAsLlbBPSjJZRVwWvlwDdWzAaVVvzZKkcHhnNTvxPEuUepPEHhHnNmfKSlLsYykALaAaAlnAEeuUOslLSVvSFfDdFvRWSsqiIQdDSsTaALWGcOsuOSdHqaCcSrOoZYpPLlJGgwWWwIuKkYyZnNWwVgGpPJjiIjungyYmMGhHSviIVTtvALlDbATdKkXxqnNQoHJdmPFpPfOoqcFTMbBeFumMCcNdRrIieEpPQtTeiIzZGMSMlLmeuUZDDdesHhSEDqUJSszOXxTjLSsbLHKuUkhlcqQMXgGWwmMjJHhuUWhHYxMmQVvIicKMjiIJmkAaCKxXuKQqcwWCeQqFFjDQwSQBtFfBbTiuRrUueEXxNncCXxNKkPTtpsRrwWScCYydjXGzBVWeGgGZgCcWIsQZzqDrGgRdTxXHhEetpYyYyMwNnEevVzebZzBgGXxgEetTyYBblLNOVvVLlvxkSsoOLGgoKBbkOHfFIOoinNiIkezZkKERwWMmVvpPeErqPpqqQAlXRLtTinNcCBRJjVIiGdIiAGecCXVcyYFfJjDpYkxSjJnNtTQQicYQqVvyDxXdTNBLloGGyvoOpPvVoJvNlNnLGgIiwBbWYvoGkKpPCWDbODjJtiIJjXGtpPvVTrRbauUIBErFNThHPuFEeiIfUPppgRrGPptSsUIZzFfiDPpWwQqdaAKqQkAaVveElLBUuZFfQpPoODgaAgGGkHhrRtTzvVYXxXZzxuUrRCcjCaHCuUcQtTUuqTtXGpAajgQgSQxXkJjArRakuPwWOHjJFfhHXjYyUuJqkxgWmGiIgkZzdDDysBIjDdOvYOoJjZzYKkJjyCcCwRFeyqKyYauAazZZMyYBupjTtbBTtJpvVXuwWZwWzjGgxXZzGgPItTPpiptWwuUCxXIaegGEAyYzSHhbBsZHhIwWuJKRugHhGUDdgXxGGNngpPfFiIdDKcQqGgCvVsPpboODsSMmdDlLdIlKFWeJOoddDWmFnNEIRrieouUHhgGfVvGgLlYyAaFgGYxXJYQqyjymLlPpJjnBYhHybDTtdvVtTvVcCIiqbBQmDEvRaAtdDMkOZuoOStRdiIuCZjlRrUvVuPprRnNnrgrtVvCcQCXxcUPnNYyJIPpgiDCdDaYyNCcBGgxxSBbsKHFckYhHyEpPQqexdFfDGgEeKkgMwwznVKRlFfvVExRYyrdDoOGgtTiLbBlIXergvVtwWHhkIirHhRXvhHvMmHjGXYuUNnyuGvsSWwrRkFnNEfFUUkKBbmMfkIeFAVIsSuUcCRrCbgGhHBuUqQoMrRpFRrAJfFYtTXVpPhHEEACniINoPCIDdhSsSKVHzZfJjqQKknyYmSsMWANaAnhHrbSAarRNREvVYLlqQcPpiIMHVvhtMmRrTtSAaZlvVLPfOoNfRtWwyZSszYTcCDVvbBYoOyKkgvPnaLlAKlqdDunGIahnNSDdHXxPLHIidSsVurRKmMrrbjeEOChTtcbwWgtrMYuwzvuUHhaqMIibQqaaAncdsybWLwWnVaqvxXuiIqhMJjmKKkJjqtXxTEqhPZzgqeEQGzjocCuUcrRKJjkuTuUtRrfHhKJqQLlrRNRXxrRrLlKqQFfnQoOZzPXxoOfTtFgGpNjJXVvQeEmXDGgdaAeEeyYExYkIXxyYeEiXOkKhzLZztTNnleETqQuloOyZzbeERQqePBpPlLelLSULlZzarDGejEUNnoXxWwOugiGgFfpBboSIikKwWwxmiBOlLiIVvXGgxouUwnUYWwtTmtTMAqQvoBbFWwfogGIXhnNHxiOOABZzXjmyswVvWGgIJaAPpFbBGqYGUbnNoXzbxXtcCvVvVIPpzZWJHhjIfFaELleAhHLxWYywXVvPplHhogxXOoCcXaCNZWfBMmEUIhHihHDkywQrRqvoyYMqZVrHlMFfyMUknddBGVvbzrRwkTtKYCiIwLTtlKktirREeHhgGWmFrAxZzAalLXoOnwLSdDIisKkFlLeomGsowzZWpFfPngqBbgXNxMPHaASshHvvVVRsSrhHlQFWeEwtSzVvCcZJgxXGGgVvjoOsxFfHhicAaCFfELPkKpcqyRrYQUjAaFbBPkSzZLeZNbBnzNIihHwWoSsATWPpmMwtaDFfZzMmMmdOKVvrnNRhHUItxYyoOVGsIVvBcCbiyYvVOomDYybcGoVvOghHPmMpIzZmuUMawhcVpPJhQqXtTxZzmdDnNCTtcuIcCibBvEEejgLbBGgbIGbbBBTKkFfBiIXvVKVvYykxmglVfCeEipNnPrRIzZcCpPNnINniIuoOSsRWwlGgLHpGipucyiYyFQquCxXcVXxGgwIdDiKLVvlFfkftTFEezfhBbGxXLJjpWvblLGgUOhHPpoOZzMkEbBexWwKLjJlNnfrRWQXxqEDdefaAFwFlzZGjBbJRrmMNntPpTtTbqDnNdxFfXdDVIHqQrvVRMkBbszZwWJGgVFfvjSAaaAJjBbAQGfFQqMmsUuEdDesxgGOobBZXxzkzlxXBTtYIimjJyeEbJZzsSjqJjhHcCLzeGgIvVqQWkvVJoOCjJCcSsUuQqMuRrgHfFqQRrhGUcYKkuZzzZQqJjUJDdlLkKqLrhYyluyYULYywHhtTbBElLYyaAnNFOotgGObBoTKkPRrOpPotTkXxKRfLlFfDWwcJOqRrQoHdxXDWlLqQDXxddyjmQqqQYyYyqJMmxCcdoODVvbBlLFfIiuUEYyoOpPwrRIiWJjidHhTCULcbBCxXEMlwgYqumMBbpPYyUQIInNiMZzmsSegGeEvVEceRrqQPpJDRlMuATGTCyYcWwzZtgdjJZAbiSsCiIcdDDSlzsSMOeNKUTTkKEetzZLlUudFIifTttcCTEeyYEBbMIiPpSpPALjJVXyRHpPvYioOZNnvhHVRrjMsItTudFfJjJvdDNUlLFjnUDdunyiMmcCrWwBdtTDbZBxCcGbJomMhHOMkbmMBVAavBbDbZoORsSrwWqQvUgGubBqQztTZMmSsvYyFfwUuHghkKHuBAjJwXxJIJvVxPpwPpKlZzLLlkuiCciNnIwNnLLEObCIcENnVTyYdoOnNIRriHuTjCDdpzuUZJjdYDBbdLlwvQqDdmMxUgGfCgzHrRgmePrRpuKkigGSQqQqkWCjJrNPpZznRBbYyCSsudWGmMzZAGRQqcvGmMLlldDBBUQquPvfFRnQsAnNfqQQMmcgpPGbtyWwMmYNkKiIQyYcLbBlCqvVZEEsSZzPTZSJjVcCvpleEZzLisSAEhHeThRrrRWwjoOLlNnJuiKvVkpWNkQMmEeHhpVUuqQqsRKCckrGgoOZbnNwWBpPgOJjoLlWwaJjIilffsbBMmSGDCcgGmpPKEeQvVqkHLZBbaRrAFzdDeElKDdHKMmKJBbjPpnNmAVtTvBoUpPHMmVvhfFqQuqQEeoOsSciXtTxwsdIfGjpKwqKjaAzxXnEiZAtTvVanEemZAaVvKXxkTtgWwlxCFAaYykKfKtlLWwfFBbgTtBXuUGfcCaiuFJMmVvjfUgHhGOofaJWFfatoOTAUdDpILcCwCIicWBFfoBHhbObKEekqSkzZjJaCcpIiMmPpPWmguUkzfdDBxXtToJYyzPichlyYAaJjUeHhdfFHhlLEeVRvVFmMJSsjMgGhtXtQqJjTWXPjJphHuvBbpPqQVSsNctvyTdDtsPpHCgGcwWWwybBeYNnYOoSsyVUIirSqvVoOoOjVjJvJkkzDqSzZsDMmdQdSsejtTGgJEfFxrhsSsBqQVEpPjJjJjwWohvVZvVAaSuHhLcaNNnnmMyMmkqQYDdyzOoPpnPpNZKSdWiCSstJjTkKcCncCneExXTpPOsSoUuHhJzZjpPwRFCcJjHhHhmEeYycCbxpPnnEjkKJevHRrNlLDhgyYPlyYLVXnnNvVcCZpPkkKKJlLqQjzZXGglFfJTFeQqhfFHEHbBTtGgKkhRQqrfKwWrRsSWwkIcCDdfFBbAacCgEeGsqQGzTrRujJqQGeoopPceIYHhuUlIywWYQqiQqbompPwWLlBbIeEqILlitsONnZZzJonfkKxtTRroHhrEkKePdgFfGDpEdDhUukKQUdrRLFfXcgeEibpSrqQdDJjwTtWnbAjoKOocCkiCcCpUuqIaAiyoDdOsGgEeSKwHHhNMIwTXoZzaAociQqIufFKkUCvfmLTwWVgeEGvjJfFhjJiBbAnhMvVjJmHNxwWsmMSSLZDdzKkmQqYcCAsSoUuKlLPPshPpGRrBxXbgEoOcCRreoOelcCBSsbKPyQpPxtXxTvvbZzBKoWwEtTGMmEegkKHhFfYnNcCAsSJhHjaRrjJkKNLaBQKkkKqbAlvBTtbnNtywWYuUpPpPITQqoOXzZKiYqQYTtyqDOFEqlLWKkkKzZzRrZMRrXxmwmMdDLleNcChuMmDdUAabIKkeEvBFfTteqQSsRrRrToOcuDdmkKWNnRPpjJBbvVXesoOSTtUuoRrQnHhhZfFAgGDPphpuUmQqdDXkKnNeGLvVeExXSAaieEIeiIqNnUujJSBbUwWuKkoObBXRvVoGgnklLKOoYyGgSVdDLlGBbBbgZzvsnNLRJjBmMDdMmAarRDdbrlyWPpKCckbBDqQduUtTGFrRMmfaAoOLGWysSxyCPrLKkAabBoOlsSrRRANQqnuogYyCcSkKdfFDJLIOoiCcKklDdQpPHhJjIvVyjJNtToeEOoBbmoOZzWLliQqaAIaxlLQqXakkZuqhUBoOFfXxcKkCiISsDdbwhAoOKkwWaPzrRBXSseEuUxbVoQqNpQLXtLlkuUwRrvfJjXxSDdsFaAbFfpjJJjwOoEezHxXBgcCJjsSxIHhdqQDhTzXYyaAzXxuLOoCcwWnNTVvMwDdbVoqNnCYVvyIiSFfsVOVdDvofTGztFbiIMmOowWHOaAuCUurIiSsuUFVvIivdDvRpPdIkKiDrlLHaARrjJlLhnNeEBbfFQuUBbmSsPsFBJRrmRCvVRGsSgrpPcOowQqFfWMuKKRFIKDHhMfFkzetPSGgLDdgGWUuzcCXHeDtTdbIMARrIiiSgpVSsXCnZrIuXZzbycjkKJCYCcfaAKkHDXxdiBLlbNnCgXxTOoavVHVvuUdbZnfFNwWyiIRiIpbBgGPUusSrrhEeHRbXxBbiItUHhuIiTgGfFhHqHKoOtTkhQxrrZjJZRoGqbKkfaAEeQrNDaaAMCXqQxcmFyYKJsncRLlCRQqsSrcoOrAasSYwuBRrFfHDHhdhUntgGkKxbPzpPZpkKiIiItTAZzqQJAarRXxjMrRwBbyepPFfEYyZzwWrRTtUDdDVjoHfFyDdhHQqnqQGgAaHQqhOYGcUudCcvsCiIxXczZkKoDdOBZHwWEPDdpeYyPpwWdDmFRrfMjJYAayqKkQdtTLdByfSNeEjlLJwWRzZrRqfFWmFfKkOopEelZUktTqQdEeEndDrRKsSkiTpyELlhHeoOsncreaUuAGrJjRIidJChlLHPhHzSrRqlLsSXxzZQWQqIuajJAUkKwWlLEvDdVkWuUEewKlSzZOoZIYyzZbwWDdMmgrRozOoovVOUuFIcNwWOoyhcCHWrWcCjJXUpPrReXxWxXgGwPTlLhHoAoOaOUuuUtdiIQFFfNntLlaHhxXASsTupenNERMmXdDDSpdwgGWDSJjsNnrRrRVLlbBbccmwtUudDcClMTtACWwjJsSpPpLWwsSloWwrRSsCcRrGnNgGuUhgDdGPpRzZNPpBoKkOCbQzFfsKkDdSPpchHKxXzUUdDuuYyaAsSkxKkrRrNaAnXTtxGnNCcxXaaAOopdDOowWCcssSsnVvsfpPRvbeEIbBCkaADdxWDdNEenwRrKkEeXAZFfDtpPWwTdzGgOobBfEezZYyzbhHtTNmEtTecCqQVPphRBnNbryYMpPSsrREAaAaPtKkQqIRJjrsgpPGSMfFpfHhFMmVfFMmvVWIZtTzaAiwkKvBbPDnNdDQqWWwwhHXZzoHhCsScFIiXxfzZMWwHUuhMOSJjsySsYfKlLHhOweEdDWWwgCLbBNnnLllbiUXxulvVgCOMmgIiGqQUuxGbBAaGgoNmMfMmnPWwgnNIqsLlLlUJjuSQCcDXqQHzZgCcnNGHhhVvQSbLBuOfYyBbQsSqFXxojAgGvrRqdDQcvlLVxXpKGgEUuekGgKCrpXxMmkSLlNHFfVvhnqVrbBtTaAZjkcCKJEemijJIMzKYJjJjEeVXTtxAavmlCcKwWnPJjpNCcvVbqGwWgQSWwaloOLAstfAxXWwfWwBDdSsfFUuMqQpmQgFwWZzQCkKxGbBcCgWwnNAaXSsfSGmwWiIVFfFuUeiIEpPZzrpPTtNwaAuUGyYJjgeZzEfQTtqWwFTtAatiAaSMmGgoOsNndrtTsSQqgKkmwWXuUlLxmMlLAaHhCctXxwWwrRriIEeJjbfFOofFJMmqqLKklQQQqfOoCcWwoocDgSscYGEyRbEidTEJjebbBBjJWwMILlivVJHXxyFflxXPUGrdYyDcRrCUKkuNnoORgIiuIipjJPpLkqRrQWPpBzZpPLlLlLZzVDdpLlmsSNnuUiILTqQeMmCcsSmMDfFrIFfivnjJjJNtTjJiIjnNsSJVUGgQXZztDdZFfSsHhqrgGRQvOoxXSCcsVuGZqQxXzgEeNnSsyXERrdDDdqQWweMmVDdLltTvkyYKiIGgbBSsKkcUutTHhOoCuaAUkKyvdDVgvVGqkBbCcKiIvVxNnuUdeEDXglLFnPVvpzAaZzSspHhCcPHhPpXNnfFZzzZxjJaWwATFfbByHLljUuGjJzZuUguUfLlFBbOvVoPBbdDpjjlaALejJPpHTtQqCcRVvrlyeExXGHfMHhmgGFhvVsHMmviPpKIqRrPiIIiEFuUaxXwWAbhCcpvpvVPooOWBrRbHyYRKwhHWbBAZTfkKNhHwWkXpmMPKkxKQjsLUumoOMzZRlxbBXbBuvrfFRBEebQPpcwcbpeEPBQCPpgGrnNRntOHfFrCcRgGhtbiIBOdxXNnDgoOVvUujJGKjgyrdGgMmgqmMnRrZpPjvCcVXxeEJgEeSsGihHYcCUfAFfxYyXcziIuUoONZuJjzZvkOsgeEzZVviIBfFoObnNglxXwLlWFfIiLlJeEjFftTZzLLlIrkzZKRcaACiuUdpzZPVhHqwWQvqQDJPpfWgFfVBbNnoMVmXqNnRrAaQOonQqMLlmUukckJvszobXtTmMjJeEUiAVMmvyziIUoOuzZYPuICrRchTdDtbBTtXxQvHhbBQqGRrgAaqjJlOocfFCCbCcBQnyndDFvVffHNbxHhhHIiTtlLXMmBmqQlnSsIhHitTNBbHhpSsDnDVXIisShovlqQPEeLLdtTOoZoOzDoZzOtMIhHchzZHLlDdCEuoNnOIOozZgWwvVvVWzdDvVRSsVwWwbByrRYVvrRvVfFONnzZEtTEeWXDNndcCuLlrRoOpZzGgbBChHcPTtWzBbwWGFfgZUGguwIDdsSsSFfYLlsSrkKRzZBNUuVsSLGglSsnNvHJHpfFWeEjJxCMhHmMmRruUuonNrRjuUJOUXxSsgGPAaBbCcZzpsQqoOLlWVwWyLlIiYSxXidtrxXRTDKkDdkKdwwWUuOfUXXxxJwWOojYWQqOoOocNVvnwWxpPrRueEwWsPpYySFfwWBblKaAkjJZOVvozDdYaARCccCreEyRrARraepiIPoOjJHhEeRryUuwWeoOfFwkKGGggPpQYGgQgBbLFffhKkHkKeysSYGgQPpnNqXkKqQwWirzZCwacdDeECAOoWcTtgbBGeEIWwWmzmFHhsSFfsSFnNFYCcaAyfpwWdiIDTBbhHWwdDVCiItTcHhMgoOjJtRAnNlLarTGGXHhfgGlLyxESswWFftSQqsQYJjlrRLIiPCjJxiItTuUjxdDXMcCBUurRTtpTXEZzeaAYEeyWDdKMmJiDdIUuEeVvkKHhVvKVvAQKkqfuUxXFRWyYwvUudDVslLvCcZzVvwsSWCOTDdkzYKkyZibKkmZkcCKzOoQqrRvVkQQqpTtFfZzkKNnPpMmPnNTHWErReXxrRwpdToOoOtKpghuUsSHGLlwWPiITiItQxvdvKkVOoxnNXDqmuyYvvjqQvVhHLAXzZfFGgWwpPHhOKkmMKkhpPEeTtXxKngGVvUUEewBJUuZmMzxXHFIifdDFbBsSiIRqqQQruUEDKkdTyoOYSSsSsvVidsSrRcFfCPplLDVvZzNntJAAaajrnNRecCEISeTlLjZzXyYxDnEYUhHNAanuwfBbjJFNZzoEaAhHezgcpMDdmnNPHGguUhwWLlcCcCFCLlddtWvVLLsSlJjGgEXdDoOLwWjBbJjjCcJDdJWWwwlVvkKUurXOGEeIigoNiInVMmvxCcbWwBwnbMmbHhBBMaPpmyYvVrRiOAZzaogVvkKrRGWwZzWqQpPpPweHhybWwKdDkBzZLlNneEMsSxXmYlhTbBtxXDlIiONnozSGgfFPyYcjJCXxpiuKOokUCWvVwcCTtnbBNbHhBPpMMmJJYyTtrXxTtzZRUIibicusSUhIKkaAoOuUjQLyjJYQCsSGXsxXSnuVvUKkyYxXWAEeazZwXxEejLpaAPlMmbBhHAlLPpaSsJMwGrRGggXxpaAPWiPpUDdvVFfubBqNkKlxXeEeEDfFdirRIDdgGeEveEVpPCcrUpPlkKLuNnRjJmIiAnNtTaMDdbBLIiVvOGSsLloOaAQLlIwWyOocCtLzZlvdVmMSAaaDTORxXaRrArxevuzZpvVXcCIeEiVhHCaAcbBjSoKkDdOBbgEFQqfEaJjfYtwQqWTzZzZyFAcCyYjJarRqsSQywWilKkLpJjEQqmMdDaAvaASpEebBhHXPpsSxgqQUuhKkFfvVhHSxXmMYyFEzEenNJjazZAIWwhHSsWwZxkKiIXEyYeEKkGwIiWNncCAlLtyYTalzRrZbBVvcCuxXUHhwEwWeBnNbLlXxDTQqbBtrRgnNGdWwTVvdDlUuHxmkkKyYEYhkKsXxSKCckdzZmMHhHqQVFlLJjXxzZfUXAauURNnrxXxyYoOuMmVvmMHhfSsdeEDNnJrRMsSENnUueEMmNnWWwKNVvngGkkKwwWZzNQqivVQjJqtTYySGZzncpWwPCeuNnUFaAcCfQSsLxXefFELllqmMUujJHhhHQnNlmPwWpMnuUNRrEeVvAaLnNoOhfoOeGdqQVJjpPcbByYDdzrRPpRrHhfKhcCwWHFfQqjJkFPHZzYXZzjJeExpPTIVGgRrHRrOohUutWwTDPplNnLvVZejkvGgVyXxNEenHrRhNZzXxnwWWwYkNFfnmITtinIiNqQaGgQZqGgQRrBvkKvVJKkjVfiIQezZpPQOKkKqQoEAIiDdaGgYyoOeOtQKknhHNhHrjJfFBfFHWwCchCnOGgLljJadMmDtCcDdGgeEnNkCcKdAAmDdiIMZzKkWQquOoSsxXOogGXAaQqxoOhHEenNnqlLcIcCAlLHhtTzBbyYDdZfFtTzGgZYyEeSFPxXpaAgGbdWwSsyYYJpHgjJGhVvHhPEexyYMmkSsnRrLlNxXVVytTeEbBYTtiIAaQLlkKqjJOovveGgEfFIpPizZimFZzJoODDdJjWdGgDgGRnkDdByYbKDfuUQqTJwWFPIIiXWbzZByaAYwWxXUuIiSsUsCAOoWwaWwcSyeEYLlTWwlLreBMKkrRLlakKAfNnoOjJUiIpPCcrRQqvZzgGVwWpRnNRULAmMBzZPpbVWwXwWJRBbrEesSHKkhjJqQKmDrRAagjJkweEWKQuUGvVmAaMHpPhJvVHcCekKdbBKcCyFfAaAaYSftXxDkKrKeEcCWwMmkVsRrStEBmMovVMmdDOzxGMmKpgDdGHcChaAIrRFqbBbBdDsSBbQqDrCcRIIiqQiiIxXdvVvavVmlLMgZzsSEegGGTJjMHRrhmYJjyFftTtsfFSCcsnlLiOoIKkvwjJWgGmMOoRrVVvfYyrQqROoZzFRgGvTgxKBbNnkbxXBBbOoUXxubBTtgnNGXYyJjWSbBiIsWEecPpFZSsSzZWHhSeEJjJCcjsDdzZcnnVAakeERUunNQUuqRrwNSeEHhwWQqQRrEuUfFIdDBkKbNUungGoOwoOWQqlLEQiIqXgtTEApfFMiIjPDdpRrsOfFlLoWwKvVlByYbVmfFMMmZcvbBVIiTtLlLbBCcHXxoOhhpPShyLtTOolYOpOQiIWTtxjJJjTtyFfYAaAEeQqSszIiZaRvVUurvVvMmVYyqMYVtgcCGTvyXwAaqqQQdhdeEDCfFcRIiYoODdAarWwMmhnNjJJjeEpPICciMVcCvmhHGgvEevVDxvGDSkKsnMXDWlLwWbDCcdUPpmFdDfDdMbBRrTKTtUQquCczZlLTtiKkIEeKwobBOWadrRpPlHhJZfRrFzBbAOlqQLKkXxYyLSsMmIzZiDFfpPoOEeBOiIhIiOonDfOoOoqQDdWqQdBJjAaIayCVjJvyYOAalLoyYOnNAaFnNvVflLMowWLlNnKkjJKkKknNCiIekIZzwEeWjJiHRrhIeETiwWIOhHozDdvVvWwXxokxXKOQEbBajyYrqQpXNVvmMnxElgGTtLeGgiIHNncUuvDdbBOVqaTteEAwWUuQqQqGPpOogGgLlhmMhHHqQowfFHhWXxcBbYyfopPEEeuUuuUxNsSAaAzZUufFdDaKWwbBWwkqrTtRIZziiIgGCmMhHpPcKkBJjxEeDhbBHfFdAhHMmalLsoOIiSXyYSvVzoOlcCLUuhHWwCHxXWwhLlVOovWKkwHmdDWKmMIeEANOouDpmMaAIhldDlLLDCcNLvVcCcyhoOHYRrMmCIiGlbBXxtElLIYwWwWuUfzBbZTtgGbMCcqQtPpWgGkKwrWAaxXvVIiDhthlLgaAGHzZnNBbwWTHlCczhHFZzfCczZZMKkmqQXFOofxEeGQqgLdAgdAaCIiXKkcCZzxjYyTtJITiISwWscEeCWaAOotTzRrPpZtTlWwLmMpUuLtTtJjTNkKszZAMmaBtHcOhHLloCglLGcChTlWOohHzZIiITtCxLlPpfFtTKLiEeMmeEUlLdDuuUoTtnNOfFRlSswzZcGgCamMfMmFHhbIiCugGvVtTUuPXxpUBbjJwWzIiEeZdVCuUcvkKGgyXxIiXxhHzZEeeKkcCXEeEXxzXxYyjJseESIlLEeVvIiKohHxXBvVboOGgQHhqgGoNnQqXWbBwCcHHDdhRrYlLyYYgGyIJLAaXxlcCaYyisSDeEaAbBdMmoOvAaJcbBDdMxvVjJHDzZABbJFfIijatTdOcChqQjJPqOoQpOozZVgfzZXeExUAaUyYXbPpBxuBbMmWwGfFDgGZzbFfBuUsXxCDkKdYmMlbBEeLJjbhLlUuJjOoqZdDiItTOaeBbLlEhHJvVjXxKxvVVmUuxXMuUTtpZzPSUuWcCfFFuUfoOgTtGUuJjgGkAajJKTEetsAagKcCbBdOhHoKhtBbwWrRTHIiDddIltfoOFgWwtAAKKIUZkKzHjJduUDGgNnyYjJWwYdDyRrxGgpQgGqPmMVvXrRGgQqhKwnNWRUurbGgBaZQqRpPrzAeEkxXEvnNpcMmnNeECPdDRrlCcxVvXxDPMmvVNLKuUxXFfIiklnofFgGWwOPpdDGgyYpPsSYyuUhHTtFfOiIomOohHcyYCMoOhHmYZzyOgGaAOoYyohHMnNUuSfFsPxXpnmMNnGgLlNMmuwWZzKkZzMVzZqQcCjJRJjrWYHaAhVvywXvVaAMmMmHhUuJIiqQwuUWvJTssSHkvVKCchTUNAaDsDdbBSdnXxRresStNnPLljTtfbsSkKEejJLbBOoLCuUcaARrlDdXGNngxHtThkKhbBjZzugGUUTCsSgGckKHrRHhpbBzZzPeEeNLloOZzneEvrQqWwRyYNDdJjnRrTaAuUOiIocDdjJCNnCSgGDPGgpdkmLUulVngGNMgGrFfjAykKHhlLuUoOAaetTElSxeIHhiWwpPHzZwWjJaAhGzZSWgGIGpPgsSiLlEewcjJCUVvuBbAasSqAaQpPkuUUlLuKkXxEelLiNnMSsCcTtJjDdwWDdmBbIwWiyYDdpGrFYdYyNnDBhHdDOobdPsqQSKsSdDHhkgGZztTiDmMjvVJjJTtdIsSFfphHOowkGSsgOsSbBRxzZNnJjUTtuqQIiwvVBbJjVvfFEeNkKnoTtfFqfjJLlFQOtgGTPTEGgaACcHhDYytTtUuZlLHhpmuUMKkWwTlRrXxMaAmeEQqyYXxLWwEMwWwWmBfFDdbGiITQqriIBbMnbBYJjMmSsbByolLmhHMWwHwWhxKkXKOokkOoXxxXKwIiTyjJUWKkwuBbIxyYuUxytkKBbhHTdaABmLlwWMpPMyYTtmVveEbsMmSFfMMmcCzZjMhHmPpKuzZUVvkSQqsiIXxuUMmKuUSshyYrRHPpXxongGMmilksSKLYyovVOIXiIMmNnVvCGxXgVvrPpRpPcxXYFfyXdpPQqIioHoOqQhgNvVsSnGyYZAabBmPpyYzMmZGgwWMdDoOCnaeEGDfFziaAXYyxICcWMlLcEetTUHhUuSsuuUfiIVAavFNvVnrRLIiliIduUnNLDhEeHzZNnXxdTtMGjJWwgDcyYejJshfFMLlmPpWXxRryYxBrRbUuDRrhHdNUujAaJAdDaCxvVXxSsXsSMENnZOSsqYynvVNBbMyYEeDdhEeHmBbblLVvqeEYyOobBuUCcCcCjJcSjJsuaAUMjJyYRrdPMUumYJjyxMihHIHhkpPPpKeXoOxEIigKkGgGmaAsylwWMmIMmNnCIfFiCJjMcCmDYyUKRrkWwRrsShHIhHFWxNnPpuRrMMmmMUAaumXlLHhKSsvVSskxUkdDKqBbQpSstUuTvVokKOPkKrUuRgGJZvVtTbsbBvVUuHhhHxUWwiIhHFfKkumMjAatMmlLKkiDfdDLkKAaevVZzZzpVvGgboOBPEliInKiISTtXqnNQxBNnVvbWwBboOwERcnNzfFZzhFfHPrUUuuRpDDHhddRrXFNncCoEWwEeRzEeEOoCqQcTjJtUuKkFfeOZzRrIDdGZzkKgUpVvPGgvVHhuotTLlHAahAaOoxXlUuLYyBViouUOIvbPpWuUuROorUiIuLdDQqTtLlVvXxBOocCkjJKzZGgJjbBDdUDPpdBbjJHhUqgMTQqiIvVtRtTrsRrzUuhmMHvVHhglxXQgGjxXMmyLlYlLPpyYJqJfFjhgGsSxXrWwFfyYLlVvqdTtxXeEgGihHfFIIitTjJpPwWBbYySsbBrRDjJgGNnfFvxXgGfwWSsFSsjyYJVaAtxXfeEeEkKaNnUfFuvOosGgSjYsSaAnNBfFvrZPpwWnNTtSsgMmGgqQTtRrMmwPpSsWhRrvViEeIHhHHhqaAQGJjzkKppPBbPZpaAZzMmUuWgsVvmMcCgGLlbbdDBdEeGgDbvVhAaHdDGgBBlWprRPEewEsSYyEepPeEeLSrRuUIWwXxizsQpPkKqfFSeEUdDZlHhLNnzuPWwcCnNmMJjrRkWLqQJjYyixXvVIVvPpOcQqjoOiEeIeEJCoZhyYpgxUVvugjJGXbBkKLqQlETBuUbteUroOVvRBbiIdDZWwznNBGgDdsSbuNvVsSIieKiIGgjJdPoOpWwDyfFpPYIikdDTtpPEaUuAIizZUpPuYsSCcYyIFvNOoutTUfFyYHhWxXqQoyYOwaAvVyYKkngGJjmGHAaiICcSRApPJjeEaSsiIeIiEdDrsQHhWwKkYyuUscCFVvfSAwoOyYWaYyeEUnNCBbsLIilSvZNnzUuVuUpqQZzLlPcCsScpEBbNdDnegBbTtGPyOoYyYPvawDdWtJjlkKQlLKkhHqWwSsLlfjPpKkJFjJRrEeHvFfVEQKkqdDJjXLhHlTtJjxLlWtRrTIlLiZhJjiIHzwxXjJKcMyYmCCcHhksSLlenNWRrwScZzCDdsrqQRgGzPsSpBALlFfacCEzZOomMiIejGgtTJoOlLBbsSbzZpPBZzTtJWwjLSslbBMsqQSsqGgQGgSqlayYeEAQFNnfqhHJjPpAadDvEeVcCbBpPKgGoOkRQqrerREGwWfZzFeEgwmMZpPIiUWwuAazpbBvVqQPtTWStEeTvVaAskXRrxHhKbNnqQBIpPiebIgGasSACciEwOoSsWiIZzeBMcCmpCcPEFEefrRCZzcVqAaQJjvJjKZznaAaANAakoOPpbJjBDUvVudDdYsSyIiBbZWSAaAaHhValLAwWAavLlHxXheEeEVixXjJIEyYxXiIxkKwvVRrOorRWwWQlLqLlUusSJjbBhlLZgGzGgncPpCNjlXKkxLoORrJHnPVEekKvpNWqKvVTJjtEuiIUwWwWCcyYPWwpcCjiITtYcCyECceJjpnNPJBkhHfBbzkKMDHhdmJHhjtTFfyJjHhdUujyYXxJKkQqDMwWuUmmukKUZzjJuUHOoOoDdqQqQaAUuyYrHhRkKbBWwhazloiIhHRrOLPpDNnZZzLzgGZYNnqQylfFaAeEiICczdmoOLeElmMnWLlwvvrRVaAVPsSqQpuUzYyRrZBboOKkgGTNGgntMmssSbtLfmMFciICdDloOTfYyPpSNFfnWwiuUIBwNnAaWkZUuIiQqzKXxvoOtTmMbGgcTYydDRHtThrQqlLwAaalLALAalvVXYNnNPpuUKkNLlpPkKnhtTHtTXxlEnNeAHhaUuVAavLHhBbzTtFfZGBbaAJjvEeVxXZzgKHhkgpPxXPfFeEpGcCCDdDdreJjErRHhxBbzZXxXCaAyYclLDvPpVtTdCkDdJjKmmMlIiLMmMKkYXmMQVvXxUuREeJVvqQLlBVvZzbjOGgSSsoOsGgHheEdDoRtTrXxWoOwOjJoYyMmVvAaFBbfEeTtqKzZkIEepPNuUnEeGbBlLcFrEeREwWqhHQmOoMXxeAQPjJpJjCcoBbYypNYynWwIiaVvAcjJeEApPRrNnICcxXiaANnakKEehHRrgGCPoOsEeStTdfFDpPAaNnNIiTtZznPoOpiISsXxjIMpPmtcCTieIHhSlLgBbGglLLlheEtspPxXSTTrRlUDdupyYYyhHUNnFfpiIxXTMmtfXxxXFPeEmxXVKkfFvCcrWLVvlwRqRrQFfPVvFfFlLZzdDfpHhbBWwyxQqXZmMVgbBGvlUuLxXYyzAabBCkQqZqQiImRnNrRhcCHrMpPQIiHDdhqdqQMmigGrRIiTtlLZwWYyEPpekHOohVvKDdRfSspiIPZLlzFrNnmwWtTMnNrReXxifFIsSwuUWEOYyKrRkfrfcCFtTCcwNSsnWJOojOUXsSxBbjXxjJJuFfYMmCcyGtWwTbBLnNyYlOohHSsLlgSDdoOHhhHsMQqYytTHtTjJOoLlhKkowWUbBTtsWwSuNnLlxXrROcyYZfFzvVCZzHhqHhNeiIckKVvuUuJjiIJjUXxzZCEGHiIyYhgDsSHLlfFUuhrNnRaApAsSaPXxdkdDGgKzZntWwTkKbpvVuUGgPQcCqUHhuWwNnuUEelLYVvhHyBvGgVrRBbreEWwRsiIHYJjAIiatDdaATWwyOohEdmMDYyTtYyDdJKkKGgkXLFflwEeWUuGgfVqQvBbFYyeEtrRCTHhvVTtpPtdMmDiINnrHhQqfFrcCRdQqkCmMtTYyeEcGWwtTlgSrDdVvRsGgaARrOAaTtEjJQHhqeoWffFFuUwRJtTcuUCjruUmCcLjfFVhHXxrsSRnNuUVvaTtBnRrNiIbBbAxBbpPGuUgBbXbByYqQkKqQaDdALlIiprTtROoPwDdGbBpPIigWxCcCtTcImSsYyMJjuJjUmMpPtMmhHpPTGgjJpPaAcHhCiTfFEcCetVwWvKTtkKkiItKkIiyYQqOoTVxXgGJXsSxWwrREeJzZjpRoOrPnNjvoOqQruURNnhHmJjMKkXFOMmofFfNnbBZzJjpwWBbxXPYytTzZuUYEeyraARNnpKVSsvkFfVvAQnNqBbitTfFgmMGIoOPphHaTtTtMidDIWwRDdrRrcCvVqQqyYmeEMWeErRwcCXxBbryYKkRxXRHhmeEMmsSMSsruUFAFfmtTMabIilLFWRrwfkIiYyeEPpKfFGgFffFTtBaAQLEelPyVvYpXlLPpYyxqxXVgGwIiWkLlKfkKzZFZzwWVwWLlvvgUDduaAdWwDWDdwDdDqQdsSlLvVvVqQCcuUkKsSzZGjJoOfMOojJmlLjqQJjJQtTVvapPCcAJXxjXxerRhHESsmxJjnNWhHyYwXOoSsYyxXeSsxXZzZzLlhXxHEGjJgjiIJGhaAsbBvVeuUFzZfZzESgaZzAzzZvVZbAaBGtTHrGgRrRBhHnaANbcsxXSApPonNObmMBanNtTkKYWwaArKuUmMoOyYKkkbBWwfFRrRTtGgTpPeEtsWNNnnRroOjrRJwNcDduUCnORBbrGguUoZzsSsSUNnuAaPpIYysSiNnhHdDFfkKSsQCXxaAEUuecxrHkKMmhHaAhQqtxXaAOHGghZTtzoTFfOoiIcChHnNUmMuYyRJjdMmDPsSXxTtppPqQJjlLZCcHhqQgGzXPTtpMbBmqqQQAuUTdrRDnNxXWwtvVYyiIIigGOoVvYyHhagGZzKkqVvrlLdDROGgovVKpPkBbwWOotTOrRgGWwHhfFKkgTtGWwNnwiUiIuIQDdKkSsSsYQOoVvHhaABbsSDGguUsSCzZcIxXidziYyrrRRIqrRGgQWwMjJmFfZJjnNhqQmiIYyAaMhnNHiInNMyqQkKIGgiYQXxqoOTpPtmyAaYpPqcbBCQqXxpPQExXexXiIHLzZSswWlLlJUugGjoOrRJjqYyrxXRkoObFfDdBWwKkkKnBgGUubsSNqQpkcCKgGPdDgfFGxuUmCcfFmMSBLlDdPRrkzZKIigGfNiInFYyGtTbBgnsSzZhHoONgOoGbBTFfrRzZFfgQqGyYmsSMtnNCwpPWwWrQqRcoOBbhnNHjJpTtTtdbBfFSsDEebfFLlBbmGTtgMHhaAhHS&quot;
;input: db &quot;dabAcCaCBAcCcaDA&quot;
static input:data

%define input_len 50000
;%define input_len 16

section .text

exit:
static exit:function
  mov rax, SYSCALL_EXIT
  mov rdi, 0
  syscall

write_int_to_stdout:
static write_int:function
  push rbp
  mov rbp, rsp

  sub rsp, 32

  %define ARG0 rdi
  %define N rax
  %define BUF rsi
  %define BUF_LEN r10
  %define BUF_END r9

  lea BUF, [rsp+32]
  mov BUF_LEN, 0
  lea BUF_END, [rsp]
  mov N, ARG0

  .loop:
    mov rcx, 10 ; Divisor.
    mov rdx, 0 ; Reset rem.
    div rcx ; rax /= rcx

    add rdx, '0' ; Convert to ascii.

    ; *(end--) = rem
    dec BUF_END
    mov [BUF_END], dl
    
    inc BUF_LEN

    cmp N, 0
    jnz .loop

  mov rax, SYSCALL_WRITE
  mov rdi, 1
  mov rsi, BUF_END
  mov rdx, BUF_LEN
  syscall


  %undef ARG0
  %undef N
  %undef BUF
  %undef BUF_LEN
  %undef BUF_END

  add rsp, 32
  pop rbp
  ret

solve:
static solve:function
  push rbp
  mov rbp, rsp

  %define INPUT_LEN r10
  %define CURRENT r9
  %define NEXT r11
  %define REMAINING_COUNT rax
  %define END r8

  lea CURRENT, [input] 
  lea NEXT, [input + 1] 
  mov INPUT_LEN, input_len
  mov REMAINING_COUNT, INPUT_LEN
  lea END, [input]
  add END, INPUT_LEN
  

.loop:
  movzx dx, BYTE [CURRENT]
  movzx cx, BYTE [NEXT]
  sub dx, cx
  imul dx, dx

  mov rcx, 32*32

  cmp rdx, rcx
  jnz .else
  .then:
    mov BYTE [CURRENT], 0
    mov BYTE [NEXT], 0

    sub REMAINING_COUNT, 2

    .reverse_search:
    dec CURRENT
    mov dl, [CURRENT]
    cmp dl, 0
    jz .reverse_search


    jmp .endif
  .else:
    mov CURRENT, NEXT
  .endif:

  inc NEXT
  cmp NEXT, END
  jl .loop

  %undef INPUT_LEN
  %undef CURRENT
  %undef NEXT
  %undef REMAINING_COUNT
  %undef END


  pop rbp
  ret

global _start
_start:
  call solve

  mov rdi, rax
  call write_int_to_stdout

  call exit
</code></pre>
</div>
</body>
</html>

]]>
    </content>
     </entry>

     <entry>
       <title>How to compile LLVM, Clang, LLD, and Ziglang from source on Alpine Linux</title>
       <link href="/blog/compile_ziglang_from_source_on_alpine_2020_9.html"/>
       <id>urn:uuid:6cccb673-c083-550b-a1c8-d7a27819f1c7</id>
       <updated>2023-12-15T11:33:55Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/highlight.min.js"></script>
<script>
window.addEventListener("load", (event) => {
  hljs.highlightAll();
});
</script>
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>How to compile LLVM, Clang, LLD, and Ziglang from source on Alpine Linux</h1>
<p><a href="https://ziglang.org">Ziglang</a>, or <code>Zig</code> for short, is an ambitious programming language addressing important flaws of mainstream languages such as failing to handle memory allocation failures or forgetting to handle an error condition in general.</p>
<p>It is also fast moving so for most, the latest (HEAD) version will be needed, and most package managers will not have it, so we will compile it from source.</p>
<p>Since the official Zig compiler is (currently) written in C++ and using the LLVM libraries at a specific version, we will need them as well, and once again, some package managers will not have the exact version you want (10.0.0).</p>
<p>I find it more reliable to compile LLVM, Clang, LLD, and Zig from source and that is what we will do here. I have found that the official LLVM and Zig instructions differed somewhat, were presenting too many options, and I wanted to have one place to centralize them for my future self.</p>
<p>Incidentally, if you are a lost C++ developer trying to compile LLVM from source, without having ever heard of Zig, well you have stumbled on the right page, you can simply skip the final block about Zig.</p>
<p>Note that those instructions should work just the same on any Unix system. Feel free to pick the directories you want when cloning the git repositories.</p>
<pre><code class="language-sh"># The only Alpine specific bit. build-base mainly installs make and a C++ compiler. Python 3 is required by LLVM for some reason.
$ apk add build-base cmake git python3

$ git clone https://github.com/llvm/llvm-project.git --branch llvmorg-10.0.0  --depth 1
$ cd llvm-project/
$ mkdir build
$ cd build/
# The flag LLVM_ENABLE_PROJECTS is crucial, otherwise only llvm will be built, without clang or lld,
# and we need all three with the exact same version since C++ does not have a stable ABI.
$ cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=&quot;AVR&quot; -DLLVM_ENABLE_LIBXML2=OFF -DLLVM_ENABLE_TERMINFO=OFF -DLLVM_ENABLE_PROJECTS=&quot;clang;lld&quot; ../llvm

# nproc is Linux only but you can set the number of threads manually
$ make -j$(nproc)
$ sudo make install

$ cd ~
$ git clone https://github.com/ziglang/zig.git --depth 1
$ cd zig
$ mkdir build
$ cd build
$ cmake .. -DCMAKE_BUILD_TYPE=Release -DZIG_STATIC=ON
# nproc is Linux only but you can set the number of threads manually
$ make -j$(nproc)
$ sudo make install
</code></pre>
<p>You will now have a <code>zig</code> executable in the PATH as well as the zig standard library. You can verify you have now the latest version by doing:</p>
<pre><code>$ zig version
0.6.0+749417a
</code></pre>
<blockquote>
<p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&amp;locale.x=en_US">Donate</a></p>
</blockquote>
</div>
</body>
</html>

]]>
    </content>
     </entry>

     <entry>
       <title>This blog now has an Atom feed, and yours should probably too</title>
       <link href="/blog/feed.html"/>
       <id>urn:uuid:1f4df7db-eea8-5ef0-ae92-1038111f5dc9</id>
       <updated>2023-12-15T11:40:57Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/highlight.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/languages/scheme.min.js"></script>
<script>
window.addEventListener("load", (event) => {
  hljs.highlightAll();
});
</script>
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>This blog now has an Atom feed, and yours should probably too</h1>
<p><em>Find it <a href="https://gaultier.github.io/blog/feed.xml">here</a> or in the header on the top right-hand corner.</em></p>
<p>Imagine a world where you can see the content of each website you like inside the app of your choosing, read the articles offline and save them on disk for later, be notified whenever the website has something new, and all of which is implemented with an open standard. Well that was most of the web some years ago and this blog now does all of that.</p>
<p><img src="feed.png" alt="This feed inside the open-source app NewsFlash (https://flathub.org/apps/io.gitlab.news_flash.NewsFlash)" /></p>
<p>And it's not hard! The only thing we need is to serve a <code>feed.xml</code> file that lists articles with some metadata such as 'updated at' and a UUID to be able to uniquely identify an article. This XML file is an <a href="https://en.wikipedia.org/wiki/Atom_(web_standard)">Atom feed</a> which has a nice <a href="https://datatracker.ietf.org/doc/html/rfc4287">RFC</a>.</p>
<p>I implemented that in under an hour, skimming at the RFC and examples. It's a bit hacky but it works. The script to do so is <a href="https://github.com/gaultier/blog/blob/master/feed.go">here</a>. And you can do too! Again, it's not hard. Here goes:</p>
<ul>
<li>We pick a UUID for our feed. I just generated one and sticked it as a constant in the script.</li>
<li>The 'updated at' field for the feed is just <code>time.Now()</code>. It's not exactly accurate, it should probably be the most recent <code>mtime</code> across articles but it's good enough.</li>
<li>For each article (<code>*.html</code>) file in the directory, we add an entry (<code>&lt;entry&gt;</code>) in the XML document with:
<ul>
<li>The link to the article, that's just the filename in my case.</li>
<li>The 'updated at' field, which is just the <code>mtime</code> of the file locally</li>
<li>A UUID. Here I went with UUIDv5 which is simply the sha1 of the file name in the UUID format. It's nitfy because it means that the script is stateless and idempotent. If the article is later updated, the UUID remains the same (but the <code>updated at</code> will still hint at the update).</li>
<li>The content, as HTML, simply embedded as is inside the document</li>
</ul>
</li>
</ul>
<p>And...that's it really. Enjoy reading these articles in your favorite app!</p>
</div>
</body>
</html>

]]>
    </content>
     </entry>

     <entry>
       <title>Solving a problem with Gnuplot, the programming language (not the plotting software!)</title>
       <link href="/blog/gnuplot_lang.html"/>
       <id>urn:uuid:f2d9c4e3-5c3d-57ab-8083-0f56daf1f41e</id>
       <updated>2023-12-15T11:33:55Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>Solving a problem with Gnuplot, the programming language (not the plotting software!)</h1>
<p><em>Is it any good? Can you solve real problems with it?</em></p>
<p>Most people know <a href="https://en.wikipedia.org/wiki/Gnuplot">Gnuplot</a> as a way to plot data. Two lines of code and we can visualize data:</p>
<pre><code class="language-gnuplot">set output &quot;plot.png&quot;
plot &quot;out.dat&quot; with lines
</code></pre>
<p><img src="gnuplot.png" alt="gnuplot.png" /></p>
<p>where <code>out.data</code> is a text file with a number on each line.</p>
<p>The software engineering advice that I heard a long time ago and left a mark on me is: <strong>Find a way to visualize your problem.</strong></p>
<p>So Gnuplot is definitely worth of a spot in a Software Engineer's toolbox.</p>
<p>However, few know that Gnuplot is actually also Turing complete programming language. It is similar in syntax to Perl or Awk. So I scratched an itch and solved a <a href="https://adventofcode.com/2023/day/1">problem</a> with it.</p>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#the-problem">The problem</a></li>
<li><a href="#closing-thoughts">Closing thoughts</a></li>
<li><a href="#addendum-the-full-code">Addendum: The full code</a></li>
</ul>
<h2>The problem</h2>
<p>In short, we get a text file where each line contains random ASCII characters. For each line, we must find the first and last digit characters, combine them into an number and at the end output the sum of all these numbers.</p>
<p>The way we read the data into a variable is through a shell command:</p>
<pre><code>data = system(&quot;cat in.txt&quot;)
</code></pre>
<p>Gnuplot has the <code>plot</code> command to turn input data into a plot, but nothing built-in to read input data into a variable, it seems. No matter, <code>system</code> which spawns a command in a subshell does the trick.</p>
<p>Since we need to check whether a character is a string, let's define our own little function for it. Yes, Gnuplot has user defined functions! The unfortunate limitation is that the body has to be an expression:</p>
<pre><code class="language-gnuplot">is_digit(c) = c eq &quot;0&quot; || c eq &quot;1&quot; || c eq &quot;2&quot; || c eq &quot;3&quot; || c eq &quot;4&quot; || c eq &quot;5&quot; || c eq &quot;6&quot; || c eq &quot;7&quot; || c eq &quot;8&quot; || c eq &quot;9&quot;
</code></pre>
<p>Characters are not a thing; instead we deal with a string of length 1. Comparing strings for equality is done with the operator <code>eq</code>.</p>
<p>Then, we iterate over each line in the data. Gnuplot has a for-each construct we can use for that.</p>
<p>We then iterate over each character in the line with a for-range loop, isolating the 'character' (remember, it's just a string of length 1) with a slicing syntax that many modern languages have:</p>
<pre><code class="language-gnuplot">sum = 0

do for [line in data] {
  len = strlen(line)

  do for [i = 1:len] {
    c = line[i:i]
  }
}
</code></pre>
<p>One thing to note here is that strings are 1-indexed and the slicing syntax is: <code>foo[start_inclusive:end_inclusive]</code>.</p>
<p>We then set <code>first</code> to the first digit character we find:</p>
<pre><code class="language-gnuplot">do for [line in data] {
  len = strlen(line)

  first= &quot;&quot;

  do for [i = 1:len] {
    c = line[i:i]
    if (is_digit(c)) {
      if (first eq &quot;&quot;) {
        first = c
        break
      }  
    }
  }
}
</code></pre>
<p>We do the same for the last character, iterating in reverse order:</p>
<pre><code class="language-gnuplot">  last = &quot;&quot;

  do for [i = len:1:-1] {
    c = line[i:i]
    if (is_digit(c)) {
      if (last eq &quot;&quot;) {
        last = c
        break
      }  
    }
  }

</code></pre>
<p>Finally, we concatenate the two digits (which are still two strings of length 1 at that point) with the <code>.</code> operator, convert it to a number with the <code>+ 0</code> idiom, and increase our sum:</p>
<pre><code class="language-gnuplot">  num = first . last + 0
  sum = sum + num
</code></pre>
<p>We just have to print the sum at the end:</p>
<pre><code class="language-gnuplot">print(sum)
</code></pre>
<h2>Closing thoughts</h2>
<p>Pretty straightforward, isn't it? Well, no. The language is weirdly restrictive, for example <code>sum += num</code> does not parse. <code>for</code> and <code>while</code> loops cannot for some reason be used interchangeably due to the weird <code>do</code> prefix for for-loops. Very few builtin functions are available.
There does not seem to be basic data structures such as arrays and maps. Every variable is global. And so on.</p>
<p>It's weird because the language also has very modern constructs that some mainstream languages still do not have, like the slicing syntax.</p>
<p>Awk, Lua or Perl are honestly better in every way, to pick relatively simple, dynamic languages that people usually reach to for Unixy text transformations. And these will have better tooling, such as a debugger. Heck, even shell scripting is probably easier and more straightforward, and that's a low bar.</p>
<p>Everything points to the fact that Gnuplot expects it's input data in some prearranged tabular form, and just wants to plot it, not transform it. That means that another (real) programming language is expected to do prior work and Gnuplot is at the end of the data pipeline as a 'dumb' visualization tool. I can also see how the limited language can still be useful for Physicists or Mathematicians to write simple numerical, pure functions e.g. <code>f(x) = x*2 + 1</code>.</p>
<p>I'll investigate Julia and perhaps R in the future, which are in the same niche of science/data visualization but are full programming languages with plentiful tooling.</p>
<blockquote>
<p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&amp;locale.x=en_US">Donate</a></p>
</blockquote>
<h2>Addendum: The full code</h2>
<p>Run with <code>gnuplot my_file.dem</code>.</p>
<pre><code class="language-gnuplot">data = system(&quot;cat in.txt&quot;)

is_digit(c) = c eq &quot;0&quot; || c eq &quot;1&quot; || c eq &quot;2&quot; || c eq &quot;3&quot; || c eq &quot;4&quot; || c eq &quot;5&quot; || c eq &quot;6&quot; || c eq &quot;7&quot; || c eq &quot;8&quot; || c eq &quot;9&quot;

sum = 0

do for [line in data] {
  len = strlen(line)

  first= &quot;&quot;

  do for [i = 1:len] {
    c = line[i:i]
    if (is_digit(c)) {
      if (first eq &quot;&quot;) {
        first = c
        break
      }  
    }
  }


  last = &quot;&quot;

  do for [i = len:1:-1] {
    c = line[i:i]
    if (is_digit(c)) {
      if (last eq &quot;&quot;) {
        last = c
        break
      }  
    }
  }
  num = first . last + 0
  sum = sum + num
}

print(sum)
</code></pre>
</div>
</body>
</html>

]]>
    </content>
     </entry>

     <entry>
       <title>Cycle detection in graphs does not have to be hard: A lesser known, simple way with Kahn's algorithm</title>
       <link href="/blog/kahns_algorithm.html"/>
       <id>urn:uuid:665ef523-5c28-5dad-8582-587bfea27205</id>
       <updated>2023-12-15T11:33:55Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/highlight.min.js"></script>
<script>
window.addEventListener("load", (event) => {
  hljs.highlightAll();
});
</script>
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>Cycle detection in graphs does not have to be hard: A lesser known, simple way with Kahn's algorithm</h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the-database">The database</a></li>
<li><a href="#topological-sort">Topological sort</a></li>
<li><a href="#how-to-store-the-graph-in-memory">How to store the graph in memory</a></li>
<li><a href="#kahns-algorithm">Kahn's algorithm</a></li>
<li><a href="#implementation">Implementation</a>
<ul>
<li><a href="#helpers">Helpers</a></li>
<li><a href="#the-algorithm">The algorithm</a></li>
<li><a href="#inserting-entries-in-the-database">Inserting entries in the database</a></li>
<li><a href="#detecting-cycles">Detecting cycles</a></li>
<li><a href="#detecting-multiple-roots">Detecting multiple roots</a></li>
</ul>
</li>
<li><a href="#playing-with-the-database">Playing with the database</a></li>
<li><a href="#closing-thoughts">Closing thoughts</a></li>
<li><a href="#addendum-the-full-code">Addendum: the full code</a></li>
</ul>
<p><em>If you spot an error, please open a <a href="https://github.com/gaultier/blog">Github issue</a>!</em></p>
<h2>Introduction</h2>
<p>Graphs are everywhere in Software Engineering, or so we are told by Computer Science teachers and interviewers. But sometimes, they do show up in real problems.</p>
<p>Not too long ago, I was tasked to create a Web API to create and update a company's hierarchy of employee, and display that on a web page. Basically, who reports to whom.</p>
<p>In the simple case, it's a tree, when an employee reports to exactly one manager.</p>
<p><img src="kahns_algorithm_1.svg" alt="Employee hierarchy" /></p>
<p>Here's the tree of employees in an organization. An employee reports to a manager, and this forms a tree. The root is the CEO since they report to no one and so they have no outgoing edge.</p>
<p>An arrow (or 'edge') between two nodes means <code>&lt;source&gt; reports to &lt;destination&gt;</code>, for example: <code>Jane the CFO reports to Ellen the CEO</code>.</p>
<p>But here is the twist: our API receives a list of <code>employee -&gt; manager</code> links, in any order:</p>
<pre><code>Jane -&gt; Ellen
Angela -&gt; Ellen
Zoe -&gt; Jane
Zoe -&gt; Angela
Bella -&gt; Angela
Miranda -&gt; Angela
</code></pre>
<p>It opens the door to various invalid inputs: links that form a graph (an employee has multiple managers), multiple roots (e.g. multiple CEOs) or cycles.</p>
<p>We have to detect those and reject them, such as this one:</p>
<p><img src="kahns_algorithm_1_invalid.svg" alt="Invalid employee hierarchy" /></p>
<h2>The database</h2>
<p>So how do we store all of those people in the database?</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS people(name TEXT NOT NULL UNIQUE, manager BIGINT REFERENCES people)
</code></pre>
<p>Each employee has a optional reference to a manager.</p>
<blockquote>
<p>This is not a novel idea, actually this is one of the examples in the official <a href="https://www.sqlite.org/lang_with.html">SQLite documentation</a>.</p>
</blockquote>
<p>For example, to save <code>Ellen, CEO</code> inside the database, we do:</p>
<pre><code class="language-sql">INSERT INTO people VALUES('Ellen, CEO', NULL)
</code></pre>
<p>And to save <code>Jane, CFO</code> in the database:</p>
<pre><code class="language-sql">INSERT INTO people VALUES('Jane, CFO', 1)
</code></pre>
<p>Where <code>Ellen, CEO</code>, Jane's boss, which we just inserted before, has the id <code>1</code>.</p>
<p>Immediately, we notice that to insert an employee, their manager needs to already by in the database, by virtue of the self-referential foreign key <code>manager BIGINT REFERENCES people</code>.</p>
<p>So we need a way to sort the big list of <code>employee -&gt; manager</code> links (or 'edges' in graph parlance), to insert them in the right order. First we insert the CEO, who reports to no one. Then we insert the employees directly reporting to the CEO. Then the employees reporting to those. Etc.</p>
<p>And that's called a topological sort.</p>
<p>A big benefit is that we hit three birds with one stone:</p>
<ul>
<li>We detect cycles</li>
<li>We have the nodes in an convenient order to insert them in the database</li>
<li>Since the algorithm for the topological sort takes as input an adjacency matrix (more on this later), we can easily detect the invalid case of a node having more than one outgoing edge (i.e. more than one manager, i.e. multiple roots).</li>
</ul>
<p>From now one, I will use the graph of employees (where <code>Zoe</code> has two managers) as example since that's a possible input to our API and we need to detect this case.</p>
<h2>Topological sort</h2>
<p>From Wikipedia:</p>
<blockquote>
<p>A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another; in this application, a topological ordering is just a valid sequence for the tasks</p>
</blockquote>
<p>That's a mouthful but it's not too hard.</p>
<p>A useful command line utility that's already on your (Unix) machine is <code>tsort</code>, which takes a list of edges as input, and outputs a topological sort. Here is the input in a text file (<code>people.txt</code>):</p>
<pre><code>Jane Ellen
Angela Ellen
Zoe Jane
Zoe Angela
Bella Angela
Miranda Angela
</code></pre>
<blockquote>
<p><code>tsort</code> uses a simple way of defining each edge <code>A -&gt; B</code> on its own line with the syntax: <code>A B</code>. The order of the lines does not matter.</p>
</blockquote>
<p>And here's the <code>tsort</code> output:</p>
<pre><code class="language-sh">$ tsort &lt; people.txt
Bella
Miranda
Zoe
Angela
Jane
Ellen
</code></pre>
<p>The first 3 elements are the ones with no incoming edge, the Software Engineers, since no one reports to them. Then come their respective managers, Angela and Jane. Finally comes their manager, <code>Ellen</code>.</p>
<p>So to insert all those people in our <code>people</code> SQL table, we go through that list in reverse order: We can first insert <code>Ellen</code>, then <code>Jane</code>, etc, until we finally insert <code>Bella</code>.</p>
<p>Also, <code>tsort</code> detects cycles, for example if we add the line: <code>Ellen Zoe</code> at the end of <code>people.txt</code>, we get:</p>
<pre><code class="language-sh">$ tsort &lt; people.txt
Bella
Miranda
tsort: -: input contains a loop:
tsort: Jane
tsort: Ellen
tsort: Zoe
Jane
tsort: -: input contains a loop:
tsort: Angela
tsort: Ellen
tsort: Zoe
Angela
Ellen
Zoe
</code></pre>
<p>So, how can we implement something like <code>tsort</code> for our problem at hand? That's where <a href="https://en.wikipedia.org/wiki/Topological_sorting#Kahn&#x27;s_algorithm">Kahn's algorithm</a> comes in to do exactly that: find cycles in the graph and output a topological sort.</p>
<p><em>Note that that's not the only solution and there are ways to detect cycles without creating a topological sort, but this algorithm seems relatively unknown and does not come up often on the Internet, so let's discover how it works and implement it. I promise, it's not complex.</em></p>
<h2>How to store the graph in memory</h2>
<p>There are many ways to do so, and Kahn's algorithm does not dictate which one to use.</p>
<p>We'll use an <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a>, because it's simple conceptually, maps well to Kahn's algorithm, and can be optimized if needed.</p>
<p>It's just a 2D square table of size <code>n x n</code> (where <code>n</code> is the number of nodes), where the cell at row <code>i</code> and column <code>j</code> is 1 if there is an edge from the node <code>i</code> to the node <code>j</code>, and otherwise, <code>0</code>.</p>
<p>The order of the nodes is arbitrary, I'll use the alphabetical order because again, it's simple to do:</p>
<pre><code>Angela
Bella
Ellen
Jane
Miranda
Zoe
</code></pre>
<p>Here, <code>Angela</code> is the node <code>0</code> and <code>Zoe</code> is the node <code>5</code>.</p>
<p>Since there is an edge from <code>Zoe</code> to <code>Angela</code>, i.e. from the node <code>5</code> to the node <code>0</code>, the cell at the position <code>(5, 0)</code> is set to <code>1</code>.</p>
<p>The full adjacency matrix for the employee graph in the example above looks like:</p>
<table>
  <tbody>
    <tr> <th></th>        <th>Angela</th>  <th>Bella</th>  <th>Ellen</th> <th>Jane</th>  <th>Miranda</th> <th>Zoe</th>  </tr>
    <tr> <td>Angela</td>  <td>0</td>       <td>0</td>      <td>1</td>     <td>0</td>     <td>0</td>       <td>0</td>    </tr>
    <tr> <td>Bella</td>   <td>1</td>       <td>0</td>      <td>0</td>     <td>0</td>     <td>0</td>       <td>0</td>    </tr>
    <tr> <td>Ellen</td>   <td>0</td>       <td>0</td>      <td>0</td>     <td>0</td>     <td>0</td>       <td>0</td>    </tr>
    <tr> <td>Jane</td>    <td>0</td>       <td>0</td>      <td>1</td>     <td>0</td>     <td>0</td>       <td>0</td>    </tr>
    <tr> <td>Miranda</td> <td>1</td>       <td>0</td>      <td>0</td>     <td>0</td>     <td>0</td>       <td>0</td>    </tr>
    <tr> <td>Zoe</td>     <td>1</td>       <td>0</td>      <td>0</td>     <td>1</td>     <td>0</td>       <td>0</td>    </tr>
  </tbody>
</table>
<p>The way to read this table is:</p>
<ul>
<li>For a given row, all the <code>1</code>'s indicate outgoing edges</li>
<li>For a given column, all the <code>1</code>'s indicate incoming edges</li>
<li>If there is a <code>1</code> on the diagonal, it means there is an edge going out of a node and going to the same node.</li>
</ul>
<p>There are a lot of zeroes in this table. Some may think this is horribly inefficient, which it is, but it really depends on number of nodes, i.e. the number of employees in the organization.
But note that this adjacency matrix is a concept, it shows what information is present, but not how it is stored.</p>
<p>For this article, we will store it the naive way, in a 2D array. Here are two optimization ideas I considered but have not had time to experiment with:</p>
<ul>
<li>Make this a bitarray. We are already only storing zeroes and ones, so it maps perfectly to this format.</li>
<li>Since there are a ton of zeroes (in the valid case, a regular employee's row only has one <code>1</code> and the CEO's row is only zeroes), it is very compressible. An easy way would be to use run-length encoding, meaning, instead of <code>0 0 0 0</code>, we just store the number of times the number occurs: <code>4 0</code>. Easy to implement, easy to understand. A row compresses to just a few bytes. And this size would be constant, whatever the size of the organization (i.e. number of employees) is.</li>
</ul>
<p>Wikipedia lists others if you are interested, it's a well-known problem.</p>
<p>Alright, now that we know how our graph is represented, on to the algorithm.</p>
<h2>Kahn's algorithm</h2>
<p><a href="https://en.wikipedia.org/wiki/Topological_sorting#Kahn&#x27;s_algorithm">Kahn's algorithm</a> keeps track of nodes with no incoming edge, and mutates the graph (in our case the adjacency matrix), by removing one edge at a time, until there are no more edges, and builds a list of nodes in the right order, which is the output.</p>
<p>Here's the pseudo-code:</p>
<pre><code> 1│ L ← Empty list that will contain the sorted elements
 2│ S ← Set of all nodes with no incoming edge
 3│ 
 4│ while S is not empty do
 5│     remove a node n from S
 6│     add n to L
 7│     for each node m with an edge e from n to m do
 8│         remove edge e from the graph
 9│         if m has no other incoming edges then
10│             insert m into S
11│ 
12│ if graph has edges then
13│     return error   (graph has at least one cycle)
14│ else 
15│     return L   (a topologically sorted order)
</code></pre>
<p>And in plain English:</p>
<p><code>Line 1</code>: The result of this algorithm is the list of nodes in the desired order (topological). It starts empty, and we add nodes one-by one during the algorithm. We can simply use an array in our implementation.</p>
<p><code>Line 2</code>: We first collect all nodes with no incoming edge. In terms of adjacency matrix, it means picking columns with only zeroes. The algorithm calls it a set, but we are free in our implementation to use whatever data structure we see fit. It just means a given node appears at most once in it. In our example, this set is: <code>[Zoe, Bella, Miranda]</code>. During the algorithm course, we will add further nodes to this set. Note that this is a working set, not the final result. Also, the order does not matter.</p>
<p><code>Line 4</code>: Self-explanatory, we continue until the working set is empty and there is no more work to do.</p>
<p><code>Line 5</code>: We first pick a node with no incoming edge (it does not matter which one). For example, <code>Zoe</code>, and remove it from <code>S</code>. <code>S</code> is now: <code>[Bella, Miranda]</code>.</p>
<p><code>Line 6</code>: We add this node to the list of topologically sorted nodes, <code>L</code>. It now is: <code>[Zoe]</code>.</p>
<p><code>Line 7</code>: We then inspect each node that <code>Zoe</code> has an edge to. That means <code>Jane</code> and <code>Angela</code>. In terms of adjacency matrix, we simply read <code>Zoe's</code> row, and inspect cells with a <code>1</code> in it.</p>
<p><code>Line 8</code>: We remove such an edge, for example, <code>Zoe -&gt; Jane</code>. In terms of adjacency matrix, it means setting the cell on the row <code>Zoe</code> and column <code>Jane</code> to <code>0</code>.</p>
<p>At this point, the graph looks like this:</p>
<p><img src="kahns_algorithm_2.svg" alt="Employee hierarchy" /></p>
<p><code>Line 9</code>: If <code>Jane</code> does not have another incoming edge, we add it to the set of all nodes with no incoming edge. That's the case here, so <code>S</code> now looks like: <code>[Bella, Miranda, Jane]</code>.</p>
<p>We know loop to <code>Line 7</code> and handle the node <code>Angela</code> since <code>Jane</code> is taken care of.</p>
<p><code>Line 7-10</code>: We are now handling the node <code>Angela</code>. We remove the edge <code>Zoe -&gt; Angela</code>. We check whether the node <code>Angela</code> has incoming edges. It does, so we do <strong>not</strong> add it to <code>S</code>.</p>
<p>The graph is now:</p>
<p><img src="kahns_algorithm_2_1.svg" alt="Employee hierarchy" /></p>
<p>We are now done with the <code>Line 7</code> for loop, so go back to <code>Line 5</code> and pick this time <code>Bella</code>. And so on.</p>
<p>The graph would now, to the algorithm, look like:</p>
<p><img src="kahns_algorithm_2_2.svg" alt="Employee hierarchy" /></p>
<hr />
<p>And here are the next steps in images:</p>
<ol>
<li><img src="kahns_algorithm_2_3.svg" alt="Employee hierarchy" /></li>
<li><img src="kahns_algorithm_2_4.svg" alt="Employee hierarchy" /></li>
<li><img src="kahns_algorithm_2_5.svg" alt="Employee hierarchy" /></li>
<li><img src="kahns_algorithm_2_6.svg" alt="Employee hierarchy" /></li>
<li><img src="kahns_algorithm_2_7.svg" alt="Employee hierarchy" /></li>
<li><img src="kahns_algorithm_2_8.svg" alt="Employee hierarchy" /></li>
<li><img src="kahns_algorithm_2_9.svg" alt="Employee hierarchy" /></li>
</ol>
<hr />
<p><code>Line 12-15</code>: Once the loop at <code>Line 4</code> is finished, we inspect our graph. If there are no more edges, we are done. If there is still an edge, it means there was a cycle in the graph, and we return an error.
Note that this algorithm is not capable by itself to point out which cycle there was exactly, only that there was one. That's because we mutated the graph by removing edges. If this information was important, we could keep track of which edges we removed in order, and re-add them back, or perhaps apply the algorithm to a copy of the graph (the adjacency matrix is trivial to clone).</p>
<p>This algorithm is loose concerning the order of some operations, for example, picking a node with no incoming edge, or in which order the nodes in <code>S</code> are stored. That gives room for an implementation to use certain data structures or orders that are faster, but in some cases we want the order to be always the same to solve ties in the stable way and to be reproducible. In order to do that, we simply use the alphabetical order. So in our example above, at <code>Line 5</code>, we picked <code>Zoe</code> out of <code>[Zoe, Bella, Miranda]</code>. Using this method, we would keep the working set <code>S</code> sorted alphabetically and pick <code>Bella</code> out of <code>[Bella, Miranda, Zoe]</code>.</p>
<h2>Implementation</h2>
<p>I implemented this at the time in Go, but I will use for this article the lingua franca of the 2010s, Javascript.</p>
<p><em>I don't write Javascript these days, I stopped many years ago, so apologies in advance if I am not using all the bells and whistles of 'Modern Javascript', or if the code is not quite idiomatic.</em></p>
<p>First, we define our adjacency matrix and the list of nodes. This is the naive format. We would get the nodes and edges in some format, for example JSON, in the API, and build the adjacency matrix, which is trivial. Let's take the very first example, the (valid) tree  of employees:</p>
<pre><code class="language-js">const adjacencyMatrix = [
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0],
];

const nodes = [&quot;Angela&quot;, &quot;Bella&quot;, &quot;Ellen&quot;, &quot;Jane&quot;, &quot;Miranda&quot;, &quot;Zoe&quot;];
</code></pre>
<h3>Helpers</h3>
<p>We need a helper function to check if a node has no incoming edge (<code>Line 9</code> in the algorithm):</p>
<pre><code class="language-js">function hasNodeNoIncomingEdge(adjacencyMatrix, nodeIndex) {
  const column = nodeIndex;

  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    const cell = adjacencyMatrix[row][column];
    if (cell != 0) {
      return false;
    }
  }

  return true;
}
</code></pre>
<p>Then, using this helper, we can define a second helper to initially collect all the nodes with no incoming edge (<code>Line 2</code> in the algorithm):</p>
<pre><code class="language-js">function getNodesWithNoIncomingEdge(adjacencyMatrix, nodes) {
  return nodes.filter((_, i) =&gt; hasNodeNoIncomingEdge(adjacencyMatrix, i));
}
</code></pre>
<p>We can try it:</p>
<pre><code class="language-js">console.log(getNodesWithNoIncomingEdge(adjacencyMatrix, nodes));
</code></pre>
<p>And it outputs:</p>
<pre><code class="language-js">[ 'Bella', 'Miranda', 'Zoe' ]
</code></pre>
<p>We need one final helper, to determine if the graph has edges (<code>Line 12</code>), which is straightforward:</p>
<pre><code class="language-js">function graphHasEdges(adjacencyMatrix) {
  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    for (let column = 0; column &lt; adjacencyMatrix.length; column += 1) {
      if (adjacencyMatrix[row][column] == 1) return true;
    }
  }

  return false;
}
</code></pre>
<h3>The algorithm</h3>
<p>We are finally ready to implement the algorithm. It's a straightforward, line by line, translation of the pseudo-code:</p>
<pre><code class="language-js">function topologicalSort(adjacencyMatrix) {
  const L = [];
  const S = getNodesWithNoIncomingEdge(adjacencyMatrix, nodes);

  while (S.length &gt; 0) {
    const node = S.pop();
    L.push(node);
    const nodeIndex = nodes.indexOf(node);

    for (let mIndex = 0; mIndex &lt; nodes.length; mIndex += 1) {
      const hasEdgeFromNtoM = adjacencyMatrix[nodeIndex][mIndex];
      if (!hasEdgeFromNtoM) continue;

      adjacencyMatrix[nodeIndex][mIndex] = 0;

      if (hasNodeNoIncomingEdge(adjacencyMatrix, mIndex)) {
        const m = nodes[mIndex];
        S.push(m);
      }
    }
  }

  if (graphHasEdges(adjacencyMatrix)) {
    throw new Error(&quot;Graph has at least one cycle&quot;);
  }

  return L;
}
</code></pre>
<p>Let's try it:</p>
<pre><code class="language-js">console.log(topologicalSort(adjacencyMatrix, nodes));
</code></pre>
<p>We get:</p>
<pre><code class="language-js">[ 'Zoe', 'Jane', 'Miranda', 'Bella', 'Angela', 'Ellen' ]
</code></pre>
<p>Interestingly, it is not the same order as <code>tsort</code>, but it is indeed a valid topological ordering. That's because there are ties between some nodes and we do not resolve those ties the exact same way <code>tsort</code> does.</p>
<p>But in our specific case, we just want a valid insertion order in the database, and so this is enough.</p>
<h3>Inserting entries in the database</h3>
<p>Now, we can produce the SQL code to insert our entries. We operate on a clone of the adjacency matrix for convenience because we later need to know what is the outgoing edge for a given node.</p>
<p>We handle the special case of the root first, which is the last element, and then we go through the topologically sorted list of employees in reverse order, and insert each one. We use a one liner to get the manager id by name when inserting to avoid many round trips to the database:</p>
<pre><code class="language-js">const employeesTopologicallySorted = topologicalSort(structuredClone(adjacencyMatrix), nodes)

const root = employeesTopologicallySorted[employeesTopologicallySorted.length - 1];
console.log(`INSERT INTO people VALUES(&quot;${root}&quot;, NULL)`);

for (let i = employeesTopologicallySorted.length - 2; i &gt;= 0; i -= 1) {
  const employee = employeesTopologicallySorted[i];
  const employeeIndex = nodes.indexOf(employee);

  const managerIndex = adjacencyMatrix[employeeIndex].indexOf(1);
  const manager = nodes[managerIndex];
  console.log(
    `INSERT INTO people SELECT &quot;${employee}&quot;, rowid FROM people WHERE name = &quot;${manager}&quot; LIMIT 1;`,
  );
}
</code></pre>
<p>Which outputs:</p>
<pre><code class="language-sql">INSERT INTO people VALUES(&quot;Ellen&quot;, NULL);
INSERT INTO people SELECT &quot;Angela&quot;, rowid FROM people WHERE name = &quot;Ellen&quot; LIMIT 1;
INSERT INTO people SELECT &quot;Bella&quot;, rowid FROM people WHERE name = &quot;Angela&quot; LIMIT 1;
INSERT INTO people SELECT &quot;Miranda&quot;, rowid FROM people WHERE name = &quot;Angela&quot; LIMIT 1;
INSERT INTO people SELECT &quot;Jane&quot;, rowid FROM people WHERE name = &quot;Ellen&quot; LIMIT 1;
INSERT INTO people SELECT &quot;Zoe&quot;, rowid FROM people WHERE name = &quot;Jane&quot; LIMIT 1;
</code></pre>
<h3>Detecting cycles</h3>
<p>As we said earlier, we get that for free, so let's check our implementation against this invalid example:</p>
<p><img src="kahns_algorithm_4.svg" alt="Employee hierarchy with cycle" /></p>
<p>We add the edge <code>Ellen -&gt; Zoe</code> to create a cycle:</p>
<pre><code class="language-js">const adjacencyMatrix = [
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1], // =&gt; We change the last element of this row (Ellen's row, Zoe's column) from 0 to 1.
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0],
];

const nodes = [&quot;Angela&quot;, &quot;Bella&quot;, &quot;Ellen&quot;, &quot;Jane&quot;, &quot;Miranda&quot;, &quot;Zoe&quot;];

const employeesTopologicallySorted = topologicalSort(structuredClone(adjacencyMatrix), nodes);
</code></pre>
<p>And we get an error as expected:</p>
<pre><code class="language-sh">/home/pg/my-code/blog/kahns_algorithm.js:63
    throw new Error(&quot;Graph has at least one cycle&quot;);
    ^

Error: Graph has at least one cycle
</code></pre>
<h3>Detecting multiple roots</h3>
<p>One thing that topological sorting does not do for us is to detect the case of multiple roots in the graph, for example:</p>
<p><img src="kahns_algorithm_3.svg" alt="Employee hierarchy with multiple roots" /></p>
<p>To do this, we simply scan the adjacency matrix and verify that there is only one row with only zeroes, that is, only one node that has no outgoing edges:</p>
<pre><code class="language-js">function hasMultipleRoots(adjacencyMatrix) {
  let countOfRowsWithOnlyZeroes = 0;

  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    let rowHasOnlyZeroes = true;
    for (let column = 0; column &lt; adjacencyMatrix.length; column += 1) {
      if (adjacencyMatrix[row][column] != 0) {
        rowHasOnlyZeroes = false;
        break;
      }
    }
    if (rowHasOnlyZeroes) countOfRowsWithOnlyZeroes += 1;
  }

  return countOfRowsWithOnlyZeroes &gt; 1;
}
</code></pre>
<p>Let's try it with our invalid example from above:</p>
<pre><code class="language-js">const adjacencyMatrix = [
  [0, 0, 1, 0, 0, 0, 0],
  [1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 0, 0],
  [1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
];

const nodes = [&quot;Angela&quot;, &quot;Bella&quot;, &quot;Ellen&quot;, &quot;Jane&quot;, &quot;Miranda&quot;, &quot;Zoe&quot;, &quot;Kelly&quot;];


console.log(hasMultipleRoots(adjacencyMatrix));
</code></pre>
<p>And we get: <code>true</code>. With our previous (valid) example, we get: <code>false</code>.</p>
<h2>Playing with the database</h2>
<p>We can query each employee along with their manager name so:</p>
<pre><code class="language-sql">SELECT a.name as employee_name, COALESCE(b.name, '') as manager_name FROM people a LEFT JOIN people b ON a.manager = b.rowid;
</code></pre>
<p>To query the manager (N+1) and the manager's manager (N+2) of an employee:</p>
<pre><code class="language-sql">SELECT COALESCE(n_plus_1.name, ''), COALESCE(n_plus_2.name, '')
FROM people employee
LEFT JOIN people n_plus_1 ON employee.manager = n_plus_1.rowid
LEFT JOIN people n_plus_2 ON n_plus_1.manager = n_plus_2.rowid
WHERE employee.name = ?
</code></pre>
<p>We can also do this with hairy recursive Common Table Expression (CTE) but I'll leave that to the reader.</p>
<h2>Closing thoughts</h2>
<p>Graphs and algorithms operating on them do not have to be complicated. Using an adjacency matrix and Kahn's algorithm, we can achieve a lot with little and it remains simple.</p>
<p>There are many ways to optimize the code in this article; the point was not to write the most efficient code, but to showcase in the clearest, simplest way possible to detect cycles and store a graph/tree in memory and in a database.</p>
<p>If you want to play with the code here and try to make it faster, go at it!</p>
<blockquote>
<p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&amp;locale.x=en_US">Donate</a></p>
</blockquote>
<h2>Addendum: the full code</h2>
<pre><code class="language-js">const adjacencyMatrix = [
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0],
];

const nodes = [&quot;Angela&quot;, &quot;Bella&quot;, &quot;Ellen&quot;, &quot;Jane&quot;, &quot;Miranda&quot;, &quot;Zoe&quot;];

function hasNodeNoIncomingEdge(adjacencyMatrix, nodeIndex) {
  const column = nodeIndex;

  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    const cell = adjacencyMatrix[row][column];

    if (cell != 0) {
      return false;
    }
  }

  return true;
}

function getNodesWithNoIncomingEdge(adjacencyMatrix, nodes) {
  return nodes.filter((_, i) =&gt; hasNodeNoIncomingEdge(adjacencyMatrix, i));
}

function graphHasEdges(adjacencyMatrix) {
  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    for (let column = 0; column &lt; adjacencyMatrix.length; column += 1) {
      if (adjacencyMatrix[row][column] == 1) return true;
    }
  }

  return false;
}

function topologicalSort(adjacencyMatrix) {
  const L = [];
  const S = getNodesWithNoIncomingEdge(adjacencyMatrix, nodes);

  while (S.length &gt; 0) {
    const node = S.pop();
    L.push(node);
    const nodeIndex = nodes.indexOf(node);

    for (let mIndex = 0; mIndex &lt; nodes.length; mIndex += 1) {
      const hasEdgeFromNtoM = adjacencyMatrix[nodeIndex][mIndex];
      if (!hasEdgeFromNtoM) continue;

      adjacencyMatrix[nodeIndex][mIndex] = 0;

      if (hasNodeNoIncomingEdge(adjacencyMatrix, mIndex)) {
        const m = nodes[mIndex];
        S.push(m);
      }
    }
  }

  if (graphHasEdges(adjacencyMatrix)) {
    throw new Error(&quot;Graph has at least one cycle&quot;);
  }

  return L;
}

function hasMultipleRoots(adjacencyMatrix) {
  let countOfRowsWithOnlyZeroes = 0;

  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    let rowHasOnlyZeroes = true;
    for (let column = 0; column &lt; adjacencyMatrix.length; column += 1) {
      if (adjacencyMatrix[row][column] != 0) {
        rowHasOnlyZeroes = false;
        break;
      }
    }
    if (rowHasOnlyZeroes) countOfRowsWithOnlyZeroes += 1;
  }

  return countOfRowsWithOnlyZeroes &gt; 1;
}

console.log(hasMultipleRoots(adjacencyMatrix));
const employeesTopologicallySorted = topologicalSort(structuredClone(adjacencyMatrix), nodes);
console.log(employeesTopologicallySorted);

const root = employeesTopologicallySorted[employeesTopologicallySorted.length - 1];
console.log(`INSERT INTO people VALUES(&quot;${root}&quot;, NULL)`);

for (let i = employeesTopologicallySorted.length - 2; i &gt;= 0; i -= 1) {
  const employee = employeesTopologicallySorted[i];
  const employeeIndex = nodes.indexOf(employee);

  const managerIndex = adjacencyMatrix[employeeIndex].indexOf(1);
  const manager = nodes[managerIndex];
  console.log(
    `INSERT INTO people SELECT &quot;${employee}&quot;, rowid FROM people WHERE name = &quot;${manager}&quot; LIMIT 1;`,
  );
}
</code></pre>
</div>

]]>
    </content>
     </entry>

     <entry>
       <title>Roll your own memory profiling: it's actually not hard</title>
       <link href="/blog/roll_your_own_memory_profiling.html"/>
       <id>urn:uuid:5344c109-864c-5db2-97a9-24834e053169</id>
       <updated>2023-12-15T11:33:55Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/highlight.min.js"></script>
<script>
window.addEventListener("load", (event) => {
  hljs.highlightAll();
});
</script>
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>Roll your own memory profiling: it's actually not hard</h1>
<p><em>Or: An exploration of the <a href="https://github.com/gperftools/gperftools">pprof</a> memory profiler and its textual format for fun an profit.</em></p>
<p>Say that you are using a programming language where memory is manually managed, and you have decided to use a custom allocator for one reason or another, for example an arena allocator, and are wondering:</p>
<ul>
<li>How do I track every allocation, recording how many bytes were allocated and what was the call stack at that time?</li>
<li>How much memory is my program using, and what is the peak use?</li>
<li>How much memory does my program free? Is it all of it (are there leaks)?</li>
<li>Which line of code in my function is allocating, and how much?</li>
<li>I want a flamegraph showing allocations by function</li>
</ul>
<p>What to do? Mainstream allocators such as <code>tcmalloc</code> and <code>jemalloc</code> can provide us this information but we have lost this ability by using our own!</p>
<p>Well, it turns out that this can all be achieved very simply without adding dependencies to your application, in ~100 lines of code (including lots of comments). I'll show one way and then explore other possibilities. And here are the results we are working towards:</p>
<p><img src="mem_prof1.png" alt="1" />
<em>Profiling the memory usage of my <a href="https://github.com/gaultier/micro-kotlin">micro-kotlin</a> project.</em></p>
<p><img src="mem_prof2.png" alt="2" />
<em>Showing which lines of code are allocating in a function.</em></p>
<p><img src="mem_prof3.png" alt="3" />
<em>A flamegraph based on the previous data.</em></p>
<p>The only requirement to make it all work is to be able to run a bit of code on each allocation.</p>
<p>Another good reason to do this, is when the system's <code>malloc</code> comes with some form of memory profiling which is not suitable for your needs and you want something different/better/the same on every platform.</p>
<blockquote>
<p>If you spot an error, please open a <a href="https://github.com/gaultier/blog">Github issue</a>!</p>
</blockquote>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#roll-your-own-memory-profiling-its-actually-not-hard">Roll your own memory profiling: it's actually not
hard</a>
<ul>
<li><a href="#pprof">Pprof</a></li>
<li><a href="#the-text-format">The text format</a></li>
<li><a href="#generating-a-pprof-profile">Generating a <code>pprof</code> profile</a></li>
<li><a href="#variations-and-limitations">Variations and limitations</a></li>
<li><a href="#alternatives">Alternatives</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#addendum-the-full-code">Addendum: the full code</a></li>
</ul>
</li>
</ul>
<h2>Pprof</h2>
<p>Here is the plan:</p>
<ol>
<li>Each time there is an allocation in our program, we record information about it in an array.</li>
<li>At the end of the program (or upon receiving a signal, a special TCP packet, whatever), we dump the information in the (original) <a href="https://github.com/gperftools/gperftools">pprof</a> format, which is basically just a text file with one line per allocation (more details on that in a bit).</li>
<li>We can then use the (original) <code>pprof</code> which is just a <a href="https://github.com/gperftools/gperftools/blob/master/src/pprof">giant Perl script</a> which will extract interesting information and most importantly symbolize (meaning: transform memory addresses into line/column/function/file information).</li>
</ol>
<p>I will showcase this approach with C code using an arena allocator. The full code can be found in my project <a href="https://github.com/gaultier/micro-kotlin/blob/pprof-original/str.h#L320">micro-kotlin</a>. But this can be done in any language since the <code>pprof</code> text format is so simple! Also, using arenas, we do not bother to free anything so the memory profiling part is even simpler.</p>
<blockquote>
<p>The original <code>pprof</code> written in Perl is not to be confused with the rewritten <a href="https://github.com/google/pprof">pprof</a> in Go which offers a superset of the features of the original but based on a completely different and incompatible file format (protobuf)!</p>
</blockquote>
<h2>The text format</h2>
<p>Here is the text format we want to generate:</p>
<pre><code>heap profile:    &lt;in use objects sum&gt;:  &lt;in use bytes sum&gt; [   &lt;space objects sum&gt;:  &lt;space bytes sum&gt;] @ heapprofile
&lt;in use objects&gt;: &lt;in use bytes&gt; [&lt;space objects&gt;: &lt;space bytes&gt;] @ &lt;rip1&gt; &lt;rip2&gt; &lt;rip3&gt; [...]
&lt;in use objects&gt;: &lt;in use bytes&gt; [&lt;space objects&gt;: &lt;space bytes&gt;] @ &lt;rip1&gt; &lt;rip2&gt; &lt;rip3&gt; [...]
&lt;in use objects&gt;: &lt;in use bytes&gt; [&lt;space objects&gt;: &lt;space bytes&gt;] @ &lt;rip1&gt; &lt;rip2&gt; &lt;rip3&gt; [...]
                                                                             
MAPPED_LIBRARIES:
[...]

</code></pre>
<p>The first line is a header identifying that this is a heap profile (contrary to a CPU profile which <code>pprof</code> can also analyze, which uses a different, binary, format) and gives for each of the four fields we will record, their sum.</p>
<p>Then comes one line per entry. Each entry has these four fields that the header just gave us a sum of:</p>
<ul>
<li><code>in use objects</code>: How many objects are 'live' i.e. in use on the heap at the time of the allocation. Allocating increases its value, freeing decreases it.</li>
<li><code>in use bytes</code>: How many bytes are 'live' i.e. in use on the heap at the time of the allocation. Allocating increases its value, freeing decreases it.</li>
<li><code>space objects</code>: How many objects have been allocated since the start of the program. It is not affected by freeing memory, it only increases.</li>
<li><code>space bytes</code>: How many bytes have been allocated since the start of the program. It is not affected by freeing memory, it only increases.</li>
</ul>
<p>So when we allocate an object e.g. <code>new(Foo)</code> in C++:</p>
<ul>
<li><code>in use objects</code> and <code>space objects</code> increment by 1</li>
<li><code>in use bytes</code> and <code>space bytes</code> increment by <code>sizeof(Foo)</code></li>
</ul>
<p>When we allocate an array of N elements of type <code>Foo</code>:</p>
<ul>
<li><code>in use objects</code> and <code>space objects</code> increment by N</li>
<li><code>in use bytes</code> and <code>space bytes</code> increment by <code>N * sizeof(Foo)</code></li>
</ul>
<p>When we free an object:</p>
<ul>
<li><code>in use objects</code> decrements by 1</li>
<li><code>in use bytes</code> decrements by <code>sizeof(Foo)</code></li>
</ul>
<p>When we free an array of N elements of type <code>Foo</code>:</p>
<ul>
<li><code>in use objects</code> decrements by N</li>
<li><code>in use bytes</code> decrements by <code>N * sizeof(Foo)</code></li>
</ul>
<p>These 4 dimensions are really useful to spot memory leaks (<code>in use objects</code> and <code>in use bytes</code> increase over time), peak memory usage (<code>space bytes</code>), whether we are doing many small allocations versus a few big allocations, etc.
<code>pprof</code> also supports sampling and we could supply a sampling rate here optionally but we want to track each and every allocation so we do not bother with that.</p>
<p>Each entry (i.e. line) ends with the call stack which is a space-separated list of addresses. We'll see that it is easy to get that information without resorting to external libraries such as <code>libunwind</code> by simply walking the stack, a topic I touched on in a previous <a href="/blog/x11_x64.html#a-stack-primer">article</a>.</p>
<p>Very importantly, multiple allocation records with the same stack must be merged together into one, summing their values. In that sense, each line conceptually an entry in a hashmap where the key is the call stack (the part of the right of the <code>@</code> character) and the value is a 4-tuple: <code>(u64, u64, u64, u64)</code> (the part on the left of the <code>@</code> character).</p>
<p>The text file ends with a trailer which is crucial for symbolication (to transform memory addresses into source code locations), which on Linux is trivial to get: This is just a copy of the file <code>/proc/self/maps</code>. It lists of the loaded libraries and at which address they are.</p>
<p>I have not implemented it myself but a quick internet search shows that the other major operating systems have a similar capability, named differently:</p>
<ul>
<li>Windows: <code>VirtualQuery</code></li>
<li>macOS: <code>mach_vm_region_info</code></li>
<li>FreeBSD: <code>procstat_getvmmap</code></li>
</ul>
<p>Here is a small example:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

void b(int n) { malloc(n); }

void a(int n) {
  malloc(n);
  b(n);
}

int main() {
  for (int i = 0; i &lt; 2; i++)
    a(2);

  b(3);
}
</code></pre>
<p>Leveraging <code>tcmalloc</code>, this program will generate a heap profile:</p>
<pre><code class="language-sh">$ cc /tmp/test_alloc.c -ltcmalloc  -g3
$ HEAPPROFILE=/tmp/heapprof ./a.out
Starting tracking the heap
Dumping heap profile to /tmp/heapprof.0001.heap (Exiting, 11 bytes in use)
</code></pre>
<p><em>This is just an example to showcase the format, we will from this point on use our own code to generate this text format.</em></p>
<pre><code>heap profile:      5:       11 [     5:       11] @ heapprofile
     2:        4 [     2:        4] @ 0x558e804cc165 0x558e804cc18e 0x558e804cc1b0 0x7f452a4daa90 0x7f452a4dab49 0x558e804cc085
     2:        4 [     2:        4] @ 0x558e804cc184 0x558e804cc1b0 0x7f452a4daa90 0x7f452a4dab49 0x558e804cc085
     1:        3 [     1:        3] @ 0x558e804cc165 0x558e804cc1c4 0x7f452a4daa90 0x7f452a4dab49 0x558e804cc085

MAPPED_LIBRARIES:
558e804cb000-558e804cc000 r--p 00000000 00:00 183128      /tmp/a.out
558e804cc000-558e804cd000 r-xp 00001000 00:00 183128      /tmp/a.out
558e804cd000-558e804ce000 r--p 00002000 00:00 183128      /tmp/a.out
558e804ce000-558e804cf000 r--p 00002000 00:00 183128      /tmp/a.out
558e804cf000-558e804d0000 rw-p 00003000 00:00 183128      /tmp/a.out
558e814b7000-558e81db8000 rw-p 00000000 00:00 0           [heap]
7f4529e7e000-7f452a112000 rw-p 00000000 00:00 0           
7f452a112000-7f452a115000 r--p 00000000 00:00 678524      /usr/lib/x86_64-linux-gnu/liblzma.so.5.4.1
7f452a115000-7f452a136000 r-xp 00003000 00:00 678524      /usr/lib/x86_64-linux-gnu/liblzma.so.5.4.1
7f452a136000-7f452a142000 r--p 00024000 00:00 678524      /usr/lib/x86_64-linux-gnu/liblzma.so.5.4.1
7f452a142000-7f452a143000 r--p 00030000 00:00 678524      /usr/lib/x86_64-linux-gnu/liblzma.so.5.4.1
7f452a143000-7f452a144000 rw-p 00031000 00:00 678524      /usr/lib/x86_64-linux-gnu/liblzma.so.5.4.1
7f452a144000-7f452a152000 r--p 00000000 00:00 668348      /usr/lib/x86_64-linux-gnu/libm.so.6
7f452a152000-7f452a1d0000 r-xp 0000e000 00:00 668348      /usr/lib/x86_64-linux-gnu/libm.so.6
7f452a1d0000-7f452a22b000 r--p 0008c000 00:00 668348      /usr/lib/x86_64-linux-gnu/libm.so.6
7f452a22b000-7f452a22c000 r--p 000e6000 00:00 668348      /usr/lib/x86_64-linux-gnu/libm.so.6
7f452a22c000-7f452a22d000 rw-p 000e7000 00:00 668348      /usr/lib/x86_64-linux-gnu/libm.so.6
7f452a22d000-7f452a22f000 rw-p 00000000 00:00 0           
7f452a22f000-7f452a2cb000 r--p 00000000 00:00 678806      /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.32
7f452a2cb000-7f452a3fc000 r-xp 0009c000 00:00 678806      /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.32
7f452a3fc000-7f452a489000 r--p 001cd000 00:00 678806      /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.32
7f452a489000-7f452a494000 r--p 0025a000 00:00 678806      /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.32
7f452a494000-7f452a497000 rw-p 00265000 00:00 678806      /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.32
7f452a497000-7f452a49b000 rw-p 00000000 00:00 0           
7f452a49b000-7f452a49e000 r--p 00000000 00:00 702044      /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1
7f452a49e000-7f452a4a8000 r-xp 00003000 00:00 702044      /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1
7f452a4a8000-7f452a4ab000 r--p 0000d000 00:00 702044      /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1
7f452a4ab000-7f452a4ac000 r--p 0000f000 00:00 702044      /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1
7f452a4ac000-7f452a4ad000 rw-p 00010000 00:00 702044      /usr/lib/x86_64-linux-gnu/libunwind.so.8.0.1
7f452a4ad000-7f452a4b7000 rw-p 00000000 00:00 0           
7f452a4b7000-7f452a4d9000 r--p 00000000 00:00 668342      /usr/lib/x86_64-linux-gnu/libc.so.6
7f452a4d9000-7f452a651000 r-xp 00022000 00:00 668342      /usr/lib/x86_64-linux-gnu/libc.so.6
7f452a651000-7f452a6a9000 r--p 0019a000 00:00 668342      /usr/lib/x86_64-linux-gnu/libc.so.6
7f452a6a9000-7f452a6ad000 r--p 001f1000 00:00 668342      /usr/lib/x86_64-linux-gnu/libc.so.6
7f452a6ad000-7f452a6af000 rw-p 001f5000 00:00 668342      /usr/lib/x86_64-linux-gnu/libc.so.6
7f452a6af000-7f452a6bc000 rw-p 00000000 00:00 0           
7f452a6bc000-7f452a6bf000 r--p 00000000 00:00 677590      /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
7f452a6bf000-7f452a6da000 r-xp 00003000 00:00 677590      /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
7f452a6da000-7f452a6de000 r--p 0001e000 00:00 677590      /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
7f452a6de000-7f452a6df000 r--p 00021000 00:00 677590      /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
7f452a6df000-7f452a6e0000 rw-p 00022000 00:00 677590      /usr/lib/x86_64-linux-gnu/libgcc_s.so.1
7f452a6e0000-7f452a6f3000 r--p 00000000 00:00 182678      /usr/lib/x86_64-linux-gnu/libtcmalloc.so.4.5.9
7f452a6f3000-7f452a719000 r-xp 00013000 00:00 182678      /usr/lib/x86_64-linux-gnu/libtcmalloc.so.4.5.9
7f452a719000-7f452a729000 r--p 00039000 00:00 182678      /usr/lib/x86_64-linux-gnu/libtcmalloc.so.4.5.9
7f452a729000-7f452a72a000 r--p 00048000 00:00 182678      /usr/lib/x86_64-linux-gnu/libtcmalloc.so.4.5.9
7f452a72a000-7f452a72b000 rw-p 00049000 00:00 182678      /usr/lib/x86_64-linux-gnu/libtcmalloc.so.4.5.9
7f452a72b000-7f452a8e1000 rw-p 00000000 00:00 0           
7f452a8e4000-7f452a8f8000 rw-p 00000000 00:00 0           
7f452a8f8000-7f452a8f9000 r--p 00000000 00:00 668336      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f452a8f9000-7f452a921000 r-xp 00001000 00:00 668336      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f452a921000-7f452a92b000 r--p 00029000 00:00 668336      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f452a92b000-7f452a92d000 r--p 00033000 00:00 668336      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f452a92d000-7f452a92f000 rw-p 00035000 00:00 668336      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fff91a4d000-7fff91a6e000 rw-p 00000000 00:00 0           [stack]
7fff91b3f000-7fff91b43000 r--p 00000000 00:00 0           [vvar]
7fff91b43000-7fff91b45000 r-xp 00000000 00:00 0           [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0           [vsyscall]
</code></pre>
<p>We see that at the end of the program, we have (looking at the first line):</p>
<ul>
<li>5 objects in use</li>
<li>11 bytes in use</li>
<li>5 objects allocated in total</li>
<li>11 bytes allocated in total</li>
</ul>
<p>Since we never freed any memory, the <code>in use</code> counters are the same as the <code>space</code> counters.</p>
<p>We have 3 unique call stacks that allocate, in the same order as they appear in the text file (although order does not matter for <code>pprof</code>):</p>
<ul>
<li><code>b</code> &lt;- <code>a</code> &lt;- <code>main</code></li>
<li><code>a</code> &lt;- <code>main</code></li>
<li><code>b</code> &lt;- <code>main</code></li>
</ul>
<p>Since our program is a Position Independant Executable (PIE), the loader picks a random address for where to load our program in virtual memory. Consequently, addresses collected from within our program have this offset added to them and this offset is different every run. Thankfully, the <code>MAPPED_LIBRARIES</code> section lists address ranges (the first column of each line in that section) for each library that gets loaded.</p>
<p>As such, <code>pprof</code> only needs to find for each address the relevant range, subtract the start of the range from this address, and it has the real address in our executable. It then runs <code>addr2line</code> or similar to get the code location.</p>
<p>Finally we can use <code>pprof</code> to extract human-readable information from this text file:</p>
<pre><code class="language-sh">$ pprof --text ./a.out ./heapprof.0001.heap
Using local file ./a.out.
Using local file /tmp/heapprof.0001.heap.
Total: 0.0 MB
     0.0  63.6%  63.6%      0.0  63.6% b
     0.0  36.4% 100.0%      0.0  72.7% a
     0.0   0.0% 100.0%      0.0 100.0% __libc_start_call_main
     0.0   0.0% 100.0%      0.0 100.0% __libc_start_main_impl
     0.0   0.0% 100.0%      0.0 100.0% _start
     0.0   0.0% 100.0%      0.0 100.0% main
</code></pre>
<h2>Generating a <code>pprof</code> profile</h2>
<p>Let's start with a very simple arena (directly based on <a href="https://nullprogram.com/blog/2023/09/27/">https://nullprogram.com/blog/2023/09/27/</a>) and show how it is used:</p>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;


typedef struct {
  u8 *start;
  u8 *end;
} arena_t;

static void * arena_alloc(arena_t *a, size_t size, size_t align, size_t count) {
  pg_assert(a-&gt;start &lt;= a-&gt;end);
  pg_assert(align == 1 || align == 2 || align == 4 || align == 8);

  size_t available = a-&gt;end - a-&gt;start;
  size_t padding = -(size_t)a-&gt;start &amp; (align - 1);

  size_t offset = padding + size * count;
  if (available &lt; offset) {
    fprintf(stderr,
            &quot;Out of memory: available=%lu &quot;
            &quot;allocation_size=%lu\n&quot;,
            available, offset);
    abort();
  }

  uint8_t *res = a-&gt;start + padding;

  a-&gt;start += offset;

  return (void *)res;
}
</code></pre>
<p>Now, we are ready to add memory profiling to our simple allocator.</p>
<p>First, we model a record with the 4 counters and the call stack:</p>
<pre><code class="language-c">typedef struct {
  uint64_t in_use_space, in_use_objects, alloc_space, alloc_objects;
  uint64_t *call_stack;
  uint64_t call_stack_len;
} mem_record_t;
</code></pre>
<p>Then, the profile, which contains the 4 counters as a sum and an array of records.</p>
<p>An arena now has an (optional) pointer to a memory profile:</p>
<pre><code class="language-c">typedef struct mem_profile_t mem_profile_t;
typedef struct {
  uint8_t *start;
  uint8_t *end;
  mem_profile_t* profile;
} arena_t;

struct mem_profile_t {
  mem_record_t *records;
  uint64_t records_len;
  uint64_t records_cap;
  uint64_t in_use_space, in_use_objects, alloc_space, alloc_objects;
  arena_t arena;
};
</code></pre>
<p>Note that the memory profile needs to allocate to store this metadata and as such needs an arena. Which makes these two structures cyclic!</p>
<p>The way we solve it is:</p>
<ol>
<li>We create an small arena dedicated to the memory profiling and this arena does <em>not</em> have a memory profile attached (otherwise we would end up in a infinite recursion, and we are not interested in profiling the memory usage of the memory profiler anyway; its memory usage is capped by the size of its dedicated arena).</li>
<li>We create the memory profile using this arena.</li>
<li>We create the main arena for our program to use and attach the profile to it.</li>
</ol>
<pre><code class="language-c">static arena_t arena_new(uint64_t cap, mem_profile_t *profile) {
  uint8_t *mem = mmap(NULL, cap, PROT_READ | PROT_WRITE,
                      MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);

  arena_t arena = {
      .profile = profile,
      .start = mem,
      .end = mem + cap,
  };
  return arena;
}

int main(){
  arena_t mem_profile_arena = arena_new(1 &lt;&lt; 16, NULL);
  mem_profile_t mem_profile = {.arena = mem_profile_arena};

  arena_t arena = arena_new(1 &lt;&lt; 22, &amp;mem_profile);
}
</code></pre>
<p>Now, in <code>arena_alloc</code>, if there is a non-NULL memory profile, we record the allocation just before returning the freshly allocated pointer:</p>
<pre><code class="language-c">static void *arena_alloc(arena_t *a, size_t size, size_t align, size_t count) {
  [...]

  if (a-&gt;profile) {
    mem_profile_record_alloc(a-&gt;profile, count, offset);
  }

  return (void *)res;
}
</code></pre>
<p>We now have to implement <code>mem_profile_record_alloc</code> and exporting the profile to the text format, and we are done.</p>
<p>When recording an allocation, we need to capture the call stack, so we walk the stack upwards until we reach a frame address that is 0 or does not have the alignement of a pointer (8); at which point we know not to dereference it and go further.</p>
<p>This will break if we disable frame pointers when compiling (<code>-fomit-frame-pointer</code>) which is in my opinion always a bad idea. There are other ways to get a call stack fortunately but they all are more involved and potentially slower. Note that this approach probably only works on x86_64, no idea how ARM does that. Here is a <a href="https://hacks.mozilla.org/2022/06/everything-is-broken-shipping-rust-minidump-at-mozilla/">deep dive</a> on getting a stack trace in different environments.</p>
<pre><code class="language-c">static uint8_t record_call_stack(uint64_t *dst, uint64_t cap) {
  uintptr_t *rbp = __builtin_frame_address(0);

  uint64_t len = 0;

  while (rbp != 0 &amp;&amp; ((uint64_t)rbp &amp; 7) == 0 &amp;&amp; *rbp != 0) {
    const uintptr_t rip = *(rbp + 1);
    rbp = (uintptr_t *)*rbp;

    // `rip` points to the return instruction in the caller, once this call is
    // done. But: We want the location of the call i.e. the `call xxx`
    // instruction, so we subtract one byte to point inside it, which is not
    // quite 'at' it, but good enough.
    dst[len++] = rip - 1;

    if (len &gt;= cap)
      return len;
  }
  return len;
}
</code></pre>
<p>Now we can record the allocation proper, upserting the new record into our existing list of records, trying to find an existing record with the same call stack.
That part is important to avoid having a huge profile and that's why <code>pprof</code> made this design decision.</p>
<p>The code is slightly length because we need to roll our own arrays here in this minimal example, but in a real application you'd have your own array structure and helper functions, most likely:</p>
<pre><code class="language-c">static void mem_profile_record_alloc(mem_profile_t *profile,
                                     uint64_t objects_count,
                                     uint64_t bytes_count) {
  // Record the call stack by stack walking.
  uint64_t call_stack[64] = {0};
  uint64_t call_stack_len =
      record_call_stack(call_stack, sizeof(call_stack) / sizeof(call_stack[0]));

  // Update the sums.
  profile-&gt;alloc_objects += objects_count;
  profile-&gt;alloc_space += bytes_count;
  profile-&gt;in_use_objects += objects_count;
  profile-&gt;in_use_space += bytes_count;

  // Upsert the record.
  for (uint64_t i = 0; i &lt; profile-&gt;records_len; i++) {
    mem_record_t *r = &amp;profile-&gt;records[i];

    if (r-&gt;call_stack_len == call_stack_len &amp;&amp;
        memcmp(r-&gt;call_stack, call_stack, call_stack_len * sizeof(uint64_t)) ==
            0) {
      // Found an existing record, update it.
      r-&gt;alloc_objects += objects_count;
      r-&gt;alloc_space += bytes_count;
      r-&gt;in_use_objects += objects_count;
      r-&gt;in_use_space += bytes_count;
      return;
    }
  }

  // Not found, insert a new record
  mem_record_t record = {
      .alloc_objects = objects_count,
      .alloc_space = bytes_count,
      .in_use_objects = objects_count,
      .in_use_space = bytes_count,
  };
  record.call_stack = arena_alloc(&amp;profile-&gt;arena, sizeof(uint64_t),
                                  _Alignof(uint64_t), call_stack_len);
  memcpy(record.call_stack, call_stack, call_stack_len * sizeof(uint64_t));
  record.call_stack_len = call_stack_len;

  if (profile-&gt;records_len &gt;= profile-&gt;records_cap) {
    uint64_t new_cap = profile-&gt;records_cap * 2;
    // Grow the array.
    mem_record_t *new_records = arena_alloc(
        &amp;profile-&gt;arena, sizeof(mem_record_t), _Alignof(mem_record_t), new_cap);
    memcpy(new_records, profile-&gt;records,
           profile-&gt;records_len * sizeof(mem_record_t));
    profile-&gt;records_cap = new_cap;
    profile-&gt;records = new_records;
  }
  profile-&gt;records[profile-&gt;records_len++] = record;
}

</code></pre>
<p>Finally, we can dump this profile in the <code>pprof</code> textual representation:</p>
<pre><code>static void mem_profile_write(mem_profile_t *profile, FILE *out) {
  fprintf(out, &quot;heap profile: %lu: %lu [     %lu:    %lu] @ heapprofile\n&quot;,
          profile-&gt;in_use_objects, profile-&gt;in_use_space,
          profile-&gt;alloc_objects, profile-&gt;alloc_space);

  for (uint64_t i = 0; i &lt; profile-&gt;records_len; i++) {
    mem_record_t r = profile-&gt;records[i];

    fprintf(out, &quot;%lu: %lu [%lu: %lu] @ &quot;, r.in_use_objects, r.in_use_space,
            r.alloc_objects, r.alloc_space);

    for (uint64_t j = 0; j &lt; r.call_stack_len; j++) {
      fprintf(out, &quot;%#lx &quot;, r.call_stack[j]);
    }
    fputc('\n', out);
  }

  fputs(&quot;\nMAPPED_LIBRARIES:\n&quot;, out);

  static uint8_t mem[4096] = {0};
  int fd = open(&quot;/proc/self/maps&quot;, O_RDONLY);
  assert(fd != -1);
  ssize_t read_bytes = read(fd, mem, sizeof(mem));
  assert(read_bytes != -1);
  close(fd);

  fwrite(mem, 1, read_bytes, out);

  fflush(out);
}
</code></pre>
<p>And we're done! Let's try it with our initial example (bumping the size of the allocations a bit because <code>pprof</code> ignores tiny allocations for readability - although this is configurable):</p>
<pre><code class="language-c">void b(int n, arena_t *arena) {
  arena_alloc(arena, sizeof(int), _Alignof(int), n);
}

void a(int n, arena_t *arena) {
  arena_alloc(arena, sizeof(int), _Alignof(int), n);
  b(n, arena);
}

int main() {
  [...]

  arena_t arena = arena_new(1 &lt;&lt; 28, &amp;mem_profile);

  for (int i = 0; i &lt; 2; i++)
    a(2 * 1024 * 1024, &amp;arena);

  b(3 * 1024 * 1024, &amp;arena);

  mem_profile_write(&amp;mem_profile, stderr);
}
</code></pre>
<pre><code class="language-sh">$ cc -g3 example.c
$ ./a.out 2&gt; heap.profile
$ pprof --web ./a.out heap.profile
</code></pre>
<p>And we see in our browser:</p>
<p><img src="mem_prof4.png" alt="Initial profile" /></p>
<p>And we can even generate a flamegraph for it leveraging the great <a href="https://github.com/brendangregg/FlameGraph">OG flamegraph project</a>:</p>
<pre><code class="language-sh">$ pprof --collapsed ./a.out heap.profile | flamegraph.pl &gt; out.svg
</code></pre>
<p><img src="mem_prof_flamegraph.svg" alt="Flamegraph" /></p>
<h2>Variations and limitations</h2>
<ul>
<li>For this article we always do memory profiling and abort once the arena is full; but it does not have to be this way. Memory profiling could be enabled in a CLI program with a command line flag; if it is disabled we do not create a memory profile nor an arena for it. Or, it could be enabled/disabled dynamically, after a given amount of time, etc. It could also stop when its dedicated arena is full instead of aborting the whole program.</li>
<li>Sampling could be easily added to <code>mem_profile_record_alloc</code> to only record some records, say 1%</li>
<li>The current maximum call stack depth is 64, for brevity in the context of this article. We can store a bigger one by having a dynamically sized array or storing each address in a more compact format, e.g. varint instead of a fixed 8 bytes</li>
<li>Stack traces won't work across library calls that are compiled without frame pointers. To which I'd say: It's likely easier to compile all of the code you depend on with the build flags you require than try to come up with alternative ways to walk the stack. Your mileage may vary.</li>
<li>We use linear scanning to find an existing record with the same call stack. When having lots of records, it would be advantageous to use a binary search on a sorted array or perhaps a hashtable.</li>
</ul>
<h2>Alternatives</h2>
<p><code>pprof</code> (the Perl one) is not the only way to get this information.</p>
<p>It turns out that your browser comes with a built-in profiler and a nice one to use at that! And it has support for native allocations, stack traces and so forth. Another possibility is the new <code>pprof</code> (the Go one). They all have more features than the original <code>pprof</code> that are really handy, most notably:</p>
<ul>
<li>A built-in interactive flamegraph feature</li>
<li>Tracking the time at which an allocation happened, which can then be used to produce a flamechart representing allocations over time (for example to observe a memory leak increasing the memory usage over time, and discover where it comes from)</li>
</ul>
<p>To make use of these, our application needs to generate the information we gathered in the format the profiler expects, just like we did with <code>pprof</code>.</p>
<ul>
<li>Chrome expects a <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">JSON file</a>, which I did not experiment with yet.</li>
<li>Firefox expects a <a href="https://github.com/firefox-devtools/profiler/blob/main/docs-developer/processed-profile-format.md">different JSON file</a>. A good starting point is <a href="https://github.com/mstange/samply">https://github.com/mstange/samply</a>. I experimented with it but dropped this avenue because of several frustrating aspects:
<ul>
<li>It is very JS-centric so much of the profile has to be filled with <code>null</code> values or explicitly saying that the each sample is not for JS.</li>
<li>All fields must be provided even if empty, including arrays. Failing to do so throws an obscure exception in the profiler, that has to be tracked in the browser debugger, which shows the minified JS profiler code, which is not fun (yes, the profiler is written mostly/entirely in JS). The consequence is that most of the profile file is made of lengthy arrays only containing <code>null</code> values. Thus, most of the code to generate it is boilerplate noise.</li>
<li>Memory traces are supported but it seems that a CPU trace is required for each memory trace which makes the profile even bigger, and harder to generate. Only providing memory samples shows nothing in the graphs.</li>
</ul>
</li>
<li>The new <code>pprof</code> (the Go version) expects a relatively simple gzipped <a href="https://github.com/google/pprof/tree/4ca4178f5c7ab3f10300f07dab7422ead8dc17bc/proto">protobuf file</a>, but that means adding code generation and a library dependency. I use this tool when writing Go quite often and it is helpful. It also supports adding labels to samples, for example we could label the allocations coming from different arenas differently to be able to distinguish them in the same profile.</li>
</ul>
<h2>Conclusion</h2>
<p>I like that one of the most common memory profilers uses a very simple text format that anyone can generate, and that's it's stand-alone. It's very UNIXy!</p>
<p>Nonetheless, I will in the future explore the other aforementioned profilers (probably the Chrome one because it seems the most straightforward) and I do not think it should be much additional work. It's nice to leverage the existing browser to avoid having to install a profiler.</p>
<p>After all, it's been <a href="https://technology.riotgames.com/news/profiling-real-world-performance-league">done before</a>!</p>
<blockquote>
<p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&amp;locale.x=en_US">Donate</a></p>
</blockquote>
<h2>Addendum: the full code</h2>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;unistd.h&gt;

typedef struct {
  uint64_t in_use_space, in_use_objects, alloc_space, alloc_objects;
  uint64_t *call_stack;
  uint64_t call_stack_len;
} mem_record_t;

typedef struct mem_profile mem_profile_t;
typedef struct {
  uint8_t *start;
  uint8_t *end;
  mem_profile_t *profile;
} arena_t;

struct mem_profile {
  mem_record_t *records;
  uint64_t records_len;
  uint64_t records_cap;
  uint64_t in_use_space, in_use_objects, alloc_space, alloc_objects;
  arena_t arena;
};

static void *arena_alloc(arena_t *a, size_t size, size_t align, size_t count);

static uint8_t record_call_stack(uint64_t *dst, uint64_t cap) {
  uintptr_t *rbp = __builtin_frame_address(0);

  uint64_t len = 0;

  while (rbp != 0 &amp;&amp; ((uint64_t)rbp &amp; 7) == 0 &amp;&amp; *rbp != 0) {
    const uintptr_t rip = *(rbp + 1);
    rbp = (uintptr_t *)*rbp;

    // `rip` points to the return instruction in the caller, once this call is
    // done. But: We want the location of the call i.e. the `call xxx`
    // instruction, so we subtract one byte to point inside it, which is not
    // quite 'at' it, but good enough.
    dst[len++] = rip - 1;

    if (len &gt;= cap)
      return len;
  }
  return len;
}
static void mem_profile_record_alloc(mem_profile_t *profile,
                                     uint64_t objects_count,
                                     uint64_t bytes_count) {
  // Record the call stack by stack walking.
  uint64_t call_stack[64] = {0};
  uint64_t call_stack_len =
      record_call_stack(call_stack, sizeof(call_stack) / sizeof(call_stack[0]));

  // Update the sums.
  profile-&gt;alloc_objects += objects_count;
  profile-&gt;alloc_space += bytes_count;
  profile-&gt;in_use_objects += objects_count;
  profile-&gt;in_use_space += bytes_count;

  // Upsert the record.
  for (uint64_t i = 0; i &lt; profile-&gt;records_len; i++) {
    mem_record_t *r = &amp;profile-&gt;records[i];

    if (r-&gt;call_stack_len == call_stack_len &amp;&amp;
        memcmp(r-&gt;call_stack, call_stack, call_stack_len * sizeof(uint64_t)) ==
            0) {
      // Found an existing record, update it.
      r-&gt;alloc_objects += objects_count;
      r-&gt;alloc_space += bytes_count;
      r-&gt;in_use_objects += objects_count;
      r-&gt;in_use_space += bytes_count;
      return;
    }
  }

  // Not found, insert a new record.
  mem_record_t record = {
      .alloc_objects = objects_count,
      .alloc_space = bytes_count,
      .in_use_objects = objects_count,
      .in_use_space = bytes_count,
  };
  record.call_stack = arena_alloc(&amp;profile-&gt;arena, sizeof(uint64_t),
                                  _Alignof(uint64_t), call_stack_len);
  memcpy(record.call_stack, call_stack, call_stack_len * sizeof(uint64_t));
  record.call_stack_len = call_stack_len;

  if (profile-&gt;records_len &gt;= profile-&gt;records_cap) {
    uint64_t new_cap = profile-&gt;records_cap * 2;
    // Grow the array.
    mem_record_t *new_records = arena_alloc(
        &amp;profile-&gt;arena, sizeof(mem_record_t), _Alignof(mem_record_t), new_cap);
    memcpy(new_records, profile-&gt;records,
           profile-&gt;records_len * sizeof(mem_record_t));
    profile-&gt;records_cap = new_cap;
    profile-&gt;records = new_records;
  }
  profile-&gt;records[profile-&gt;records_len++] = record;
}

static void mem_profile_write(mem_profile_t *profile, FILE *out) {
  fprintf(out, &quot;heap profile: %lu: %lu [     %lu:    %lu] @ heapprofile\n&quot;,
          profile-&gt;in_use_objects, profile-&gt;in_use_space,
          profile-&gt;alloc_objects, profile-&gt;alloc_space);

  for (uint64_t i = 0; i &lt; profile-&gt;records_len; i++) {
    mem_record_t r = profile-&gt;records[i];

    fprintf(out, &quot;%lu: %lu [%lu: %lu] @ &quot;, r.in_use_objects, r.in_use_space,
            r.alloc_objects, r.alloc_space);

    for (uint64_t j = 0; j &lt; r.call_stack_len; j++) {
      fprintf(out, &quot;%#lx &quot;, r.call_stack[j]);
    }
    fputc('\n', out);
  }

  fputs(&quot;\nMAPPED_LIBRARIES:\n&quot;, out);

  static uint8_t mem[4096] = {0};
  int fd = open(&quot;/proc/self/maps&quot;, O_RDONLY);
  assert(fd != -1);
  ssize_t read_bytes = read(fd, mem, sizeof(mem));
  assert(read_bytes != -1);
  close(fd);

  fwrite(mem, 1, read_bytes, out);

  fflush(out);
}

static void *arena_alloc(arena_t *a, size_t size, size_t align, size_t count) {
  size_t available = a-&gt;end - a-&gt;start;
  size_t padding = -(size_t)a-&gt;start &amp; (align - 1);

  size_t offset = padding + size * count;
  if (available &lt; offset) {
    fprintf(stderr,
            &quot;Out of memory: available=%lu &quot;
            &quot;allocation_size=%lu\n&quot;,
            available, offset);
    abort();
  }

  uint8_t *res = a-&gt;start + padding;

  a-&gt;start += offset;

  if (a-&gt;profile) {
    mem_profile_record_alloc(a-&gt;profile, count, offset);
  }

  return (void *)res;
}

static arena_t arena_new(uint64_t cap, mem_profile_t *profile) {
  uint8_t *mem = mmap(NULL, cap, PROT_READ | PROT_WRITE,
                      MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);

  arena_t arena = {
      .profile = profile,
      .start = mem,
      .end = mem + cap,
  };
  return arena;
}

void b(int n, arena_t *arena) {
  arena_alloc(arena, sizeof(int), _Alignof(int), n);
}

void a(int n, arena_t *arena) {
  arena_alloc(arena, sizeof(int), _Alignof(int), n);
  b(n, arena);
}

int main() {
  arena_t mem_profile_arena = arena_new(1 &lt;&lt; 16, NULL);
  mem_profile_t mem_profile = {
      .arena = mem_profile_arena,
      .records = arena_alloc(&amp;mem_profile_arena, sizeof(mem_record_t),
                             _Alignof(mem_record_t), 16),
      .records_cap = 16,
  };

  arena_t arena = arena_new(1 &lt;&lt; 28, &amp;mem_profile);

  for (int i = 0; i &lt; 2; i++)
    a(2 * 1024 * 1024, &amp;arena);

  b(3 * 1024 * 1024, &amp;arena);

  mem_profile_write(&amp;mem_profile, stderr);
}
</code></pre>
</div>
</body>
</html>

]]>
    </content>
     </entry>

     <entry>
       <title>Adventures in CI land, or how to speed up your CI</title>
       <link href="/blog/speed_up_your_ci.html"/>
       <id>urn:uuid:4663e8ea-73ab-56ef-9dc5-8dbb4743d84a</id>
       <updated>2023-12-15T11:33:55Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>Adventures in CI land, or how to speed up your CI</h1>
<p>Every project has a Continuous Integration (CI) pipeline and every one of them complains its CI is too slow. It is more important than you might think; this can be the root cause of many problems, including lackluster productivity, low morale, high barrier of entry for newcomers, and overall suboptimal quality.</p>
<p>But this need not be. I have compiled here a lengthy list of various ways you can simplify your CI and make it faster, based on my experience on open-source projects and my work experience. I sure wish you will find something in here worth your time.</p>
<p>And finally, I hope you will realize this endeavour is not unlike optimizing a program: it requires some time and dedication but you will get tremendous results. Also, almost incidentally, it will be more secure and easier to audit.</p>
<p>Lastly, remember to measure and profile your changes. If a change has made no improvements, it should be reverted.</p>
<p><em>This article assumes you are running a POSIX system. Windows developers, this is not the article you are looking for.</em></p>
<h2>Reduce the size of everything</h2>
<p>Almost certainly, your CI pipeline has to download 'something', be it a base docker image, a virtual machine image, some packages, maybe a few company wide scripts. The thing is, you are downloading those every time it runs, 24/7, every day of the year. Even a small size reduction can yield big speed ups. Remember, the network is usually the bottleneck.</p>
<p>In no particular order:</p>
<ul>
<li>Only fetch required git objects. That means running <code>git clone my-repo.git --depth 1 --branch shiny-feature</code>, instead of cloning the whole repository every time, along with every branch and that one class file that your coworker accidentally committed once.</li>
<li>Axe duplicate tools. <code>curl</code> and <code>wget</code> are equivalent, given the right command line options. Settle on using only one and stick to it. All my pipelines use: <code>curl --sSL --retry 5</code>. You can customize further, but that's the gist of it. Other examples: <code>make</code> and <code>ninja</code>, <code>gcc</code> and <code>clang</code>, etc.</li>
<li>Use POSIX tools. They are already present on whatever system you are using. When purely checking that a tool or an API returned 'OK', simply use <code>grep</code> and <code>awk</code>, no need for <code>ripgrep</code>. Prefer <code>sh</code> over <code>bash</code> for simple scripts, <code>make</code> over <code>rake</code> for builds, etc. It's most likely faster, more stable, and more documented, too.</li>
<li>Pay attention to the base image you are using. Prefer a small image where you install only what you need. I have seen docker base images over 1 Gb big. You will spend more time downloading it, uncompressing it, and checksumming it, than running your pipeline. Alpine Linux is great. Debian and Ubuntu are fine. When in doubt, inspect the content of the image. Look for stuff that should not be here. E.g.: <code>X11</code>, man pages, etc.</li>
<li>Don't install documentation. It's obvious but most people do it. While you are at it, don't install <code>man</code>, <code>apropos</code>, <code>info</code>, etc. Alpine Linux gets it right by splitting almost all packages between the package itself and its documentation. E.g.: <code>cmake</code> and <code>cmake-doc</code>.</li>
<li>On the same vein: don't install shell autocompletions. Same idea. Again, on Alpine they are not part of the main package. E.g.: <code>cmake</code> and <code>cmake-bash-completion</code>.</li>
<li>Stay away from aggregate packages (or meta-packages)! Those are for convenience only when developing. E.g.: <code>build-base</code> on Alpine is a meta-package gathering <code>make</code>, <code>file</code>, <code>gcc</code>, etc. It will bring lots of things you do not need. Cherry-pick only what you really required and steer clear of those packages.</li>
<li>Learn how Docker image layers work: avoid doing <code>RUN rm archive.tar</code>, since it simply creates a new layer without removing the file from the previous layer. Prefer: <code>RUN curl -sSL --retry 5 foo.com/archive.tar &amp;&amp; tar -xf archive.tar &amp;&amp; rm archive.tar</code> which will not add the tar archive to the Docker image.</li>
<li>Use multi-stage Docker builds. It is old advice at this point but it bears repeating.</li>
<li>When using multi-stage: Only copy files you need from a previous stage instead of globbing wildly, thus defeating the purpose of multi-stages.</li>
<li>Tell apart the development and the release variant of a package. For example: on Ubuntu, when using the SDL2 library, it comes in two flavors: <code>libsdl2-dev</code> and <code>libsdl2-2.0</code>. The former is the development variant which you only need when building code that needs the headers and the libraries of the SDL2, while the latter is only useful with software needing the dynamic libraries at runtime. The development packages are usually bigger in size. You can astutely use multi-stage Docker builds to have first a build stage using the development packages, and then a final stage which only has the non-development packages. In CI, you almost never need both variants installed at the same time.</li>
<li>Opt-out of 'recommended' packages. Aptitude on Debian/Ubuntu is the culprit here: <code>apt-get install foo</code> will install much more than <code>foo</code>. It will also install recommended packages that most of the time are completely unrelated. Always use <code>apt-get install --no-install-recommends foo</code>.</li>
<li>Don't create unnecessary files: you use use heredoc and shell pipelines to avoid creating intermediary files.</li>
</ul>
<h2>Be lazy: Don't do things you don't need to do</h2>
<ul>
<li>Some features you are not using are enabled by default. Be explicit instead of relying on obscure, ever changing defaults. Example: <code>CGO_ENABLED=0 go build ...</code> because it is (at the time of writing) enabled by default. The Gradle build system also has the annoying habit to run stuff behind your back. Use <code>gradle foo -x baz</code> to run <code>foo</code> and not <code>baz</code>.</li>
<li>Don't run tests from your dependencies. This can happen if you are using git submodules or vendoring dependencies in some way. You generally always want to build them, but not run their tests. Again, <code>gradle</code> is the culprit here. If you are storing your git submodules in a <code>submodules/</code> directory for example, you can run only your project tests with: <code>gradle test -x submodules:test</code>.</li>
<li>Disable the generation of reports files. They frequently come in the form of HTML or XML form, and once again, <code>gradle</code> gets out of his way to clutter your filesystem with those. Of debatable usefulness locally, they are downright wasteful in CI. And it takes some precious time, too! Disable it with:
tasks.withType<Test> {
useJUnitPlatform()
reports.html.isEnabled = false
reports.junitXml.isEnabled = false
}</li>
<li>Check alternative repositories for a dependency instead of building it from source. It can happen that a certain dependency you need is not in the main repositories of the package manager of your system. You can however inspect other repositories before falling back to building it yourself. On Alpine, you can simply add the URL of the repository to <code>/etc/apk/repositories</code>. For example, in the main Alpine Docker image, the repository <code>https://&lt;mirror-server&gt;/alpine/edge/testing</code> is not enabled. More information <a href="https://wiki.alpinelinux.org/wiki/Enable_Community_Repository">here</a>. Other example: on OpenBSD or FreeBSD, you can opt-in to use the <code>current</code> branch to get the newest and latest changes, and along them the newest dependencies.</li>
<li>Don't build the static and dynamic variants of the same library (in C or C++). You probably only want one, preferably the static one. Otherwise, you are doing twice the work!</li>
<li>Fetch statically built binaries instead of building them from source. Go, and sometimes Rust, are great for this. As long as the OS and the architecture are the same, of course. E.g.: you can simply fetch <code>kubectl</code> which is a Go static binary instead of installing lots of Kubernetes packages, if you simply need to talk to a Kubernetes cluster. Naturally, the same goes for single file, dependency-less script: shell, awk, python, lua, perl, and ruby, assuming the interpreter is the right one. But this case is rarer and you might as well vendor the script at this point.</li>
<li>Groom your 'ignore' files. <code>.gitignore</code> is the mainstream one, but were you aware Docker has the mechanism in the form of a <code>.dockerignore</code> file? My advice: whitelist the files you need, e.g.:
<pre><code>**/*
!**/*.js
</code></pre>
This can have a huge impact on performance since Docker will copy all the files inside the Docker context directory inside the container (or virtual machine on macOS) and it can be a lot. You don't want to copy build artifacts, images, and so on each time which your image does not need.</li>
<li>Use an empty Docker context if possible: you sometimes want to build an image which does not need any local files. In that case you can completely bypass copying any files into the image with the command: <code>docker build . -f - &lt; Dockerfile</code>.</li>
<li>Don't update the package manager cache: you typically need to start your Dockerfile by updating the package manager cache, otherwise it will complain the dependencies you want to install are not found. E.g.: <code>RUN apk update &amp;&amp; apk add curl</code>. But did you know it is not always required? You can simply do: <code>RUN apk --no-cache add curl</code> when you know the package exists and you can bypass the cache.</li>
<li>Silence the tools: most command line applications accept the <code>-q</code> flag which reduces their verbosity. Most of their output is likely to be useless, some CI systems will struggle storing big pipeline logs, and you might be bottlenecked on stdout! Also, it will simplify troubleshooting <em>your</em> build if it is not swamped in thousands of unrelated logs.</li>
</ul>
<h2>Miscellenaous tricks</h2>
<ul>
<li>Use <code>sed</code> to quickly edit big files in place. E.g.: you want to insert a line at the top of a Javascript file to skip linter warnings. Instead of doing: <code>printf '/* eslint-disable */\n\n' | cat - foo.js &gt; foo_tmp &amp;&amp; mv foo_tmp foo.js</code>, which involves reading the whole file, copying it, and renaming it, we can do: <code>sed -i '1s#^#/* eslint-disable */ #' foo.js</code> which is simpler.</li>
<li>Favor static linking and LTO. This will simplify much of your pipeline because you'll have to deal with fewer files, ideally one statically built executable.</li>
<li>Use only one Gitlab CI job. That is because the startup time of a job is very high, in the order of minutes. You can achieve task parallelism with other means such as <code>parallel</code> or <code>make -j</code>.</li>
<li>Parallelize all the things! Some tools do not run tasks in parallel by default, e.g. <code>make</code> and <code>gradle</code>. Make sure you are always using a CI instance with multiple cores and are passing <code>--parallel</code> to Gradle and <code>-j$(nproc)</code> to make. In rare instances you might have to tweak the exact level of parallelism to your particular task for maximum performance. Also, <code>parallel</code> is great for parallelizing tasks.</li>
<li>Avoid network accesses: you should minimize the amount of things you are downloading from external sources in your CI because it is both slow and a source of flakiness. Some tools will unfortunately always try to 'call home' even if all of your dependencies are present. You should disable this behavior explicitly, e.g. with Gradle: <code>gradle build --offline</code>.</li>
<li>In some rare cases, you will be bottlenecked on a slow running script. Consider using a faster interpreter: for shell scripts, there is <code>ash</code> and <code>dash</code> which are said to be much faster than <code>bash</code>. For <code>awk</code> there is <code>gawk</code> and <code>mawk</code>. For Lua there is <code>LuaJIT</code>.</li>
<li>Avoid building inside Docker if you can. Building locally, and then copying the artifacts into the image, is always faster. It only works under certain constraints, of course:
<ul>
<li>same OS and architecture, or</li>
<li>a portable artifact format such as <code>jar</code>, and not using native dependencies, or</li>
<li>your toolchain supports cross-compilation</li>
</ul>
</li>
</ul>
<h2>A note on security</h2>
<ul>
<li>Always use https</li>
<li>Checksum files you fetched from third-parties with <code>shasum</code>.</li>
<li>Favor official package repositories, docker images, and third-parties over those of individuals.</li>
<li>Never bypass certificate checks (such as <code>curl -k</code>)</li>
</ul>
<h2>I am a DevOps Engineer, what can I do?</h2>
<p>Most of the above rules can be automated with a script, assuming the definition of a CI pipeline is in a text format (e.g. Gitlab CI). I would suggest starting here, and teaching developers about these simple tips than really make a difference.</p>
<p>I would also suggest considering adding strict firewall rules inside CI pipelines, and making sure the setup/teardown of CI runners is very fast. Additionally, I would do everything to avoid a situation where no CI runner is available, preventing developers from working and deploying.</p>
<p>Finally, I would recommend leading by example with the pipelines for the tools made by DevOps Engineers in your organization.</p>
<h2>Closing words</h2>
<p>I wish you well on your journey towards a fast, reliable and simple CI pipeline.</p>
<p>I noticed in my numerous projects with different tech stacks that some are friendlier than others towards CI pipelines than others (I am looking at you, Gradle!). If you have the luxury of choosing your technical stack, do consider how it will play out with your pipeline. I believe this is a much more important factor than discussing whether $LANG has semicolons or not because I am convinced it can completely decide the outcome of your project.</p>
<blockquote>
<p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&amp;locale.x=en_US">Donate</a></p>
</blockquote>
</div>
</body>
</html>

]]>
    </content>
     </entry>

     <entry>
       <title>Learn Wayland by writing a GUI from scratch</title>
       <link href="/blog/wayland_from_scratch.html"/>
       <id>urn:uuid:6b96e587-14ff-53a9-a142-d20e9c53d970</id>
       <updated>2023-12-15T11:33:55Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/highlight.min.js"></script>
<script>
window.addEventListener("load", (event) => {
  hljs.highlightAll();
});
</script>
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>Learn Wayland by writing a GUI from scratch</h1>
<p><a href="https://wayland.freedesktop.org/">Wayland</a> is all the rage those days. Distributions left and right switch to it, many readers of my previous article on <a href="/blog/x11_x64.html">writing a X11 GUI from scratch in x86_64 assembly</a> asked for a follow-up article about Wayland, and I now run Wayland on my desktop. So here we go, let's write a (very simple) GUI program with Wayland, without any libraries, this time in C.</p>
<p>Here is what we are working towards:</p>
<p><img src="wayland-screenshot-tiled1.png" alt="Result" /></p>
<p>We display the Wayland logo in its own window (we can see the mountain wallpaper in the background since we use a fixed size buffer). It's not quite Visual Studio yet, I know, but it's a good foundation for more in future articles, perhaps.</p>
<p>Why not in assembly again you ask? Well, the Wayland protocol has some peculiarities that necessitate the use of some C standard library macros to make it work reliably on different platforms (Linux, FreeBSD, etc): namely, sending a file descriptor over a UNIX socket. Maybe it could be done in assembly, but it would be much more tedious. Also, the Wayland protocol is completely asynchronous by nature, whereas the X11 protocol was more of a request-(maybe) response chatter, and as such, we have to keep track of some state in our program, and C makes it easier.</p>
<p>Now, if you want to follow along and translate the C snippets into assembly, go for it, it is doable, just tedious.</p>
<blockquote>
<p>If you spot an error, please open a <a href="https://github.com/gaultier/blog">Github issue</a>!</p>
</blockquote>
<p><em>This article has been discussed on <a href="https://news.ycombinator.com/item?id=37876896">Hacker News</a> and <a href="https://lobste.rs/s/385e2w/learn_wayland_by_writing_gui_from_scratch">Lobsters</a>.</em></p>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#learn-wayland-by-writing-a-gui-from-scratch">Learn Wayland by writing a GUI from
scratch</a>
<ul>
<li><a href="#what-do-we-need">What do we need?</a></li>
<li><a href="#wayland-basics">Wayland basics</a></li>
<li><a href="#opening-a-socket">Opening a socket</a></li>
<li><a href="#creating-a-registry">Creating a registry</a></li>
<li><a href="#shared-memory-the-frame-buffer">Shared memory: the frame
buffer</a></li>
<li><a href="#chatting-with-the-compositor">Chatting with the compositor</a>
<ul>
<li><a href="#reacting-to-events-binding-interfaces">Reacting to events: binding
interfaces</a></li>
<li><a href="#using-the-interfaces-we-created">Using the interfaces we
created</a></li>
<li><a href="#reacting-to-events-pingpong">Reacting to events:
ping/pong</a></li>
<li><a href="#reacting-to-events-configureack-configure">Reacting to events: configure/ACK
configure</a></li>
<li><a href="#rendering-a-frame-the-red-rectangle">Rendering a frame: the red
rectangle</a></li>
<li><a href="#rendering-a-frame-the-wayland-logo">Rendering a frame: The Wayland
logo</a></li>
</ul>
</li>
<li><a href="#the-end">The end</a></li>
<li><a href="#addendum-the-full-code">Addendum: the full code</a></li>
</ul>
</li>
</ul>
<h2>What do we need?</h2>
<p>Not much: We'll use C99 so any C compiler of the last 20 years will do. Having a Wayland desktop to test the application will also greatly help.</p>
<p>Note that I have only run it on Linux; it should work (meaning: compile and run) on other platforms running Wayland such as FreeBSD, it's just that I have not tried.</p>
<p><em>Note that the code in this article has not been written in the most robust way, it simply exits when things are not how they should be for example. So, not production ready, but still a good learning resource and a good foundation for more.</em></p>
<h2>Wayland basics</h2>
<p>Wayland is a protocol specification for GUI applications (and more), in short. We will write the client side, while the server side is a compositor which understands our protocol. If you have a Wayland desktop right now, a Wayland compositor is already running so there is nothing to do.</p>
<p>Much like X11, a client opens a UNIX socket, sends some commands in a specific format (which are different from the X11 ones), to open a window and the server can also send messages to notify the client to resize the window, that there is some keyboard input, etc. It's important to note that contrary to X11, in Wayland, the client only has access to its own window.</p>
<p>It is also interesting to note that Wayland is quite a limited protocol and any GUI will have to use extension protocols.</p>
<p>Most client applications use <code>libwayland</code> which is a library composed of C files that are autogenerated from a XML file describing the protocol.
The same goes for extension protocols: they simply are one XML file that is turned into C files, which are then compiled and linked to a GUI application.</p>
<p>Now, we will not do any of this: we will instead write our own serialization and deserialization functions, which is really not a lot of work as you will see.</p>
<p>There are many advantages:</p>
<ul>
<li>No need to link to external libraries: no build system complexities, no dynamic linking issues, and so on.</li>
<li>We do not have to use the callback system that <code>libwayland</code> requires.</li>
<li>We can use the I/O mechanism we wish to listen to incoming messages: blocking, <code>poll</code>, <code>select</code>, <code>epoll</code>, <code>io_uring</code>, <code>kqueue</code> on some systems, etc. Here, we will use blocking calls for simplicity but the world is your oyster.</li>
<li>Easy troubleshooting: 100% of the code is our own.</li>
<li>No XML</li>
<li>The protocols we will use are stable so the numeric values on the wire should not change underneath us, but in the unlikely event they do, we simply have to fix them in our code and compile again.</li>
</ul>
<p>So at this point you might be thinking: this is going to be so much work! Well, not really. Here are <strong>all</strong> of the Wayland protocol numeric values we will need, including the extension protocols:</p>
<pre><code class="language-c">static const uint32_t wayland_display_object_id = 1;
static const uint16_t wayland_wl_registry_event_global = 0;
static const uint16_t wayland_shm_pool_event_format = 0;
static const uint16_t wayland_wl_buffer_event_release = 0;
static const uint16_t wayland_xdg_wm_base_event_ping = 0;
static const uint16_t wayland_xdg_toplevel_event_configure = 0;
static const uint16_t wayland_xdg_toplevel_event_close = 1;
static const uint16_t wayland_xdg_surface_event_configure = 0;
static const uint16_t wayland_wl_display_get_registry_opcode = 1;
static const uint16_t wayland_wl_registry_bind_opcode = 0;
static const uint16_t wayland_wl_compositor_create_surface_opcode = 0;
static const uint16_t wayland_xdg_wm_base_pong_opcode = 3;
static const uint16_t wayland_xdg_surface_ack_configure_opcode = 4;
static const uint16_t wayland_wl_shm_create_pool_opcode = 0;
static const uint16_t wayland_xdg_wm_base_get_xdg_surface_opcode = 2;
static const uint16_t wayland_wl_shm_pool_create_buffer_opcode = 0;
static const uint16_t wayland_wl_surface_attach_opcode = 1;
static const uint16_t wayland_xdg_surface_get_toplevel_opcode = 1;
static const uint16_t wayland_wl_surface_commit_opcode = 6;
static const uint16_t wayland_wl_display_error_event = 0;
static const uint32_t wayland_format_xrgb8888 = 1;
static const uint32_t wayland_header_size = 8;
static const uint32_t color_channels = 4;
</code></pre>
<p>So, not that much!</p>
<h2>Opening a socket</h2>
<p>The first step is opening a UNIX domain socket. Note that this step is exactly the same as for X11, save for the path of the socket. Also, X11 is designed to be used over the network so it does not have to be a UNIX domain socket, on the same machine - but everybody does so on their desktop machine anyway.</p>
<p>To craft the socket path, we follow these simple steps:</p>
<ul>
<li>If <code>$WAYLAND_DISPLAY</code> is set, attempt to connect to <code>$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY</code></li>
<li>Otherwise, attempt to connect to <code>$XDG_RUNTIME_DIR/wayland-0</code></li>
<li>Otherwise, fail</li>
</ul>
<p>Here goes, along with two utility macros we'll use everywhere:</p>
<pre><code class="language-c">#define cstring_len(s) (sizeof(s) - 1)

#define roundup_4(n) (((n) + 3) &amp; -4)

static int wayland_display_connect() {
  char *xdg_runtime_dir = getenv(&quot;XDG_RUNTIME_DIR&quot;);
  if (xdg_runtime_dir == NULL)
    return EINVAL;

  uint64_t xdg_runtime_dir_len = strlen(xdg_runtime_dir);

  struct sockaddr_un addr = {.sun_family = AF_UNIX};
  assert(xdg_runtime_dir_len &lt;= cstring_len(addr.sun_path));
  uint64_t socket_path_len = 0;

  memcpy(addr.sun_path, xdg_runtime_dir, xdg_runtime_dir_len);
  socket_path_len += xdg_runtime_dir_len;

  addr.sun_path[socket_path_len++] = '/';

  char *wayland_display = getenv(&quot;WAYLAND_DISPLAY&quot;);
  if (wayland_display == NULL) {
    char wayland_display_default[] = &quot;wayland-0&quot;;
    uint64_t wayland_display_default_len = cstring_len(wayland_display_default);

    memcpy(addr.sun_path + socket_path_len, wayland_display_default,
           wayland_display_default_len);
    socket_path_len += wayland_display_default_len;
  } else {
    uint64_t wayland_display_len = strlen(wayland_display);
    memcpy(addr.sun_path + socket_path_len, wayland_display,
           wayland_display_len);
    socket_path_len += wayland_display_len;
  }

  int fd = socket(AF_UNIX, SOCK_STREAM, 0);
  if (fd == -1)
    exit(errno);

  if (connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1)
    exit(errno);

  return fd;
}
</code></pre>
<p>In Wayland, there is no connection setup to do, such as sending some special messages, so there is nothing more to do.</p>
<h2>Creating a registry</h2>
<p>Now, to do anything useful, we want to create a registry: it is an object that allows us to query at runtime the capabilities of the compositor.</p>
<p>In Wayland, to create an object, we simply send the right message followed by an id of our own. Ids should be unique so we simply increment a number each time we want to create a new resource. After this is done, we will remember this number to be able to refer to it in later messages:</p>
<p>This is coincidentally our first message we send, so let's briefly go over the structure of a Wayland message. It is basically a RPC mechanism. All bytes are in the host endianness so there is nothing special to do about it:</p>
<ul>
<li>4 bytes: The id of the resource ('object') we want to call a method on</li>
<li>2 bytes: The opcode of the method we want to call</li>
<li>2 bytes: The size of the message</li>
<li>Depending on the method, arguments in their wire format follow</li>
</ul>
<p>The object id in this case is <code>1</code>, which is the singleton <code>wl_display</code> that already exists.
The method is: <code>get_registry(u32 new_id)</code> whose opcode we listed before.
The sole argument takes 4 bytes and is this incremental number we keep track of client-side.
It does not necessarily have to be incremental, but that's what <code>libwayland</code> does and also it's the easiest.</p>
<p>For convenience and efficiency, we always craft the message on the stack and do not allocate dynamic memory.</p>
<p>We first introduce a few utility functions to read and write parts of messages:</p>
<pre><code class="language-c">static void buf_write_u32(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                          uint32_t x) {
  assert(*buf_size + sizeof(x) &lt;= buf_cap);
  assert(((size_t)buf + *buf_size) % sizeof(x) == 0);

  *(uint32_t *)(buf + *buf_size) = x;
  *buf_size += sizeof(x);
}

static void buf_write_u16(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                          uint16_t x) {
  assert(*buf_size + sizeof(x) &lt;= buf_cap);
  assert(((size_t)buf + *buf_size) % sizeof(x) == 0);

  *(uint16_t *)(buf + *buf_size) = x;
  *buf_size += sizeof(x);
}

static void buf_write_string(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                             char *src, uint32_t src_len) {
  assert(*buf_size + src_len &lt;= buf_cap);

  buf_write_u32(buf, buf_size, buf_cap, src_len);
  memcpy(buf + *buf_size, src, roundup_4(src_len));
  *buf_size += roundup_4(src_len);
}

static uint32_t buf_read_u32(char **buf, uint64_t *buf_size) {
  assert(*buf_size &gt;= sizeof(uint32_t));
  assert((size_t)*buf % sizeof(uint32_t) == 0);

  uint32_t res = *(uint32_t *)(*buf);
  *buf += sizeof(res);
  *buf_size -= sizeof(res);

  return res;
}

static uint16_t buf_read_u16(char **buf, uint64_t *buf_size) {
  assert(*buf_size &gt;= sizeof(uint16_t));
  assert((size_t)*buf % sizeof(uint16_t) == 0);

  uint16_t res = *(uint16_t *)(*buf);
  *buf += sizeof(res);
  *buf_size -= sizeof(res);

  return res;
}

static void buf_read_n(char **buf, uint64_t *buf_size, char *dst, uint64_t n) {
  assert(*buf_size &gt;= n);

  memcpy(dst, *buf, n);

  *buf += n;
  *buf_size -= n;
}
</code></pre>
<p>And we finally can send our first message:</p>
<pre><code class="language-c">static uint32_t wayland_wl_display_get_registry(int fd) {
  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_display_object_id);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_wl_display_get_registry_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  if ((int64_t)msg_size != send(fd, msg, msg_size, MSG_DONTWAIT))
    exit(errno);

  printf(&quot;-&gt; wl_display@%u.get_registry: wl_registry=%u\n&quot;,
         wayland_display_object_id, wayland_current_id);

  return wayland_current_id;
}
</code></pre>
<p>And by calling it, we have created our very first Wayland resource!</p>
<p><em>From this point on, the utility functions to send Wayland messages (<code>wayland_*</code>) will not be included in the code snippets for brevity (but you will find all of the code at the end!), just because they all are similar to the one above.</em></p>
<h2>Shared memory: the frame buffer</h2>
<p>To avoid drawing  a frame in our application, and having to send all of the bytes over the socket to the compositor, there is a smarter approach: the buffer should be shared between the two processes, so that no copying is required.</p>
<p>We need to synchronize the access between the two so that presenting the frame does not happen while we are still drawing it, and Wayland has us covered here.</p>
<p>First, we need to create this buffer. We are going to make it easier for us by using a fixed size. Wayland is going to send us 'resize' events, whenever the window size changes, which we will acknowledge and ignore. This is done here just to simplify a bit the article, obviously in a real application, you would resize the buffer.</p>
<p>First, we introduce a struct that will hold all of the client-side state so that we remember which resources we have created so far. We also need a super simple state machine for later to track whether the surface (i.e. the 'frame' data) should be drawn to, as mentioned:</p>
<pre><code class="language-c">typedef enum state_state_t state_state_t;
enum state_state_t {
  STATE_NONE,
  STATE_SURFACE_ACKED_CONFIGURE,
  STATE_SURFACE_ATTACHED,
};

typedef struct state_t state_t;
struct state_t {
  uint32_t wl_registry;
  uint32_t wl_shm;
  uint32_t wl_shm_pool;
  uint32_t wl_buffer;
  uint32_t xdg_wm_base;
  uint32_t xdg_surface;
  uint32_t wl_compositor;
  uint32_t wl_surface;
  uint32_t xdg_toplevel;
  uint32_t stride;
  uint32_t w;
  uint32_t h;
  uint32_t shm_pool_size;
  int shm_fd;
  uint8_t *shm_pool_data;

  state_state_t state;
};
</code></pre>
<p>We use it so in <code>main()</code>:</p>
<pre><code class="language-c">  state_t state = {
      .wl_registry = wayland_wl_display_get_registry(fd),
      .w = 117,
      .h = 150,
      .stride = 117 * color_channels,
  };

  // Single buffering.
  state.shm_pool_size = state.h * state.stride;
</code></pre>
<p>The window is a rectangle, of width <code>w</code> and height <code>h</code>. We will use the color format <code>xrgb8888</code> which is 4 color channels, each taking one bytes, so 4 bytes per pixel. This is one of the two formats that is guaranteed to be supported by the compositor per the specification. The stride counts how many bytes a horizontal row takes: <code>w * 4</code>.</p>
<p>And so, our buffer size for the frame is : <code>w * h * 4</code>. We use single buffering again for simplicity and also because we want to display a static image.</p>
<p>We could choose to use double or even triple buffering, thus respectively doubling or tripling the buffer size. The compositor is none the wiser - we would simply keep a counter client-side that increments each time we render a frame (and wraps around back to 0 when reaching the number of buffers), we would draw in the right location of this big buffer (i.e. at an offset), and attach the right part of the buffer to the surface.
All the Wayland calls would remain the same.</p>
<p>Alright, time to really create this buffer, and not only keep track of its size:</p>
<pre><code class="language-c">static void create_shared_memory_file(uint64_t size, state_t *state) {
  char name[255] = &quot;/&quot;;
  for (uint64_t i = 1; i &lt; cstring_len(name); i++) {
    name[i] = ((double)rand()) / (double)RAND_MAX * 26 + 'a';
  }

  int fd = shm_open(name, O_RDWR | O_EXCL | O_CREAT, 0600);
  if (fd == -1)
    exit(errno);

  assert(shm_unlink(name) != -1);

  if (ftruncate(fd, size) == -1)
    exit(errno);

  state-&gt;shm_pool_data =
      mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  assert(state-&gt;shm_pool_data != NULL);
  state-&gt;shm_fd = fd;
}
</code></pre>
<p>We use <code>shm_open(3)</code> to create a POSIX shared memory object, so that we later can send the corresponding file descriptor to the compositor so that the latter also has access to it. The flags mean:</p>
<ul>
<li><code>O_RDWR</code>: Read-write.</li>
<li><code>O_CREAT</code>: If the file does not exist, create it.</li>
<li><code>O_EXCL</code>: Return an error if the shared memory object with this name already exists (we do not want that another running instance of the application gets by mistake the same memory buffer).</li>
</ul>
<p>We alternatively could use <code>memfd_create(2)</code> which spares us from crafting a unique path but this is Linux specific.</p>
<p>We craft a unique, random path to avoid clashes with other running applications.</p>
<p>Right after, we remove the file on the filesystem with <code>shm_unlink</code> to not leave any traces when the program finishes. Note that the file descriptor remains valid since our process still has the file open (there is a reference counting mechanism in the kernel behind the scenes).</p>
<p>We then resize with <code>ftruncate</code> and memory map this file with <code>mmap(2)</code>, effectively allocating memory, with the <code>MAP_SHARED</code> flag to allow the compositor to also read this memory.</p>
<p>Later, we will send the file descriptor over the UNIX domain socket as ancillary data to the compositor.</p>
<p>Alright, we now have some memory to draw our frame to, but the compositor does not know of it yet. Let's tackle that now.</p>
<h2>Chatting with the compositor</h2>
<p>We are going to exchange messages back and forth over the socket with the compositor. Let's use plain old blocking calls in <code>main</code> like it's the 70's. We read as much as we can from the socket:</p>
<pre><code class="language-c">  while (1) {
    char read_buf[4096] = &quot;&quot;;
    int64_t read_bytes = recv(fd, read_buf, sizeof(read_buf), 0);
    if (read_bytes == -1)
      exit(errno);

    char *msg = read_buf;
    uint64_t msg_len = (uint64_t)read_bytes;

    while (msg_len &gt; 0)
      wayland_handle_message(fd, &amp;state, &amp;msg, &amp;msg_len);
    }
  }
</code></pre>
<p>The read buffer very likely now contains a sequence of various messages, which we parse and handle with
<code>wayland_handle_message</code> eagerly until the end of the buffer.
This might break if a message is spanning two different read buffers - a ring buffer would be more appropriate to handle this case gracefully, but again, for this article this is fine.</p>
<p><code>wayland_handle_message</code> reads the header part of every message as described in the beginning, and reacts to known opcodes and objects:</p>
<pre><code class="language-c">static void wayland_handle_message(int fd, state_t *state, char **msg,
                                   uint64_t *msg_len) {
  assert(*msg_len &gt;= 8);

  uint32_t object_id = buf_read_u32(msg, msg_len);
  assert(object_id &lt;= wayland_current_id);

  uint16_t opcode = buf_read_u16(msg, msg_len);

  uint16_t announced_size = buf_read_u16(msg, msg_len);
  assert(roundup_4(announced_size) &lt;= announced_size);

  uint32_t header_size =
      sizeof(object_id) + sizeof(opcode) + sizeof(announced_size);
  assert(announced_size &lt;= header_size + *msg_len);

  if (object_id == state-&gt;wl_registry &amp;&amp;
      opcode == wayland_wl_registry_event_global) {
      // TODO
  }
  // Following: Lots of `if (opcode == ...) {... } else if (opcode = ...) { ... } [...]`
}
</code></pre>
<h3>Reacting to events: binding interfaces</h3>
<p>At this point we have sent one message to the compositor: <code>wl_display@1.get_registry()</code> thanks to our C function <code>wayland_wl_display_get_registry</code>.
The compositor responds with a series of events, listing the available global objects, such as shared memory support, extension protocols, etc.</p>
<p>Each event contains the interface name, which is a string. Now, in the Wayland protocol, the string length gets padded to a multiple of four, so we have read those padding bytes as well.</p>
<p>If we see a global object that we are interested in, we create one of this type, and record the new id in our <code>state</code> structure for later use. While we're at it, we also handle error events. If the compositor does not like our messages, it will complain with some useful error messages in there:</p>
<pre><code class="language-c">  if (object_id == state-&gt;wl_registry &amp;&amp;
      opcode == wayland_wl_registry_event_global) {
    uint32_t name = buf_read_u32(msg, msg_len);

    uint32_t interface_len = buf_read_u32(msg, msg_len);
    uint32_t padded_interface_len = roundup_4(interface_len);

    char interface[512] = &quot;&quot;;
    assert(padded_interface_len &lt;= cstring_len(interface));

    buf_read_n(msg, msg_len, interface, padded_interface_len);
    assert(interface[interface_len] == 0);

    uint32_t version = buf_read_u32(msg, msg_len);

    printf(&quot;&lt;- wl_registry@%u.global: name=%u interface=%.*s version=%u\n&quot;,
           state-&gt;wl_registry, name, interface_len, interface, version);

    assert(announced_size == sizeof(object_id) + sizeof(announced_size) +
                                 sizeof(opcode) + sizeof(name) +
                                 sizeof(interface_len) + padded_interface_len +
                                 sizeof(version));

    char wl_shm_interface[] = &quot;wl_shm&quot;;
    if (strcmp(wl_shm_interface, interface) == 0) {
      state-&gt;wl_shm = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    char xdg_wm_base_interface[] = &quot;xdg_wm_base&quot;;
    if (strcmp(xdg_wm_base_interface, interface) == 0) {
      state-&gt;xdg_wm_base = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    char wl_compositor_interface[] = &quot;wl_compositor&quot;;
    if (strcmp(wl_compositor_interface, interface) == 0) {
      state-&gt;wl_compositor = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    return;
  } else if (object_id == wayland_display_object_id &amp;&amp; opcode == wayland_wl_display_error_event) {
    uint32_t target_object_id = buf_read_u32(msg, msg_len);
    uint32_t code = buf_read_u32(msg, msg_len);
    char error[512] = &quot;&quot;;
    uint32_t error_len = buf_read_u32(msg, msg_len);
    buf_read_n(msg, msg_len, error, roundup_4(error_len));

    fprintf(stderr, &quot;fatal error: target_object_id=%u code=%u error=%s\n&quot;,
            target_object_id, code, error);
    exit(EINVAL);
  }
</code></pre>
<p>Remember: Since the Wayland protocol is a kind of RPC, we need to create the objects first before calling remote methods on them.</p>
<p>In terms of robustness, we do not have guarantees that every feature (i.e.: interface) we need in our application will be supported by the compositor. It could be a good idea to bail if the interfaces we require are not present.</p>
<h3>Using the interfaces we created</h3>
<p>We can now call methods on the new interfaces to create more entities we will need, namely:</p>
<ul>
<li>A <code>wl_surface</code></li>
<li>A <code>xdg_surface</code></li>
<li>A <code>xdg_toplevel</code></li>
</ul>
<p>The last two being entities from extension protocols, which is inconsequential in our implementation since we do not link against any libraries. This is just the same logic as the other messages and events from the core protocol.</p>
<p>Once we have done that, the surface is setup, and we commit it, to signal to the compositor to atomically apply the changes to the surface.</p>
<pre><code class="language-c">
    while (msg_len &gt; 0)
      wayland_handle_message(fd, &amp;state, &amp;msg, &amp;msg_len);

    if (state.wl_compositor != 0 &amp;&amp; state.wl_shm != 0 &amp;&amp;
        state.xdg_wm_base != 0 &amp;&amp;
        state.wl_surface == 0) { // Bind phase complete, need to create surface.
      assert(state.state == STATE_NONE);

      state.wl_surface = wayland_wl_compositor_create_surface(fd, &amp;state);
      state.xdg_surface = wayland_xdg_wm_base_get_xdg_surface(fd, &amp;state);
      state.xdg_toplevel = wayland_xdg_surface_get_toplevel(fd, &amp;state);
      wayland_wl_surface_commit(fd, &amp;state);
    }
  }
</code></pre>
<h3>Reacting to events: ping/pong</h3>
<p>For some entities, the Wayland compositor will send us a ping message and expect a pong back to ensure our application is responsive and not deadlocked or frozen.</p>
<p>We just have to add one more <code>if</code> to the long list of <code>if</code>s to handle each event from the compositor:</p>
<pre><code class="language-c">if (object_id == state-&gt;xdg_wm_base &amp;&amp;
             opcode == wayland_xdg_wm_base_event_ping) {
    uint32_t ping = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- xdg_wm_base@%u.ping: ping=%u\n&quot;, state-&gt;xdg_wm_base, ping);
    wayland_xdg_wm_base_pong(fd, state, ping);

    return;
  }
</code></pre>
<h3>Reacting to events: configure/ACK configure</h3>
<p>Akin to the previous ping/pong mechanism, we receive a <code>configure</code> event for the <code>xdg_surface</code> and we reply with a <code>ack_configure</code> message.</p>
<p>This is an important milestone since from that point on, we can start rendering our frame! We thus advance our little state machine:</p>
<pre><code class="language-c">if (object_id == state-&gt;xdg_surface &amp;&amp;
             opcode == wayland_xdg_surface_event_configure) {
    uint32_t configure = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- xdg_surface@%u.configure: configure=%u\n&quot;, state-&gt;xdg_surface,
           configure);
    wayland_xdg_surface_ack_configure(fd, state, configure);
    state-&gt;state = STATE_SURFACE_ACKED_CONFIGURE;

    return;
  } 
</code></pre>
<h3>Rendering a frame: the red rectangle</h3>
<p>Once the configure/ack configure step has been completed, we can render a frame.</p>
<p>To do so, we need to create two final entities: a shared memory pool (<code>wl_shm_pool</code>) and a <code>wl_buffer</code> if they do not exist yet.</p>
<p>Finally, we fiddle with the pixel data anyway we want, remembering the color format we picked (XRGB8888), attach the buffer to the surface, and commit the surface.</p>
<p>This acts as synchronization mechanism between the client and the compositor to avoid presenting a half-rendered frame. To sum up:</p>
<ol>
<li>The <code>ack_configure</code> event signals us that we can start rendering the frame</li>
<li>We render the frame client-side by setting the pixel data to whatever we want</li>
<li>We send the <code>attach</code> + <code>commit</code> messages to notify the compositor that the frame is ready to be presented</li>
<li>We advance our state machine to avoid writing to the frame data while the compositor is presenting it</li>
</ol>
<p>So let's show a red rectangle as a warm-up. The alpha component is completely ignored as far as I can tell in this color format:</p>
<pre><code class="language-c">    if (state.state == STATE_SURFACE_ACKED_CONFIGURE) {
      // Render a frame.
      assert(state.wl_surface != 0);
      assert(state.xdg_surface != 0);
      assert(state.xdg_toplevel != 0);

      if (state.wl_shm_pool == 0)
        state.wl_shm_pool = wayland_wl_shm_create_pool(fd, &amp;state);
      if (state.wl_buffer == 0)
        state.wl_buffer = wayland_wl_shm_pool_create_buffer(fd, &amp;state);

      assert(state.shm_pool_data != 0);
      assert(state.shm_pool_size != 0);

      uint32_t *pixels = (uint32_t *)state.shm_pool_data;
      for (uint32_t i = 0; i &lt; state.w * state.h; i++) {
        uint8_t r = 0xff;
        uint8_t g = 0;
        uint8_t b = 0;
        pixels[i] = (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
      }
      wayland_wl_surface_attach(fd, &amp;state);
      wayland_wl_surface_commit(fd, &amp;state);

      state.state = STATE_SURFACE_ATTACHED;
    }

</code></pre>
<p>Result:</p>
<p><img src="wayland-screenshot-red.png" alt="Result, red" /></p>
<h3>Rendering a frame: The Wayland logo</h3>
<p>Let's render something more interesting. We download the <a href="https://wayland.freedesktop.org/wayland.png">Wayland logo</a>, but we do not want to have to deal with a complicated format like PNG (because we then have to uncompress the image data with <code>zlib</code> or similar).</p>
<p>We thus convert it offline to a simpler image format, PPM6, and then embed the raw pixel data in our code as an byte array, skipping over the first 15 bytes which are metadata:</p>
<pre><code class="language-shell">$ file wayland.png
wayland.png: PNG image data, 117 x 150, 8-bit/color RGBA, non-interlaced
$ convert wayland.png wayland.ppm
$ file wayland.ppm
wayland.ppm: Netpbm image data, size = 117 x 150, rawbits, pixmap
$ xxd -s +15 -i wayland.ppm  &gt; wayland-logo.h
$ sed -i 's/wayland_ppm/wayland_logo/g' wayland-logo.h
</code></pre>
<p><em>The resulting C array created by <code>xxd</code> will be named after the input file i.e. <code>wayland_ppm</code>. We rename it with the last command to something more human-readable.</em></p>
<p>The image is now in the <code>RGB</code> format (3 bytes per pixel), which we have to convert to the <code>XRGB</code> format (4 bytes per pixel). Our frame rendering loop becomes:</p>
<pre><code class="language-c">#include &quot;wayland-logo.h&quot;

[...]

      for (uint32_t i = 0; i &lt; state.w * state.h; i++) {
        uint8_t r = wayland_logo[i * 3 + 0];
        uint8_t g = wayland_logo[i * 3 + 1];
        uint8_t b = wayland_logo[i * 3 + 2];
        pixels[i] = (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
      }
</code></pre>
<p>And finally we see the result.</p>
<p>Tiled: <img src="wayland-screenshot-tiled1.png" alt="Result, tiled" /></p>
<p>Floating: <img src="wayland-screenshot-floating.png" alt="Result, floating" /></p>
<p><em>Note: We handle the absolute minimum set of events coming from the compositor to make it work in a simple way. If your particular compositor sends more events, they will have to be read (and possibly ignored). Since the Wayland protocol uses a Tag-Length-Value (TLV) encoding, one can simply skip over <code>&lt;length&gt;</code> bytes if the opcode is unknown. But some events will demand a reply (e.g. ping/pong)!</em></p>
<h2>The end</h2>
<p>It was not that much work to go from zero to a working GUI application, albeit a simplistic one.</p>
<p>Compared to X11, it was a bit more work, but not that much. The barrier of entry is higher but the concepts and architecture are more sound, it seems to me.</p>
<p>The setup is a bit tedious but once this is done, we are in practice going to spend all of our time in the frame rendering code, and perhaps add support for a few additional events (we do not yet support keyboard or mouse events, for example, or animations, which would require us to notify the compositor that a region was 'damaged' meaning modified, and needs re-rendering).</p>
<p>Thus, I have the feeling that Wayland really goes out of the way once the initial scaffolding is done.</p>
<p>As for the next steps, I would like to draw some text, and react to user input events. Maybe even port something like <a href="https://github.com/rxi/microui">microui</a>, which only needs a few drawing routines, to our application.</p>
<blockquote>
<p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&amp;locale.x=en_US">Donate</a></p>
</blockquote>
<h2>Addendum: the full code</h2>
<p><em>Do not forget to generate <code>wayland-logo.h</code> with the aforementioned commands!</em></p>
<p>Compile with: <code>cc -std=c99 wayland.c -Ofast</code>.</p>
<pre><code class="language-c">#define _POSIX_C_SOURCE 200112L
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;unistd.h&gt;

#include &quot;wayland-logo.h&quot;

#define cstring_len(s) (sizeof(s) - 1)

#define roundup_4(n) (((n) + 3) &amp; -4)

static uint32_t wayland_current_id = 1;

static const uint32_t wayland_display_object_id = 1;
static const uint16_t wayland_wl_registry_event_global = 0;
static const uint16_t wayland_shm_pool_event_format = 0;
static const uint16_t wayland_wl_buffer_event_release = 0;
static const uint16_t wayland_xdg_wm_base_event_ping = 0;
static const uint16_t wayland_xdg_toplevel_event_configure = 0;
static const uint16_t wayland_xdg_toplevel_event_close = 1;
static const uint16_t wayland_xdg_surface_event_configure = 0;
static const uint16_t wayland_wl_display_get_registry_opcode = 1;
static const uint16_t wayland_wl_registry_bind_opcode = 0;
static const uint16_t wayland_wl_compositor_create_surface_opcode = 0;
static const uint16_t wayland_xdg_wm_base_pong_opcode = 3;
static const uint16_t wayland_xdg_surface_ack_configure_opcode = 4;
static const uint16_t wayland_wl_shm_create_pool_opcode = 0;
static const uint16_t wayland_xdg_wm_base_get_xdg_surface_opcode = 2;
static const uint16_t wayland_wl_shm_pool_create_buffer_opcode = 0;
static const uint16_t wayland_wl_surface_attach_opcode = 1;
static const uint16_t wayland_xdg_surface_get_toplevel_opcode = 1;
static const uint16_t wayland_wl_surface_commit_opcode = 6;
static const uint16_t wayland_wl_display_error_event = 0;
static const uint32_t wayland_format_xrgb8888 = 1;
static const uint32_t wayland_header_size = 8;
static const uint32_t color_channels = 4;

typedef enum state_state_t state_state_t;
enum state_state_t {
  STATE_NONE,
  STATE_SURFACE_ACKED_CONFIGURE,
  STATE_SURFACE_ATTACHED,
};

typedef struct state_t state_t;
struct state_t {
  uint32_t wl_registry;
  uint32_t wl_shm;
  uint32_t wl_shm_pool;
  uint32_t wl_buffer;
  uint32_t xdg_wm_base;
  uint32_t xdg_surface;
  uint32_t wl_compositor;
  uint32_t wl_surface;
  uint32_t xdg_toplevel;
  uint32_t stride;
  uint32_t w;
  uint32_t h;
  uint32_t shm_pool_size;
  int shm_fd;
  uint8_t *shm_pool_data;

  state_state_t state;
};

static int wayland_display_connect() {
  char *xdg_runtime_dir = getenv(&quot;XDG_RUNTIME_DIR&quot;);
  if (xdg_runtime_dir == NULL)
    return EINVAL;

  uint64_t xdg_runtime_dir_len = strlen(xdg_runtime_dir);

  struct sockaddr_un addr = {.sun_family = AF_UNIX};
  assert(xdg_runtime_dir_len &lt;= cstring_len(addr.sun_path));
  uint64_t socket_path_len = 0;

  memcpy(addr.sun_path, xdg_runtime_dir, xdg_runtime_dir_len);
  socket_path_len += xdg_runtime_dir_len;

  addr.sun_path[socket_path_len++] = '/';

  char *wayland_display = getenv(&quot;WAYLAND_DISPLAY&quot;);
  if (wayland_display == NULL) {
    char wayland_display_default[] = &quot;wayland-0&quot;;
    uint64_t wayland_display_default_len = cstring_len(wayland_display_default);

    memcpy(addr.sun_path + socket_path_len, wayland_display_default,
           wayland_display_default_len);
    socket_path_len += wayland_display_default_len;
  } else {
    uint64_t wayland_display_len = strlen(wayland_display);
    memcpy(addr.sun_path + socket_path_len, wayland_display,
           wayland_display_len);
    socket_path_len += wayland_display_len;
  }

  int fd = socket(AF_UNIX, SOCK_STREAM, 0);
  if (fd == -1)
    exit(errno);

  if (connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1)
    exit(errno);

  return fd;
}

static void buf_write_u32(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                          uint32_t x) {
  assert(*buf_size + sizeof(x) &lt;= buf_cap);
  assert(((size_t)buf + *buf_size) % sizeof(x) == 0);

  *(uint32_t *)(buf + *buf_size) = x;
  *buf_size += sizeof(x);
}

static void buf_write_u16(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                          uint16_t x) {
  assert(*buf_size + sizeof(x) &lt;= buf_cap);
  assert(((size_t)buf + *buf_size) % sizeof(x) == 0);

  *(uint16_t *)(buf + *buf_size) = x;
  *buf_size += sizeof(x);
}

static void buf_write_string(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                             char *src, uint32_t src_len) {
  assert(*buf_size + src_len &lt;= buf_cap);

  buf_write_u32(buf, buf_size, buf_cap, src_len);
  memcpy(buf + *buf_size, src, roundup_4(src_len));
  *buf_size += roundup_4(src_len);
}

static uint32_t buf_read_u32(char **buf, uint64_t *buf_size) {
  assert(*buf_size &gt;= sizeof(uint32_t));
  assert((size_t)*buf % sizeof(uint32_t) == 0);

  uint32_t res = *(uint32_t *)(*buf);
  *buf += sizeof(res);
  *buf_size -= sizeof(res);

  return res;
}

static uint16_t buf_read_u16(char **buf, uint64_t *buf_size) {
  assert(*buf_size &gt;= sizeof(uint16_t));
  assert((size_t)*buf % sizeof(uint16_t) == 0);

  uint16_t res = *(uint16_t *)(*buf);
  *buf += sizeof(res);
  *buf_size -= sizeof(res);

  return res;
}

static void buf_read_n(char **buf, uint64_t *buf_size, char *dst, uint64_t n) {
  assert(*buf_size &gt;= n);

  memcpy(dst, *buf, n);

  *buf += n;
  *buf_size -= n;
}

static uint32_t wayland_wl_display_get_registry(int fd) {
  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_display_object_id);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_wl_display_get_registry_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_display@%u.get_registry: wl_registry=%u\n&quot;,
         wayland_display_object_id, wayland_current_id);

  return wayland_current_id;
}

static uint32_t wayland_wl_registry_bind(int fd, uint32_t registry,
                                         uint32_t name, char *interface,
                                         uint32_t interface_len,
                                         uint32_t version) {
  uint64_t msg_size = 0;
  char msg[512] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), registry);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_wl_registry_bind_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(name) + sizeof(interface_len) +
      roundup_4(interface_len) + sizeof(version) + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), name);
  buf_write_string(msg, &amp;msg_size, sizeof(msg), interface, interface_len);
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), version);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  assert(msg_size == roundup_4(msg_size));

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_registry@%u.bind: name=%u interface=%.*s version=%u\n&quot;,
         registry, name, interface_len, interface, version);

  return wayland_current_id;
}

static uint32_t wayland_wl_compositor_create_surface(int fd, state_t *state) {
  assert(state-&gt;wl_compositor &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_compositor);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_wl_compositor_create_surface_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_compositor@%u.create_surface: wl_surface=%u\n&quot;,
         state-&gt;wl_compositor, wayland_current_id);

  return wayland_current_id;
}

static void create_shared_memory_file(uint64_t size, state_t *state) {
  char name[255] = &quot;/&quot;;
  for (uint64_t i = 1; i &lt; cstring_len(name); i++) {
    name[i] = ((double)rand()) / (double)RAND_MAX * 26 + 'a';
  }

  int fd = shm_open(name, O_RDWR | O_EXCL | O_CREAT, 0600);
  if (fd == -1)
    exit(errno);

  assert(shm_unlink(name) != -1);

  if (ftruncate(fd, size) == -1)
    exit(errno);

  state-&gt;shm_pool_data =
      mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  assert(state-&gt;shm_pool_data != NULL);
  state-&gt;shm_fd = fd;
}

static void wayland_xdg_wm_base_pong(int fd, state_t *state, uint32_t ping) {
  assert(state-&gt;xdg_wm_base &gt; 0);
  assert(state-&gt;wl_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;xdg_wm_base);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_xdg_wm_base_pong_opcode);

  uint16_t msg_announced_size = wayland_header_size + sizeof(ping);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), ping);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; xdg_wm_base@%u.pong: ping=%u\n&quot;, state-&gt;xdg_wm_base, ping);
}

static void wayland_xdg_surface_ack_configure(int fd, state_t *state,
                                              uint32_t configure) {
  assert(state-&gt;xdg_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;xdg_surface);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_xdg_surface_ack_configure_opcode);

  uint16_t msg_announced_size = wayland_header_size + sizeof(configure);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), configure);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; xdg_surface@%u.ack_configure: configure=%u\n&quot;, state-&gt;xdg_surface,
         configure);
}

static uint32_t wayland_wl_shm_create_pool(int fd, state_t *state) {
  assert(state-&gt;shm_pool_size &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_shm);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_wl_shm_create_pool_opcode);

  uint16_t msg_announced_size = wayland_header_size +
                                sizeof(wayland_current_id) +
                                sizeof(state-&gt;shm_pool_size);

  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;shm_pool_size);

  assert(roundup_4(msg_size) == msg_size);

  // Send the file descriptor as ancillary data.
  // UNIX/Macros monstrosities ahead.
  char buf[CMSG_SPACE(sizeof(state-&gt;shm_fd))] = &quot;&quot;;

  struct iovec io = {.iov_base = msg, .iov_len = msg_size};
  struct msghdr socket_msg = {
      .msg_iov = &amp;io,
      .msg_iovlen = 1,
      .msg_control = buf,
      .msg_controllen = sizeof(buf),
  };

  struct cmsghdr *cmsg = CMSG_FIRSTHDR(&amp;socket_msg);
  cmsg-&gt;cmsg_level = SOL_SOCKET;
  cmsg-&gt;cmsg_type = SCM_RIGHTS;
  cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(state-&gt;shm_fd));

  *((int *)CMSG_DATA(cmsg)) = state-&gt;shm_fd;
  socket_msg.msg_controllen = CMSG_SPACE(sizeof(state-&gt;shm_fd));

  if (sendmsg(fd, &amp;socket_msg, 0) == -1)
    exit(errno);

  printf(&quot;-&gt; wl_shm@%u.create_pool: wl_shm_pool=%u\n&quot;, state-&gt;wl_shm,
         wayland_current_id);

  return wayland_current_id;
}

static uint32_t wayland_xdg_wm_base_get_xdg_surface(int fd, state_t *state) {
  assert(state-&gt;xdg_wm_base &gt; 0);
  assert(state-&gt;wl_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;xdg_wm_base);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_xdg_wm_base_get_xdg_surface_opcode);

  uint16_t msg_announced_size = wayland_header_size +
                                sizeof(wayland_current_id) +
                                sizeof(state-&gt;wl_surface);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_surface);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; xdg_wm_base@%u.get_xdg_surface: xdg_surface=%u wl_surface=%u\n&quot;,
         state-&gt;xdg_wm_base, wayland_current_id, state-&gt;wl_surface);

  return wayland_current_id;
}

static uint32_t wayland_wl_shm_pool_create_buffer(int fd, state_t *state) {
  assert(state-&gt;wl_shm_pool &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_shm_pool);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_wl_shm_pool_create_buffer_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id) + sizeof(uint32_t) * 5;
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  uint32_t offset = 0;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), offset);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;w);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;h);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;stride);

  uint32_t format = wayland_format_xrgb8888;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), format);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_shm_pool@%u.create_buffer: wl_buffer=%u\n&quot;, state-&gt;wl_shm_pool,
         wayland_current_id);

  return wayland_current_id;
}

static void wayland_wl_surface_attach(int fd, state_t *state) {
  assert(state-&gt;wl_surface &gt; 0);
  assert(state-&gt;wl_buffer &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_surface);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_wl_surface_attach_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(state-&gt;wl_buffer) + sizeof(uint32_t) * 2;
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_buffer);

  uint32_t x = 0, y = 0;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), x);
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), y);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_surface@%u.attach: wl_buffer=%u\n&quot;, state-&gt;wl_surface,
         state-&gt;wl_buffer);
}

static uint32_t wayland_xdg_surface_get_toplevel(int fd, state_t *state) {
  assert(state-&gt;xdg_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;xdg_surface);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_xdg_surface_get_toplevel_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; xdg_surface@%u.get_toplevel: xdg_toplevel=%u\n&quot;,
         state-&gt;xdg_surface, wayland_current_id);

  return wayland_current_id;
}

static void wayland_wl_surface_commit(int fd, state_t *state) {
  assert(state-&gt;wl_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_surface);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_wl_surface_commit_opcode);

  uint16_t msg_announced_size = wayland_header_size;
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_surface@%u.commit: \n&quot;, state-&gt;wl_surface);
}

static void wayland_handle_message(int fd, state_t *state, char **msg,
                                   uint64_t *msg_len) {
  assert(*msg_len &gt;= 8);

  uint32_t object_id = buf_read_u32(msg, msg_len);
  assert(object_id &lt;= wayland_current_id);

  uint16_t opcode = buf_read_u16(msg, msg_len);

  uint16_t announced_size = buf_read_u16(msg, msg_len);
  assert(roundup_4(announced_size) &lt;= announced_size);

  uint32_t header_size =
      sizeof(object_id) + sizeof(opcode) + sizeof(announced_size);
  assert(announced_size &lt;= header_size + *msg_len);

  if (object_id == state-&gt;wl_registry &amp;&amp;
      opcode == wayland_wl_registry_event_global) {
    uint32_t name = buf_read_u32(msg, msg_len);

    uint32_t interface_len = buf_read_u32(msg, msg_len);
    uint32_t padded_interface_len = roundup_4(interface_len);

    char interface[512] = &quot;&quot;;
    assert(padded_interface_len &lt;= cstring_len(interface));

    buf_read_n(msg, msg_len, interface, padded_interface_len);
    assert(interface[interface_len] == 0);

    uint32_t version = buf_read_u32(msg, msg_len);

    printf(&quot;&lt;- wl_registry@%u.global: name=%u interface=%.*s version=%u\n&quot;,
           state-&gt;wl_registry, name, interface_len, interface, version);

    assert(announced_size == sizeof(object_id) + sizeof(announced_size) +
                                 sizeof(opcode) + sizeof(name) +
                                 sizeof(interface_len) + padded_interface_len +
                                 sizeof(version));

    char wl_shm_interface[] = &quot;wl_shm&quot;;
    if (strcmp(wl_shm_interface, interface) == 0) {
      state-&gt;wl_shm = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    char xdg_wm_base_interface[] = &quot;xdg_wm_base&quot;;
    if (strcmp(xdg_wm_base_interface, interface) == 0) {
      state-&gt;xdg_wm_base = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    char wl_compositor_interface[] = &quot;wl_compositor&quot;;
    if (strcmp(wl_compositor_interface, interface) == 0) {
      state-&gt;wl_compositor = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    return;
  } else if (object_id == wayland_display_object_id &amp;&amp;
             opcode == wayland_wl_display_error_event) {
    uint32_t target_object_id = buf_read_u32(msg, msg_len);
    uint32_t code = buf_read_u32(msg, msg_len);
    char error[512] = &quot;&quot;;
    uint32_t error_len = buf_read_u32(msg, msg_len);
    buf_read_n(msg, msg_len, error, roundup_4(error_len));

    fprintf(stderr, &quot;fatal error: target_object_id=%u code=%u error=%s\n&quot;,
            target_object_id, code, error);
    exit(EINVAL);
  } else if (object_id == state-&gt;wl_shm &amp;&amp;
             opcode == wayland_shm_pool_event_format) {

    uint32_t format = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- wl_shm: format=%#x\n&quot;, format);
    return;
  } else if (object_id == state-&gt;wl_buffer &amp;&amp;
             opcode == wayland_wl_buffer_event_release) {
    // No-op, for now.

    printf(&quot;&lt;- xdg_wl_buffer@%u.release\n&quot;, state-&gt;wl_buffer);
    return;
  } else if (object_id == state-&gt;xdg_wm_base &amp;&amp;
             opcode == wayland_xdg_wm_base_event_ping) {
    uint32_t ping = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- xdg_wm_base@%u.ping: ping=%u\n&quot;, state-&gt;xdg_wm_base, ping);
    wayland_xdg_wm_base_pong(fd, state, ping);

    return;
  } else if (object_id == state-&gt;xdg_toplevel &amp;&amp;
             opcode == wayland_xdg_toplevel_event_configure) {
    uint32_t w = buf_read_u32(msg, msg_len);
    uint32_t h = buf_read_u32(msg, msg_len);
    uint32_t len = buf_read_u32(msg, msg_len);
    char buf[256] = &quot;&quot;;
    assert(len &lt;= sizeof(buf));
    buf_read_n(msg, msg_len, buf, len);

    printf(&quot;&lt;- xdg_toplevel@%u.configure: w=%u h=%u states[%u]\n&quot;,
           state-&gt;xdg_toplevel, w, h, len);

    return;
  } else if (object_id == state-&gt;xdg_surface &amp;&amp;
             opcode == wayland_xdg_surface_event_configure) {
    uint32_t configure = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- xdg_surface@%u.configure: configure=%u\n&quot;, state-&gt;xdg_surface,
           configure);
    wayland_xdg_surface_ack_configure(fd, state, configure);
    state-&gt;state = STATE_SURFACE_ACKED_CONFIGURE;

    return;
  } else if (object_id == state-&gt;xdg_toplevel &amp;&amp;
             opcode == wayland_xdg_toplevel_event_close) {
    printf(&quot;&lt;- xdg_toplevel@%u.close\n&quot;, state-&gt;xdg_toplevel);
    exit(0);
  }

  fprintf(stderr, &quot;object_id=%u opcode=%u msg_len=%lu\n&quot;, object_id, opcode,
          *msg_len);
  assert(0 &amp;&amp; &quot;todo&quot;);
}

int main() {
  struct timeval tv = {0};
  assert(gettimeofday(&amp;tv, NULL) != -1);
  srand(tv.tv_sec * 1000 * 1000 + tv.tv_usec);

  int fd = wayland_display_connect();

  state_t state = {
      .wl_registry = wayland_wl_display_get_registry(fd),
      .w = 117,
      .h = 150,
      .stride = 117 * color_channels,
  };

  // Single buffering.
  state.shm_pool_size = state.h * state.stride;
  create_shared_memory_file(state.shm_pool_size, &amp;state);

  while (1) {
    char read_buf[4096] = &quot;&quot;;
    int64_t read_bytes = recv(fd, read_buf, sizeof(read_buf), 0);
    if (read_bytes == -1)
      exit(errno);

    char *msg = read_buf;
    uint64_t msg_len = (uint64_t)read_bytes;

    while (msg_len &gt; 0)
      wayland_handle_message(fd, &amp;state, &amp;msg, &amp;msg_len);

    if (state.wl_compositor != 0 &amp;&amp; state.wl_shm != 0 &amp;&amp;
        state.xdg_wm_base != 0 &amp;&amp;
        state.wl_surface == 0) { // Bind phase complete, need to create surface.
      assert(state.state == STATE_NONE);

      state.wl_surface = wayland_wl_compositor_create_surface(fd, &amp;state);
      state.xdg_surface = wayland_xdg_wm_base_get_xdg_surface(fd, &amp;state);
      state.xdg_toplevel = wayland_xdg_surface_get_toplevel(fd, &amp;state);
      wayland_wl_surface_commit(fd, &amp;state);
    }

    if (state.state == STATE_SURFACE_ACKED_CONFIGURE) {
      // Render a frame.
      assert(state.wl_surface != 0);
      assert(state.xdg_surface != 0);
      assert(state.xdg_toplevel != 0);

      if (state.wl_shm_pool == 0)
        state.wl_shm_pool = wayland_wl_shm_create_pool(fd, &amp;state);
      if (state.wl_buffer == 0)
        state.wl_buffer = wayland_wl_shm_pool_create_buffer(fd, &amp;state);

      assert(state.shm_pool_data != 0);
      assert(state.shm_pool_size != 0);

      uint32_t *pixels = (uint32_t *)state.shm_pool_data;
      for (uint32_t i = 0; i &lt; state.w * state.h; i++) {
        uint8_t r = wayland_logo[i * 3 + 0];
        uint8_t g = wayland_logo[i * 3 + 1];
        uint8_t b = wayland_logo[i * 3 + 2];
        pixels[i] = (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
      }
      wayland_wl_surface_attach(fd, &amp;state);
      wayland_wl_surface_commit(fd, &amp;state);

      state.state = STATE_SURFACE_ATTACHED;
    }
  }
}

</code></pre>
</div>
</body>
</html>

]]>
    </content>
     </entry>

     <entry>
       <title>Learn x86-64 assembly by writing a GUI from scratch</title>
       <link href="/blog/x11_x64.html"/>
       <id>urn:uuid:fa923100-dd66-531e-bdab-8eed3527960f</id>
       <updated>2023-12-15T11:33:55Z</updated>
<content type="html">
      <![CDATA[
			<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/highlight.min.js"></script>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/languages/x86asm.min.js"></script>
<script>
window.addEventListener("load", (event) => {
  hljs.highlightAll();
});
</script>
</head>
<body>
<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
    </ul>
</div>
<div class="body">
<h1>Learn x86-64 assembly by writing a GUI from scratch</h1>
<p>Most people think assembly is only to be used to write toy programs for learning purposes, or to write a highly optimized version of a specific function inside a codebase written in a high-level language.</p>
<p>Well, what if we wrote a whole program in assembly that opens a GUI window? It will be the hello world of the GUI world, but that still counts. Here is what we are working towards:</p>
<p><img src="x11_x64_final.png" alt="Result" /></p>
<p>I wanted to expand my knowledge of assembly and by doing something fun and motivating. It all originated from the observation that so many program binaries today are very big, often over 30 Mib (!), and I asked myself: How small a binary can be for a (very simplistic) GUI? Well, it turns out, very little. Spoiler alert: around 1 KiB!</p>
<blockquote>
<p>I am by no means an expert in assembly or in X11. I just hope to provide an entertaining, approachable article, something a beginner can understand. Something I wished I had found when I was learning those topics. If you spot an error, please open a <a href="https://github.com/gaultier/blog">Github issue</a>!</p>
</blockquote>
<p><em>This article has been discussed on <a href="https://news.ycombinator.com/item?id=36153237">Hacker News</a> and <a href="https://lobste.rs/s/dvtzfl/learn_x86_64_assembly_by_writing_gui_from">Lobsters</a>.</em></p>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#what-do-we-need">What do we need?</a></li>
<li><a href="#x11-basics">X11 basics</a></li>
<li><a href="#main-in-x64-assembly">Main in x64 assembly</a></li>
<li><a href="#a-stack-primer">A stack primer</a>
<ul>
<li><a href="#a-small-stack-example">A small stack example</a></li>
</ul>
</li>
<li><a href="#opening-a-socket">Opening a socket</a></li>
<li><a href="#connecting-to-the-server">Connecting to the server</a></li>
<li><a href="#sending-data-over-the-socket">Sending data over the socket</a></li>
<li><a href="#generating-ids">Generating ids</a></li>
<li><a href="#opening-a-font">Opening a font</a></li>
<li><a href="#creating-a-graphical-context">Creating a graphical context</a></li>
<li><a href="#creating-the-window">Creating the window</a></li>
<li><a href="#mapping-the-window">Mapping the window</a></li>
<li><a href="#polling-for-server-messages">Polling for server messages</a></li>
<li><a href="#drawing-text">Drawing text</a></li>
<li><a href="#the-end">The end</a></li>
<li><a href="#addendum-the-full-code">Addendum: the full code</a></li>
</ul>
<h2>What do we need?</h2>
<p>I will be using the <code>nasm</code> assembler which is simple, cross-platform, fast, and has quite a readable syntax.</p>
<p>For the GUI, I will be using X11 since I am based on Linux and it has some interesting properties that make it easy to do without external libraries. If you are running Wayland, it should work with XWayland out of the box (<em>EDIT: After testing it, I can confirm it does work</em>), and perhaps also on macOS with XQuartz, but I have not tested those (for macOS, remember to tell <code>nasm</code> to use the <code>macho64</code> format, since macOS does not use the ELF format! Also, the stock linker on macOS does not support <code>-static</code>.).</p>
<p>Note that the only difference between *nix operating systems in the context of this program is the system call values. Since I am based on Linux I will be using the Linux system call values, but 'porting' this program to, say, FreeBSD, would only require to change those values, possibly using the <code>nasm</code> macros:</p>
<pre><code class="language-x86asm">%ifdef linux
  %define SYSCALL_EXIT 60
%elifdef freebsd
  %define SYSCALL_EXIT 1
%endif
</code></pre>
<blockquote>
<p><code>%define</code> and its variants are part of the macro system in <code>nasm</code>, which is powerful but we will only use it here to define constants, just like in C: <code>#define FOO 3</code>.</p>
</blockquote>
<p>No need for additional tooling to cross-compile, issues with dynamic libraries, libc differences, etc. Just compile on Linux by defining the right variable on the command line, send the binary to your friend on FreeBSD, and it just works(tm). That's refreshing.</p>
<blockquote>
<p>Some readers have rightfully pointed out that Linux is the only mainstream operating system that officially provides a stable userland ABI, other OSes often break their ABI from (major) version to version and recommend all programs to link to a library (e.g. <code>libSystem</code> in the case of macOS). That layer guarantees API stability, and acts as a insulation layer from breaking changes in the ABI. In practice, for common system calls such as the ones we use here, they very rarely break, but doing more exotic things may break in the future. That actually happened to the Go project in the past on macOS! The solution if that happens is to simply recompile the program on the new version of the OS.</p>
</blockquote>
<p>So let's dive in!</p>
<h2>X11 basics</h2>
<p>X11 is a server accessible over the network that handles windowing and rendering inside those windows. A client opens a socket, connects to the server, and sends commands in a specific format to open a window, draw shapes, text, etc. The server sends message about errors or events to the client.</p>
<p>Most applications will want to use <code>libX11</code> or <code>libxcb</code> which offer a C API, but we want to do that ourselves.</p>
<p>Where the server lives is actually not relevant for a client, it might run on the same machine or in a data center far far away. Of course, in the context of a desktop computer in 2023, it will be running on the same machine, but that's a detail.</p>
<p>The <a href="https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html">official documentation</a> is pretty good, so in doubt we can refer to it.</p>
<h2>Main in x64 assembly</h2>
<p>Let's start slow with minimal program that simply exits with 0, and build from there.</p>
<p>First, we tell nasm we are writing a 64 bit program and that we target x86_64. Then, we need a main function, which we call <code>_start</code> and needs to be visible since this is the entry point of our program (hence the <code>global</code> keyword):</p>
<pre><code class="language-x86asm">; Comments start with a semicolon!
BITS 64 ; 64 bits.
CPU X64 ; Target the x86_64 family of CPUs.

section .text
global _start
_start:
  xor rax, rax ; Set rax to 0. Not actually needed, it's just to avoid having an empty body.
</code></pre>
<p><code>section .text</code> is telling <code>nasm</code> and the linker, that what follows is code that should be placed in the text section of the executable.</p>
<p>We will soon have a <code>section .data</code> for our global variables.</p>
<p>Note that those section usually get mapped by the OS to different pages in memory with different permissions (visible with <code>readelf -l</code>) so that the text section is not writable and the data section is not executable, but that varies from OS to OS.</p>
<p>The <code>_start</code> function has a body that does nothing for now, but not for long. The actual name of the main function is actually up to us, it's just that <code>start</code> or <code>_start</code> is usual.</p>
<p>We build and run our little program like this:</p>
<pre><code class="language-sh">$ nasm -f elf64 -g main.nasm &amp;&amp; ld main.o -static -o main
</code></pre>
<p><code>nasm</code> actually only produces an object file, so to get an executable out of it, we need to invoke the linker <code>ld</code>. The flag <code>-g</code> is telling <code>nasm</code> to produce debugging information which is immensely useful when writing raw assembly, since firing the debugger is often our only recourse in face of a bug.</p>
<p><em>To remove the debugging information, we can pass <code>-s</code> to the linker, for example when we are about to ship our program and want to save a few KiB.</em></p>
<p>We finally have an executable:</p>
<pre><code class="language-sh">$ file ./main
main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
</code></pre>
<p>We can see the different sections with <code>readelf -a ./main</code>, and it tells us that the <code>.text</code> section, which contains our code, is only 3 bytes long.</p>
<p>Now, if we try to run our program, it will segfault. That's because we are expected by the operating system to exit (using the exit system call) ourselves (otherwise the CPU will keep executing whatever comes after our entry point until it hits an unmapped page, triggering a segfault). That's what libc does for us in C programs, so let's handle that:</p>
<pre><code class="language-x86asm">%define SYSCALL_EXIT 60

global _start:
_start:
  mov rax, SYSCALL_EXIT
  mov rdi, 0
  syscall
</code></pre>
<blockquote>
<p><code>nasm</code> uses the Intel syntax: <code>&lt;instruction&gt; &lt;destination&gt;, &lt;source&gt;</code>, so <code>mov rdi, 0</code> puts 0 into the register <code>rdi</code>. Other assemblers use the AT&amp;T syntax which swaps the source and destination. My advice: pick one syntax and one assembler and stick to it, both syntaxes are fine and most tools have some support for both.</p>
</blockquote>
<p>Following the System V ABI, which is required on Linux and other Unices for system calls, invoking a system call requires us to put the system call code in the register <code>rax</code>, the parameters to the syscall (up to 6) in the registers <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code>, and additional parameters, if any, on the stack (which will not happen in this program so we can forget about it).
We then use the instruction <code>syscall</code> and check <code>rax</code> for the return value, <code>0</code> usually meaning: no error.</p>
<p><em>Note that Linux (and perhaps other Unices?) has a 'fun' difference, which is that the fourth parameter of a system call is actually passed using the register <code>r10</code>.</em></p>
<blockquote>
<p>Astute readers have pointed out that this is the case across all OSes and documented in the x86_64 architecture supplement of the System V ABI. The more you know! That's only for system calls, though, regular functions still use <code>rcx</code> for the fourth parameter.</p>
</blockquote>
<blockquote>
<p>Note that the System V ABI is required when making system calls and when interfacing with C but we are free to use whatever conventions we want in our own assembly code. For a long time, Go was using a different calling convention than the System V ABI, for example, when calling functions (passing arguments on the stack). Most tools (debuggers, profilers) expect the System V ABI though, so I recommend sticking to it.</p>
</blockquote>
<p>Back to our program: when we run it, we see...nothing. That's because everything went well, true to the UNIX philosophy!</p>
<p>We can check the exit code:</p>
<pre><code class="language-sh">$ ./main; echo $?
0
</code></pre>
<p>Changing <code>mov rdi, 0</code> to <code>mov rdi, 8</code> will now result in:</p>
<pre><code class="language-sh">$ ./main; echo $?
8
</code></pre>
<p>Another way to observe system calls made by a program is with <code>strace</code>, which will also prove very useful when troubleshooting. On some BSD, its equivalent is <code>truss</code> or <code>dtruss</code>.</p>
<pre><code class="language-sh">
$ strace ./main
execve(&quot;./main&quot;, [&quot;./main&quot;], 0x7ffc60e6bf10 /* 60 vars */) = 0
exit(8)                                 = ?
+++ exited with 8 +++

</code></pre>
<p>Let's change it back to 0 and continue.</p>
<h2>A stack primer</h2>
<p>Before we can continue, we need to know the basics of how the stack works in assembly since we have no friendly compiler to do that for us.</p>
<p><strong>The three most important things about the stack are:</strong></p>
<ul>
<li>It grows downwards: to reserve more space on the stack, we decrease the value of <code>rsp</code></li>
<li>A function must restore the stack pointer to its original value before the function returns, meaning, either remember the original value and set <code>rsp</code> to this, or, match every decrement by an increment of the same value.</li>
<li>Before a function call, the stack pointer needs to be 16 bytes aligned, according to the System V ABI. Also, at the very beginning of a function, the stack pointer value is: <code>16*N + 8</code>. That's because before the function call, its value was 16 byte aligned, i.e. <code>16*N</code>, and the <code>call</code> instruction pushes on the stack the current location (the register <code>rip</code>, which is 8 bytes long), to know where to jump when the called function returns.</li>
</ul>
<p>Not abiding by those rules will result in nasty crashes, so be warned. That's because the location of where to jump when the function returns will be likely overwritten and the program will jump to the wrong location. That, or the stack content will be overwritten and the program will operate on wrong values. Bad either way.</p>
<h3>A small stack example</h3>
<p>Let's write a function that prints <code>hello</code> to the standard out, using the stack, to learn the ropes. An easier way would be to store this static string in the <code>.rodata</code> section, but that would not teach us anything about the stack.</p>
<p>We need to reserve (at least) 5 bytes on the stack, since that's the length in bytes of <code>hello</code>.</p>
<p>The stack looks like this:</p>
<table>
  <tr> <td align="left">...</td> </tr>
  <tr> <td align="left" >rbp</td> </tr>
  <tr> <td align="left" >o</td> </tr>
  <tr> <td align="left" >l</td> </tr>
  <tr> <td align="left" >l</td> </tr>
  <tr> <td align="left" >e</td> </tr>
  <tr> <td align="left" >h</td> </tr>
</table>
<p>And <code>rsp</code> points to the bottom of it.</p>
<p>Here's how we access each element:</p>
<table>
  <thead>
  <tr> <th>Memory location (example)</th> <th>Assembly code</th> <th align="left">Stack element</th> </tr>
  </thead>
  <tbody>
  <tr> <td>0x1016</td> <td></td> <td align="left">...</td> </tr>
  <tr> <td>0x1015</td> <td>rsp + 5</td> <td align="left" >rbp</td> </tr>
  <tr> <td>0x1014</td> <td>rsp + 4</td> <td align="left" >o</td> </tr>
  <tr> <td>0x1013</td> <td>rsp + 3</td> <td align="left" >l</td> </tr>
  <tr> <td>0x1012</td> <td>rsp + 2</td> <td align="left" >l</td> </tr>
  <tr> <td>0x1011</td> <td>rsp + 1</td> <td align="left" >e</td> </tr>
  <tr> <td>0x1010</td> <td>rsp + 0</td> <td align="left" >h</td> </tr>
  </tbody>
</table>
<p>We then pass the address on the stack of the beginning of the string to the <code>write</code> syscall, as well as its length:</p>
<pre><code>%define SYSCALL_WRITE 1
%define STDOUT 1

print_hello:
  push rbp ; Save rbp on the stack to be able to restore it at the end of the function.
  mov rbp, rsp ; Set rbp to rsp

  sub rsp, 5 ; Reserve 5 bytes of space on the stack.
  mov BYTE [rsp + 0], 'h' ; Set each byte on the stack to a string character.
  mov BYTE [rsp + 1], 'e'
  mov BYTE [rsp + 2], 'l'
  mov BYTE [rsp + 3], 'l'
  mov BYTE [rsp + 4], 'o'

  ; Make the write syscall
  mov rax, SYSCALL_WRITE
  mov rdi, STDOUT ; Write to stdout.
  lea rsi, [rsp] ; Address on the stack of the string.
  mov rdx, 5 ; Pass the length of the string which is 5.
  syscall

  add rsp, 5 ; Restore the stack to its original value.

  pop rbp ; Restore rbp
  ret
</code></pre>
<blockquote>
<p><code>lea destination, source</code> loads the effective address of the source into the destination, which is how C pointers are implemented. To dereference a memory location we use square brackets. So, assuming we just have loaded an address into <code>rdi</code> with <code>lea</code>, e.g. <code>lea rdi, [hello_world]</code>, and we want to store the value at the address into <code>rax</code>, we do: <code>mov rax, [rdi]</code>. We usually have to tell <code>nasm</code> how many bytes to dereference with <code>BYTE</code>, <code>WORD</code>, <code>DWORD</code>, <code>QWORD</code> so: <code>mov rax, DWORD [rdi]</code>, because <code>nasm</code> does not keep track of the sizes of each variable. That's also what the C compiler does when we dereference a <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, and <code>int64_t</code> pointer, respectively.</p>
</blockquote>
<p>There is a lot to unpack here.</p>
<p>First, what is <code>rbp</code>? That's a register like any other. But, you can choose to follow the convention of not using this register like the other registers, to store arbitrary values, and instead, use it to store a linked list of call frames. That's a lot of words.</p>
<p>Basically, at the very beginning of a function, the value of <code>rbp</code> is stored on the stack (that's <code>push rbp</code>). Since <code>rbp</code> stores an address (the address of the frame that's called us), we are storing on the stack the address of the caller in a known location.</p>
<p>Immediately after that, we set <code>rbp</code> to <code>rsp</code>, that is, to the stack pointer at the beginning of the function. <code>push rbp</code> and <code>mov rbp, rsp</code> are thus usually referred to as the function prolog.</p>
<p>For the rest of the function body, we treat <code>rbp</code> as a constant and only decrease <code>rsp</code> if we need to reserve space on the stack.</p>
<p>So if function A calls function B which in turn calls function C, and each function stores on the stack the address of the caller frame, we know where to find on the stack the address of each. Thus, we can print a stack trace in any location of our program simply by inspecting the stack. Pretty nifty. That's already very useful to profilers and other similar tools.</p>
<p>We must not forget of course, just before we exit the function, to restore <code>rbp</code> to its original value (which is still on the stack at that point): that's <code>pop rbp</code>. This is also known as the function epilog. Another way to look at it is that we remove the last element of the linked list of call frames, since we are exiting the leaf function.</p>
<p>Don't worry if you have not fully understood everything, just remember to always have the function epilogs and prologs and you'll be fine:</p>
<pre><code class="language-x86asm">my_function:
  push rbp
  mov rbp, rsp

  sub rsp, N

  [...]


  add rsp, N
  pop rbp
  ret
</code></pre>
<p><strong>Note</strong>: There is an optimization method that uses <code>rbp</code> as a standard register (with a C compiler, that's the flag <code>-fomit-frame-pointer</code>), which means we lose the information about the call stack. My advice is: never do this, it is no worth it.</p>
<blockquote>
<p>Wait, but didn't you say the stack needs to be 16 byte aligned (that is, a multiple of 16)? Last time I checked, 5 is not really a multiple of 16!</p>
</blockquote>
<p>Good catch! The only reason why this program works, is that <code>print_hello</code> is a leaf function, meaning it does not call another function. Remember, the stack needs to be 16 bytes aligned when we do a <code>call</code>!</p>
<p>So the correct way would be:</p>
<pre><code>print_hello:
  push rbp
  mov rbp, rsp

  sub rsp, 16
  mov BYTE [rsp + 0], 'h'
  mov BYTE [rsp + 1], 'e'
  mov BYTE [rsp + 2], 'l'
  mov BYTE [rsp + 3], 'l'
  mov BYTE [rsp + 4], 'o'

  mov rax, SYSCALL_WRITE
  mov rdi, STDOUT
  lea rsi, [rsp]
  mov rdx, 5
  syscall

  call print_world

  add rsp, 16

  pop rbp
  ret
</code></pre>
<p>Since when we enter the function, the value of <code>rsp</code> is <code>16*N+8</code>, and pushing <code>rbp</code> increases it by 8, the stack pointer is 16 bytes aligned at the point of <code>sub rsp, 16</code>. Decrementing it by 16 (or a multiple of 16) keeps it 16 bytes aligned.</p>
<p>We now can safely call another function from within <code>print_hello</code>:</p>
<pre><code class="language-x86asm">print_world:
  push rbp
  mov rbp, rsp

  sub rsp, 16
  mov BYTE [rsp + 0], ' '
  mov BYTE [rsp + 1], 'w'
  mov BYTE [rsp + 2], 'o'
  mov BYTE [rsp + 3], 'r'
  mov BYTE [rsp + 4], 'l'
  mov BYTE [rsp + 5], 'd'

  mov rax, SYSCALL_WRITE
  mov rdi, STDOUT
  lea rsi, [rsp]
  mov rdx, 6
  syscall

  add rsp, 16

  pop rbp
  ret

print_hello:
  push rbp
  mov rbp, rsp

  sub rsp, 16
  mov BYTE [rsp + 0], 'h'
  mov BYTE [rsp + 1], 'e'
  mov BYTE [rsp + 2], 'l'
  mov BYTE [rsp + 3], 'l'
  mov BYTE [rsp + 4], 'o'

  mov rax, SYSCALL_WRITE
  mov rdi, STDOUT
  lea rsi, [rsp]
  mov rdx, 5
  syscall

  call print_world

  add rsp, 16

  pop rbp
  ret
</code></pre>
<p>And we get <code>hello world</code> as an output.</p>
<p>Now, try to do <code>sub rsp, 5</code> in <code>print_hello</code>, and your program <em>may</em> crash. There is no guarantee, that's what makes it hard to track down.</p>
<p>My advice is:</p>
<ul>
<li>Always use the standard function prologs and epilogs</li>
<li>Always increment/decrement <code>rsp</code> by (a multiple of) 16</li>
<li>Address items on the stack relative to <code>rsp</code>, i.e. <code>mov BYTE [rsp + 4], 'o'</code></li>
<li>If you have to decrement <code>rsp</code> by a value that's unknown at compile time (similar to how <code>alloca()</code> works in C), you can <code>and rsp, -16</code> to 16 bytes align it.</li>
</ul>
<p>And you'll be safe.</p>
<p>The last point is interesting, see for yourself:</p>
<pre><code class="language-shell">(gdb) p -100 &amp; -16
$1 = -112
(gdb) p -112 &amp; -16
$2 = -112
</code></pre>
<p>Which translates in assembly to:</p>
<pre><code>sub rsp, 100
and rsp, -16
</code></pre>
<p>Finally, following those conventions means that our assembly functions can be safely called from C or other languages following the <a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>, without any modification, which is great.</p>
<p><em>I have not talked about the red zone which is a 128 byte region at the bottom of the stack which our program is free to use as it pleases without having to change the stack pointer. In my opinion, it is not helpful and creates hard to track bugs, so I do not recommend to use it. To disable it entirely, run: <code>nasm -f elf64 -g main.nasm &amp;&amp; cc main.o -static -o main -mno-red-zone -nostdlib</code></em>.</p>
<h2>Opening a socket</h2>
<p>We now are ready to open a socket with the <code>socket(2)</code> syscall, so we add a few constants, taken from the libc headers (<em>note that those values might actually be different on a different Unix, I have not checked. Again, a few <code>%ifdef</code> can easily remedy this discrepancy</em>):</p>
<pre><code class="language-x86asm">%define AF_UNIX 1
%define SOCK_STREAM 1

%define SYSCALL_SOCKET 41
</code></pre>
<p>The <code>AF_UNIX</code> constant means we want a Unix domain socket, and <code>SOCK_STREAM</code> means <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">stream-oriented</a>. We use a domain socket since we now that our server is running on the same machine and it should be faster, but we could change it to <code>AF_INET</code> to connect to a remote IPv4 address for example.</p>
<p>We then fill the relevant registers with those values and invoke the system call:</p>
<pre><code class="language-x86asm">  mov rax, SYSCALL_SOCKET
  mov rdi, AF_UNIX ; Unix socket.
  mov rsi, SOCK_STREAM ; Stream oriented.
  mov rdx, 0 ; Automatic protocol.
  syscall
</code></pre>
<p>The C equivalent would be: <code>socket(AF_UNIX, SOCK_STREAM, 0);</code>. So you see that if we fill the registers in the same order as the C function parameters, we stay close to what C code would do.</p>
<p>The whole program now looks like this:</p>
<pre><code class="language-x86asm">BITS 64 ; 64 bits.
CPU X64 ; Target the x86_64 family of CPUs.

section .text

%define AF_UNIX 1
%define SOCK_STREAM 1

%define SYSCALL_SOCKET 41
%define SYSCALL_EXIT 60

global _start:
_start:
  ; open a unix socket.
  mov rax, SYSCALL_SOCKET
  mov rdi, AF_UNIX ; Unix socket.
  mov rsi, SOCK_STREAM ; Stream oriented.
  mov rdx, 0 ; automatic protocol.
  syscall


  ; The end.
  mov rax, SYSCALL_EXIT
  mov rdi, 0
  syscall
</code></pre>
<p>Building and running it under <code>strace</code> shows that it works and we get a socket with the file descriptor <code>3</code> (in this case, it might be different for you if you are following at home):</p>
<pre><code>$ nasm -f elf64 -g main.nasm &amp;&amp; ld main.o -static -o main 
$ strace ./main
execve(&quot;./main&quot;, [&quot;./main&quot;], 0x7ffe54dfe550 /* 60 vars */) = 0
socket(AF_UNIX, SOCK_STREAM, 0)         = 3
exit(0)                                 = ?
+++ exited with 0 +++
</code></pre>
<h2>Connecting to the server</h2>
<p>Now that we have created a socket, we can connect to the server with the <code>connect(2)</code> system call.</p>
<p>It's a good time to extract that logic in its own little function, just like in any other high-level language.</p>
<pre><code class="language-x86asm">x11_connect_to_server:
  ; TODO
</code></pre>
<p>In assembly, a function is simply a label we can jump to. But for clarity, both for readers of the code and tools, we can add a hint that this is a real function we can call, like this: <code>call x11_connect_to_server</code>. This will improve the call stack for example when using <code>strace -k</code>. This hint has the form (in <code>nasm</code>): <code>static &lt;name of the function&gt;:function</code>.</p>
<p>Of course, we also need to add our standard function prolog and epilog:</p>
<pre><code class="language-x86asm">x11_connect_to_server:
static x11_connect_to_server:function
  push rbp
  mov rbp, rsp
  
  pop rbp
  ret
</code></pre>
<p>An additional help when reading functions in assembly code is adding comments describing what parameters they accept and what is the return value, if any. Since there is no language level feature for this, we resort to comments:</p>
<pre><code class="language-x86asm">; Create a UNIX domain socket and connect to the X11 server.
; @returns The socket file descriptor.
x11_connect_to_server:
static x11_connect_to_server:function
  push rbp
  mov rbp, rsp
  
  pop rbp
  ret
</code></pre>
<p>First, let's move the socket creation logic to our function and call it in the program:</p>
<pre><code class="language-x86asm">; Create a UNIX domain socket and connect to the X11 server.
; @returns The socket file descriptor.
x11_connect_to_server:
static x11_connect_to_server:function
  push rbp
  mov rbp, rsp
  
  ; Open a Unix socket: socket(2).
  mov rax, SYSCALL_SOCKET
  mov rdi, AF_UNIX ; Unix socket.
  mov rsi, SOCK_STREAM ; Stream oriented.
  mov rdx, 0 ; Automatic protocol.
  syscall

  cmp rax, 0
  jle die

  mov rdi, rax ; Store socket fd in `rdi` for the remainder of the function.

  pop rbp
  ret

die:
  mov rax, SYSCALL_EXIT
  mov rdi, 1
  syscall

_start:
global _start:function
  call x11_connect_to_server
  
  ; The end.
  mov rax, SYSCALL_EXIT
  mov rdi, 0
  syscall
</code></pre>
<p>The error checking is very simplistic: we only check that the return value of the system call (in <code>rax</code>) is what we expect, otherwise we exit the program with a non-zero code by jumping to the <code>die</code> section.</p>
<blockquote>
<p><code>jle</code> is a conditional jump, which inspects global flags, hopefully set just before with <code>cmp</code> or <code>test</code>, and jumps to a label if the condition is true. Here, we compare the returned value with 0, and if it is lower or equal to 0, we jump to the error label. That's how we implement conditionals and loops.</p>
</blockquote>
<hr />
<p>Ok, we can finally connect to the server now. The <code>connect(2)</code> system call takes the address of a <code>sockaddr_un</code> structure as the second argument. This structure is too big to fit in a register.</p>
<p>This is the first syscall we encounter that needs to be passed a pointer, in other words, the address of a region in memory. That region can be on the stack or on the heap, or even be our own executable mapped in memory. That's assembly, we get to do whatever we want.</p>
<p>Since we want to keep things simple and fast, we will store everything in this program on the stack. And since we have 8 MiB of it (according to <code>limit</code>, on my machine, that is), it'll be plenty enough. Actually, the most space we will need on the stack in this program will be 32 KiB.</p>
<p>The size of the <code>sockaddr_un</code> structure is 110 bytes, so we reserve 112 to align <code>rsp</code> to 16 bytes.</p>
<blockquote>
<p>Nasm does have structs, but they are rather a way to define offsets with a name, than structures like in C with a specific syntax to address a specific field. For the sake of simplicity, I'll use the manual way, without <code>nasm</code> structs.</p>
</blockquote>
<p>We set the first 2 bytes of this structure to <code>AF_UNIX</code> since this is a domain socket. Then comes the path of the Unix domain socket which X11 expects to be in a certain format. We want to display our window on the first monitor starting at 0, so the string is: <code>/tmp/.X11-unix/X0</code>.</p>
<p>In C, we would do:</p>
<pre><code class="language-c">  const sockaddr_un addr = {.sun_family = AF_UNIX,
                            .sun_path = &quot;/tmp/.X11-unix/X0&quot;};
  const int res =
      connect(x11_socket_fd, (const struct sockaddr *)&amp;addr, sizeof(addr));
</code></pre>
<p>How do we translate that to assembly, especially the string part?</p>
<p>We could set each byte to each character of the string in the structure, on the stack, manually, one by one. Another <a href="https://en.wikibooks.org/wiki/X86_Assembly/Data_Transfer#Move_String">way</a> to do it is to use the <code>rep movsb</code> idiom, which instructs the CPU to copy a character from a string A to another string B, N times. This is exactly what we need!</p>
<p>The way it works is:</p>
<ul>
<li>We put the string in the <code>.rodata</code> section (same as the data section but read-only)</li>
<li>We load its address in <code>rsi</code> (it's the source)</li>
<li>We load the address of the string in the structure on the stack in <code>rdi</code> (it's the destination)</li>
<li>We set <code>rcx</code> to the number of bytes to be copied</li>
<li>We use <code>cld</code> to clear the <code>DF</code> flag to ensure the copy is done forwards (since it can also be done backwards)</li>
<li>We call <code>rep movsb</code> and voila</li>
</ul>
<p>It's basically <code>memcpy</code> from C.</p>
<blockquote>
<p>This is a interesting case: we can see that some instructions expect some of their operands to be in certain registers and there is no way around it.  So, we have to plan ahead and expect those registers to be overwritten. If we need to keep their original values around, we have to store those values elsewhere, for example on the stack (that's called spilling) or in other registers. This is a broader topic of register allocation which is NP-hard! In small functions, it's manageable though.</p>
</blockquote>
<p>First, the <code>.rodata</code> section:</p>
<pre><code class="language-x86asm">section .rodata

sun_path: db &quot;/tmp/.X11-unix/X0&quot;, 0
static sun_path:data
</code></pre>
<p>Then we copy the string:</p>
<pre><code class="language-x86asm">  mov WORD [rsp], AF_UNIX ; Set sockaddr_un.sun_family to AF_UNIX
  ; Fill sockaddr_un.sun_path with: &quot;/tmp/.X11-unix/X0&quot;.
  lea rsi, sun_path
  mov r12, rdi ; Save the socket file descriptor in `rdi` in `r12`.
  lea rdi, [rsp + 2]
  cld ; Move forward
  mov ecx, 19 ; Length is 19 with the null terminator.
  rep movsb ; Copy.

</code></pre>
<blockquote>
<p><code>ecx</code> is the 32 bit form of the register <code>rcx</code>, meaning we only set here the lower 32 bits of the 64 bit register. <a href="https://wiki.osdev.org/CPU_Registers_x86-64">This handy table</a> lists all of the forms for all of the registers. But be cautious of the pitfall case of only setting a value in part of a register, and then using the whole register later. The rest of the bits that have not been set will contain some past value, which is hard to troubleshoot. The solution is to use <code>movzx</code> to zero extend, meaning setting the rest of the bits to 0. A good way to visualize this is to use <code>info registers</code> within gdb, and that will display for each register the value for each of its forms, e.g. for <code>rcx</code>, it will display the value for <code>rcx</code>, <code>ecx</code>, <code>cx</code>, <code>ch</code>, <code>cl</code>.</p>
</blockquote>
<p>Then, we do the syscall, check the returned value, exit the program if the value is not 0, and finally return the socket file descriptor, which will be used every time in the rest of the program when talking to the X11 server.</p>
<p>Everything together, it looks like:</p>
<pre><code class="language-x86asm">; Create a UNIX domain socket and connect to the X11 server.
; @returns The socket file descriptor.
x11_connect_to_server:
static x11_connect_to_server:function
  push rbp
  mov rbp, rsp 

  ; Open a Unix socket: socket(2).
  mov rax, SYSCALL_SOCKET
  mov rdi, AF_UNIX ; Unix socket.
  mov rsi, SOCK_STREAM ; Stream oriented.
  mov rdx, 0 ; Automatic protocol.
  syscall

  cmp rax, 0
  jle die

  mov rdi, rax ; Store socket fd in `rdi` for the remainder of the function.

  sub rsp, 112 ; Store struct sockaddr_un on the stack.

  mov WORD [rsp], AF_UNIX ; Set sockaddr_un.sun_family to AF_UNIX
  ; Fill sockaddr_un.sun_path with: &quot;/tmp/.X11-unix/X0&quot;.
  lea rsi, sun_path
  mov r12, rdi ; Save the socket file descriptor in `rdi` in `r12`.
  lea rdi, [rsp + 2]
  cld ; Move forward
  mov ecx, 19 ; Length is 19 with the null terminator.
  rep movsb ; Copy.

  ; Connect to the server: connect(2).
  mov rax, SYSCALL_CONNECT
  mov rdi, r12
  lea rsi, [rsp]
  %define SIZEOF_SOCKADDR_UN 2+108
  mov rdx, SIZEOF_SOCKADDR_UN
  syscall

  cmp rax, 0
  jne die

  mov rax, rdi ; Return the socket fd.

  add rsp, 112
  pop rbp
  ret

</code></pre>
<p>We are ready to talk to the X11 server!</p>
<h2>Sending data over the socket</h2>
<p>There is the <code>send(2)</code> syscall to do this, but we can keep it simple and use the generic <code>write(2)</code> syscall instead. Either way works.</p>
<pre><code class="language-x86asm">%define SYSCALL_WRITE 1
</code></pre>
<p>The C structure for the handshake in the case of success looks like this:</p>
<pre><code class="language-c">typedef struct {
  u8 order;
  u8 pad1;
  u16 major, minor;
  u16 auth_proto, auth_data;
  u16 pad2;
} x11_connection_req_t;
</code></pre>
<p><code>pad*</code> fields can be ignored since they are padding and their value is not read by the server.</p>
<p>For our handshake, we need to set the <code>order</code> to be <code>l</code>, that is, little-endian, since X11 can be told to interpret message as big or little endian. Since x64 is little-endian, we do not want to have a endianness translation layer and so we stick to little-endian.</p>
<p>We also need to set the <code>major</code> field, which is the version, to <code>11</code>. I'll leave it to the reader to guess why.</p>
<p>In C, we would do:</p>
<pre><code class="language-c">  x11_connection_req_t req = {.order = 'l', .major = 11};
</code></pre>
<p>This structure is only 12 bytes long, but since we will have to read the response from the server which is quite big (around 14 KiB during my testing), we will right away reserve a lot of space on the stack, 32 KiB, to be safe:</p>
<pre><code class="language-x86asm">  sub rsp, 1&lt;&lt;15
  mov BYTE [rsp + 0], 'l' ; Set order to 'l'.
  mov WORD [rsp + 2], 11 ; Set major version to 11.
</code></pre>
<p>Then we send it to the server:</p>
<pre><code class="language-x86asm">  ; Send the handshake to the server: write(2).
  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 12*8
  syscall

  cmp rax, 12*8 ; Check that all bytes were written.
  jnz die
</code></pre>
<p>After that, we read the server response, which should be at first 8 bytes:</p>
<pre><code class="language-x86asm">  ; Read the server response: read(2).
  ; Use the stack for the read buffer.
  ; The X11 server first replies with 8 bytes. Once these are read, it replies with a much bigger message.
  mov rax, SYSCALL_READ
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 8
  syscall

  cmp rax, 8 ; Check that the server replied with 8 bytes.
  jnz die

  cmp BYTE [rsp], 1 ; Check that the server sent 'success' (first byte is 1).
  jnz die
</code></pre>
<p>The first byte in the server response is <code>0</code> for failure and <code>1</code> for success (and <code>2</code> for authentication but we will not need it here).</p>
<p>The server sends a big message with a lot of general information, which we will need for later, so we store certain fields in global variables located in the data section.</p>
<p>First we add those variables, each 4 bytes big:</p>
<pre><code class="language-x86asm">section .data

id: dd 0
static id:data

id_base: dd 0
static id_base:data

id_mask: dd 0
static id_mask:data

root_visual_id: dd 0
static root_visual_id:data
</code></pre>
<p>Then we read the server response, and skip over the parts we are not interested in. This boils down to incrementing a pointer by a dynamic value, a few times. Note that since we do not do any checks here, that would be a great attack vector to trigger a stack overflow or such in our program.</p>
<pre><code class="language-x86asm">  ; Read the rest of the server response: read(2).
  ; Use the stack for the read buffer.
  mov rax, SYSCALL_READ
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 1&lt;&lt;15
  syscall

  cmp rax, 0 ; Check that the server replied with something.
  jle die

  ; Set id_base globally.
  mov edx, DWORD [rsp + 4]
  mov DWORD [id_base], edx

  ; Set id_mask globally.
  mov edx, DWORD [rsp + 8]
  mov DWORD [id_mask], edx

  ; Read the information we need, skip over the rest.
  lea rdi, [rsp] ; Pointer that will skip over some data.
  
  mov cx, WORD [rsp + 16] ; Vendor length (v).
  movzx rcx, cx

  mov al, BYTE [rsp + 21]; Number of formats (n).
  movzx rax, al ; Fill the rest of the register with zeroes to avoid garbage values.
  imul rax, 8 ; sizeof(format) == 8

  add rdi, 32 ; Skip the connection setup
  add rdi, rcx ; Skip over the vendor information (v).

  ; Skip over padding.
  add rdi, 3
  and rdi, -4

  add rdi, rax ; Skip over the format information (n*8).

  mov eax, DWORD [rdi] ; Store (and return) the window root id.

  ; Set the root_visual_id globally.
  mov edx, DWORD [rdi + 32]
  mov DWORD [root_visual_id], edx
</code></pre>
<hr />
<p>A small aside about padding, <a href="https://github.com/gaultier/blog/issues/6">thanks to a perspicacious reader</a>:</p>
<p>How we skip padding is the only bit of smartness we allow ourselves: some fields in the X11 protocol have a variable length. But the X11 protocol counts everything in units of '4 bytes'.</p>
<p>Meaning, if a field is only 5 bytes long, per the protocol, there will be 3 bytes of padding (which should be skipped over by the application), so that the field occupies 2 units of 4 bytes (it is 4 bytes-aligned).</p>
<p>How do we do that then? The specification uses some division and modulo operations, but those are annoying to do in assembly. We can do better.</p>
<p><code>libX11</code> uses this macro:</p>
<pre><code class="language-c">#define ROUNDUP(nbytes, pad) (((nbytes) + ((pad)-1)) &amp; ~(long)((pad)-1))
</code></pre>
<p>And it should be used so:</p>
<pre><code class="language-c">assert(ROUNDUP(0, 4) == 0);
assert(ROUNDUP(1, 4) == 4);
assert(ROUNDUP(2, 4) == 4);
assert(ROUNDUP(3, 4) == 4);
assert(ROUNDUP(4, 4) == 4);
assert(ROUNDUP(5, 4) == 8);
// etc
</code></pre>
<p>This works, but is kind of complex. If we look at this output when compiling this code, we see that <code>gcc</code> smartly optimizes this macro down to:</p>
<pre><code class="language-x86asm">  add     eax, 3
  and     eax, -4
</code></pre>
<p>So we use this form.</p>
<hr />
<p>All together:</p>
<pre><code class="language-x86asm">; Send the handshake to the X11 server and read the returned system information.
; @param rdi The socket file descriptor
; @returns The window root id (uint32_t) in rax.
x11_send_handshake:
static x11_send_handshake:function
  push rbp
  mov rbp, rsp

  sub rsp, 1&lt;&lt;15
  mov BYTE [rsp + 0], 'l' ; Set order to 'l'.
  mov WORD [rsp + 2], 11 ; Set major version to 11.

  ; Send the handshake to the server: write(2).
  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 12*8
  syscall

  cmp rax, 12*8 ; Check that all bytes were written.
  jnz die

  ; Read the server response: read(2).
  ; Use the stack for the read buffer.
  ; The X11 server first replies with 8 bytes. Once these are read, it replies with a much bigger message.
  mov rax, SYSCALL_READ
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 8
  syscall

  cmp rax, 8 ; Check that the server replied with 8 bytes.
  jnz die

  cmp BYTE [rsp], 1 ; Check that the server sent 'success' (first byte is 1).
  jnz die

  ; Read the rest of the server response: read(2).
  ; Use the stack for the read buffer.
  mov rax, SYSCALL_READ
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 1&lt;&lt;15
  syscall

  cmp rax, 0 ; Check that the server replied with something.
  jle die

  ; Set id_base globally.
  mov edx, DWORD [rsp + 4]
  mov DWORD [id_base], edx

  ; Set id_mask globally.
  mov edx, DWORD [rsp + 8]
  mov DWORD [id_mask], edx

  ; Read the information we need, skip over the rest.
  lea rdi, [rsp] ; Pointer that will skip over some data.
  
  mov cx, WORD [rsp + 16] ; Vendor length (v).
  movzx rcx, cx

  mov al, BYTE [rsp + 21]; Number of formats (n).
  movzx rax, al ; Fill the rest of the register with zeroes to avoid garbage values.
  imul rax, 8 ; sizeof(format) == 8

  add rdi, 32 ; Skip the connection setup
  add rdi, rcx ; Skip over the vendor information (v).

  ; Skip over padding.
  add rdi, 3
  and rdi, -4

  add rdi, rax ; Skip over the format information (n*8).

  mov eax, DWORD [rdi] ; Store (and return) the window root id.

  ; Set the root_visual_id globally.
  mov edx, DWORD [rdi + 32]
  mov DWORD [root_visual_id], edx

  add rsp, 1&lt;&lt;15
  pop rbp
  ret
</code></pre>
<blockquote>
<p>From this point on, I will assume you are familiar with the basics of assembly and X11 and will not go as much into details.</p>
</blockquote>
<h2>Generating ids</h2>
<p>When creating resources on the server-side, we usually first generate an id on the client side, and send that id to the server when creating the resource.</p>
<p>We store the current id in a global variable and increment it each time a new id is generated.</p>
<p>This is how we do it:</p>
<pre><code class="language-x86asm">; Increment the global id.
; @return The new id.
x11_next_id:
static x11_next_id:function
  push rbp
  mov rbp, rsp

  mov eax, DWORD [id] ; Load global id.

  mov edi, DWORD [id_base] ; Load global id_base.
  mov edx, DWORD [id_mask] ; Load global id_mask.

  ; Return: id_mask &amp; (id) | id_base
  and eax, edx
  or eax, edi

  add DWORD [id], 1 ; Increment id.

  pop rbp
  ret
</code></pre>
<h2>Opening a font</h2>
<p>To open a font, which is a prerequisite to draw text, we send a message to the server specifying (part of) the name of the font we want, and the server will select a matching font.</p>
<p>To play with another font, you can use <code>xfontsel</code> which displays all the font names that the X11 server knows about.</p>
<p>First, we generate an id for the font locally, and then we send it alongside the font name.</p>
<pre><code class="language-x86asm">; Open the font on the server side.
; @param rdi The socket file descriptor.
; @param esi The font id.
x11_open_font:
static x11_open_font:function
  push rbp
  mov rbp, rsp

  %define OPEN_FONT_NAME_BYTE_COUNT 5
  %define OPEN_FONT_PADDING ((4 - (OPEN_FONT_NAME_BYTE_COUNT % 4)) % 4)
  %define OPEN_FONT_PACKET_U32_COUNT (3 + (OPEN_FONT_NAME_BYTE_COUNT + OPEN_FONT_PADDING) / 4)
  %define X11_OP_REQ_OPEN_FONT 0x2d

  sub rsp, 6*8
  mov DWORD [rsp + 0*4], X11_OP_REQ_OPEN_FONT | (OPEN_FONT_NAME_BYTE_COUNT &lt;&lt; 16)
  mov DWORD [rsp + 1*4], esi
  mov DWORD [rsp + 2*4], OPEN_FONT_NAME_BYTE_COUNT
  mov BYTE [rsp + 3*4 + 0], 'f'
  mov BYTE [rsp + 3*4 + 1], 'i'
  mov BYTE [rsp + 3*4 + 2], 'x'
  mov BYTE [rsp + 3*4 + 3], 'e'
  mov BYTE [rsp + 3*4 + 4], 'd'


  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, OPEN_FONT_PACKET_U32_COUNT*4
  syscall

  cmp rax, OPEN_FONT_PACKET_U32_COUNT*4
  jnz die

  add rsp, 6*8

  pop rbp
  ret
</code></pre>
<h2>Creating a graphical context</h2>
<p>Since an application in X11 can have multiple windows, we first need to create a graphical context containing the general information. When we create a window, we refer to this graphical context by id.</p>
<p>Again, we need to generate an id for the graphical context to be.</p>
<p>X11 stores a hierarchy of windows, so when creating the graphical context, we also need to give it the root window id (i.e. the parent id).</p>
<pre><code class="language-x86asm">; Create a X11 graphical context.
; @param rdi The socket file descriptor.
; @param esi The graphical context id.
; @param edx The window root id.
; @param ecx The font id.
x11_create_gc:
static x11_create_gc:function
  push rbp
  mov rbp, rsp

  sub rsp, 8*8

%define X11_OP_REQ_CREATE_GC 0x37
%define X11_FLAG_GC_BG 0x00000004
%define X11_FLAG_GC_FG 0x00000008
%define X11_FLAG_GC_FONT 0x00004000
%define X11_FLAG_GC_EXPOSE 0x00010000

%define CREATE_GC_FLAGS X11_FLAG_GC_BG | X11_FLAG_GC_FG | X11_FLAG_GC_FONT
%define CREATE_GC_PACKET_FLAG_COUNT 3
%define CREATE_GC_PACKET_U32_COUNT (4 + CREATE_GC_PACKET_FLAG_COUNT)
%define MY_COLOR_RGB 0x0000ffff

  mov DWORD [rsp + 0*4], X11_OP_REQ_CREATE_GC | (CREATE_GC_PACKET_U32_COUNT&lt;&lt;16)
  mov DWORD [rsp + 1*4], esi
  mov DWORD [rsp + 2*4], edx
  mov DWORD [rsp + 3*4], CREATE_GC_FLAGS
  mov DWORD [rsp + 4*4], MY_COLOR_RGB
  mov DWORD [rsp + 5*4], 0
  mov DWORD [rsp + 6*4], ecx

  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, CREATE_GC_PACKET_U32_COUNT*4
  syscall

  cmp rax, CREATE_GC_PACKET_U32_COUNT*4
  jnz die
  
  add rsp, 8*8

  pop rbp
  ret
</code></pre>
<h2>Creating the window</h2>
<p>We can now create the window, which refers to the freshly created graphical context.
We also provide the desired x and y coordinates of the window, as well as the desired dimensions (width and height).</p>
<p>Note that those are simply hints and the resulting window may well have different coordinates and dimensions, for example when using a tiling window manager, or when resizing the window.</p>
<pre><code class="language-x86asm">; Create the X11 window.
; @param rdi The socket file descriptor.
; @param esi The new window id.
; @param edx The window root id.
; @param ecx The root visual id.
; @param r8d Packed x and y.
; @param r9d Packed w and h.
x11_create_window:
static x11_create_window:function
  push rbp
  mov rbp, rsp

  %define X11_OP_REQ_CREATE_WINDOW 0x01
  %define X11_FLAG_WIN_BG_COLOR 0x00000002
  %define X11_EVENT_FLAG_KEY_RELEASE 0x0002
  %define X11_EVENT_FLAG_EXPOSURE 0x8000
  %define X11_FLAG_WIN_EVENT 0x00000800
  
  %define CREATE_WINDOW_FLAG_COUNT 2
  %define CREATE_WINDOW_PACKET_U32_COUNT (8 + CREATE_WINDOW_FLAG_COUNT)
  %define CREATE_WINDOW_BORDER 1
  %define CREATE_WINDOW_GROUP 1

  sub rsp, 12*8

  mov DWORD [rsp + 0*4], X11_OP_REQ_CREATE_WINDOW | (CREATE_WINDOW_PACKET_U32_COUNT &lt;&lt; 16)
  mov DWORD [rsp + 1*4], esi
  mov DWORD [rsp + 2*4], edx
  mov DWORD [rsp + 3*4], r8d
  mov DWORD [rsp + 4*4], r9d
  mov DWORD [rsp + 5*4], CREATE_WINDOW_GROUP | (CREATE_WINDOW_BORDER &lt;&lt; 16)
  mov DWORD [rsp + 6*4], ecx
  mov DWORD [rsp + 7*4], X11_FLAG_WIN_BG_COLOR | X11_FLAG_WIN_EVENT
  mov DWORD [rsp + 8*4], 0
  mov DWORD [rsp + 9*4], X11_EVENT_FLAG_KEY_RELEASE | X11_EVENT_FLAG_EXPOSURE


  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, CREATE_WINDOW_PACKET_U32_COUNT*4
  syscall

  cmp rax, CREATE_WINDOW_PACKET_U32_COUNT*4
  jnz die

  add rsp, 12*8

  pop rbp
  ret
</code></pre>
<h2>Mapping the window</h2>
<p>If you are following along at home, and just ran the program, you have realized nothing is displayed.</p>
<p>That is because X11 does not show the window until we have mapped it. This is a simple message to send:</p>
<pre><code class="language-x86asm">; Map a X11 window.
; @param rdi The socket file descriptor.
; @param esi The window id.
x11_map_window:
static x11_map_window:function
  push rbp
  mov rbp, rsp

  sub rsp, 16

  %define X11_OP_REQ_MAP_WINDOW 0x08
  mov DWORD [rsp + 0*4], X11_OP_REQ_MAP_WINDOW | (2&lt;&lt;16)
  mov DWORD [rsp + 1*4], esi

  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 2*4
  syscall

  cmp rax, 2*4
  jnz die

  add rsp, 16

  pop rbp
  ret
</code></pre>
<p>We now have a black window:</p>
<p><img src="x11_x64_black_window.png" alt="Black window" /></p>
<p>Yay!</p>
<h2>Polling for server messages</h2>
<p>We would like to draw text in the window now, but we have to wait for the <code>Expose</code> event to be sent to us, which means that the window is visible, to be able to start drawing on it.</p>
<p>We want to listen for all server messages actually, be it errors or events, for example when the user presses a key on the keyboard.</p>
<p>If we do a simple blocking <code>read(2)</code>, but the server sends nothing, the program will appear not responding. Not good.
The solution is to use the <code>poll(2)</code> system call to be awoken by the operating system whenever there is data to be read on the socket, a la NodeJS or Nginx.</p>
<blockquote>
<p>An shrewd reader has pointed out that we could simply <code>read</code> from the socket in a loop, since we only have one, possibly with a timeout. Linux, and perhaps others, support setting a read timeout on a socket with <code>setsockopt(2)</code>. But I will keep this version in this article since this is the original one. Feel free to experiment with the alternative at home!</p>
</blockquote>
<p>First, we need to mark the socket as 'non-blocking' since it is by default in blocking mode:</p>
<pre><code class="language-x86asm">; Set a file descriptor in non-blocking mode.
; @param rdi The file descriptor.
set_fd_non_blocking:
static set_fd_non_blocking:function
  push rbp
  mov rbp, rsp

  mov rax, SYSCALL_FCNTL
  mov rdi, rdi 
  mov rsi, F_GETFL
  mov rdx, 0
  syscall

  cmp rax, 0
  jl die

  ; `or` the current file status flag with O_NONBLOCK.
  mov rdx, rax
  or rdx, O_NONBLOCK

  mov rax, SYSCALL_FCNTL
  mov rdi, rdi 
  mov rsi, F_SETFL
  mov rdx, rdx
  syscall

  cmp rax, 0
  jl die

  pop rbp
  ret
</code></pre>
<p>Then, we write a small function to read data on the socket. For simplicity, we only read 32 bytes of data, because most messages from X11 are of this size. We also return the first byte which contains the event type.</p>
<pre><code class="language-x86asm">; Read the X11 server reply.
; @return The message code in al.
x11_read_reply:
static x11_read_reply:function
  push rbp
  mov rbp, rsp

  sub rsp, 32
  
  mov rax, SYSCALL_READ
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 32
  syscall

  cmp rax, 1
  jle die

  mov al, BYTE [rsp]

  add rsp, 32

  pop rbp
  ret
</code></pre>
<p>We now can poll. If an error occurs or the other side has closed their end of the socket, we exit the program.</p>
<pre><code class="language-x86asm">; Poll indefinitely messages from the X11 server with poll(2).
; @param rdi The socket file descriptor.
; @param esi The window id.
; @param edx The gc id.
poll_messages:
static poll_messages:function
  push rbp
  mov rbp, rsp

  sub rsp, 32

  %define POLLIN 0x001
  %define POLLPRI 0x002
  %define POLLOUT 0x004
  %define POLLERR  0x008
  %define POLLHUP  0x010
  %define POLLNVAL 0x020

  mov DWORD [rsp + 0*4], edi
  mov DWORD [rsp + 1*4], POLLIN

  mov DWORD [rsp + 16], esi ; window id
  mov DWORD [rsp + 20], edx ; gc id

  .loop:
    mov rax, SYSCALL_POLL
    lea rdi, [rsp]
    mov rsi, 1
    mov rdx, -1
    syscall

    cmp rax, 0
    jle die

    cmp DWORD [rsp + 2*4], POLLERR  
    je die

    cmp DWORD [rsp + 2*4], POLLHUP  
    je die

    mov rdi, [rsp + 0*4]
    call x11_read_reply

    jmp .loop

  add rsp, 32
  pop rbp
  ret
</code></pre>
<h2>Drawing text</h2>
<p>At last, we can draw text. The small difficulty here is that the text is of unknown length in the general case, so we have to compute the size of the X11 message, including the padding at the end. So far, we only had messages of fixed size.</p>
<p>The official documentation has formulas to compute those values.</p>
<pre><code class="language-x86asm">; Draw text in a X11 window with server-side text rendering.
; @param rdi The socket file descriptor.
; @param rsi The text string.
; @param edx The text string length in bytes.
; @param ecx The window id.
; @param r8d The gc id.
; @param r9d Packed x and y.
x11_draw_text:
static x11_draw_text:function
  push rbp
  mov rbp, rsp

  sub rsp, 1024

  mov DWORD [rsp + 1*4], ecx ; Store the window id directly in the packet data on the stack.
  mov DWORD [rsp + 2*4], r8d ; Store the gc id directly in the packet data on the stack.
  mov DWORD [rsp + 3*4], r9d ; Store x, y directly in the packet data on the stack.

  mov r8d, edx ; Store the string length in r8 since edx will be overwritten next.
  mov QWORD [rsp + 1024 - 8], rdi ; Store the socket file descriptor on the stack to free the register.

  ; Compute padding and packet u32 count with division and modulo 4.
  mov eax, edx ; Put dividend in eax.
  mov ecx, 4 ; Put divisor in ecx.
  cdq ; Sign extend.
  idiv ecx ; Compute eax / ecx, and put the remainder (i.e. modulo) in edx.
  ; LLVM optimizer magic: `(4-x)%4 == -x &amp; 3`, for some reason.
  neg edx
  and edx, 3
  mov r9d, edx ; Store padding in r9.

  mov eax, r8d 
  add eax, r9d
  shr eax, 2 ; Compute: eax /= 4
  add eax, 4 ; eax now contains the packet u32 count.


  %define X11_OP_REQ_IMAGE_TEXT8 0x4c
  mov DWORD [rsp + 0*4], r8d
  shl DWORD [rsp + 0*4], 8
  or DWORD [rsp + 0*4], X11_OP_REQ_IMAGE_TEXT8
  mov ecx, eax
  shl ecx, 16
  or [rsp + 0*4], ecx

  ; Copy the text string into the packet data on the stack.
  mov rsi, rsi ; Source string in rsi.
  lea rdi, [rsp + 4*4] ; Destination
  cld ; Move forward
  mov ecx, r8d ; String length.
  rep movsb ; Copy.

  mov rdx, rax ; packet u32 count
  imul rdx, 4
  mov rax, SYSCALL_WRITE
  mov rdi, QWORD [rsp + 1024 - 8] ; fd
  lea rsi, [rsp]
  syscall

  cmp rax, rdx
  jnz die

  add rsp, 1024

  pop rbp
  ret
</code></pre>
<p>We then call this function inside the polling loop, and we store the 'exposed' state in a boolean on the stack to know whether we should render the text or not:</p>
<pre><code class="language-x86asm">    %define X11_EVENT_EXPOSURE 0xc
    cmp eax, X11_EVENT_EXPOSURE
    jnz .received_other_event

    .received_exposed_event:
    mov BYTE [rsp + 24], 1 ; Mark as exposed.

    .received_other_event:

    cmp BYTE [rsp + 24], 1 ; exposed?
    jnz .loop

    .draw_text:
      mov rdi, [rsp + 0*4] ; socket fd
      lea rsi, [hello_world] ; string
      mov edx, 13 ; length
      mov ecx, [rsp + 16] ; window id
      mov r8d, [rsp + 20] ; gc id
      mov r9d, 100 ; x
      shl r9d, 16
      or r9d, 100 ; y
      call x11_draw_text
</code></pre>
<p>Finally, we see our <code>Hello, world!</code> text displayed inside the window:</p>
<p><img src="x11_x64_final.png" alt="Result" /></p>
<h2>The end</h2>
<p>Wow, that was a lot. But we did it! We wrote a (albeit simplistic) GUI program in pure assembly, no dependencies, and that's just 600 lines of code in the end.</p>
<p>How did we fare on the executable size part?</p>
<ul>
<li>With debug information: 10744 bytes (10 KiB)</li>
<li>Without debug information (stripped): 8592 bytes (8 KiB)</li>
<li>Stripped and <code>OMAGIC</code> (<code>--omagic</code> linker flag, from the man page: <code>Set the text and data sections to be readable and writable.  Also, do not page-align the data segment</code>): 1776 bytes (1 KiB)</li>
</ul>
<p>Not too shabby, a GUI program in 1 KiB.</p>
<p>Where to go from there?</p>
<ul>
<li>We could move text rendering client-side. Doing it server-side has lots of limitations.</li>
<li>We could add shape rendering, such as quads and circles</li>
<li>We could listen to keyboard and mouse events (the polling loop is easy to extend to do that)</li>
</ul>
<p>I hope that you had as much fun as I did!</p>
<blockquote>
<p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&amp;locale.x=en_US">Donate</a></p>
</blockquote>
<h2>Addendum: the full code</h2>
<pre><code class="language-x86asm">; Build with: nasm -f elf64 -g main.nasm &amp;&amp; ld main.o -static -o main 

BITS 64 ; 64 bits.
CPU X64 ; Target the x86_64 family of CPUs.

section .rodata

sun_path: db &quot;/tmp/.X11-unix/X0&quot;, 0
static sun_path:data

hello_world: db &quot;Hello, world!&quot;
static hello_world:data

section .data

id: dd 0
static id:data

id_base: dd 0
static id_base:data

id_mask: dd 0
static id_mask:data

root_visual_id: dd 0
static root_visual_id:data


section .text

%define AF_UNIX 1
%define SOCK_STREAM 1

%define SYSCALL_READ 0
%define SYSCALL_WRITE 1
%define SYSCALL_POLL 7
%define SYSCALL_SOCKET 41
%define SYSCALL_CONNECT 42
%define SYSCALL_EXIT 60
%define SYSCALL_FCNTL 72

; Create a UNIX domain socket and connect to the X11 server.
; @returns The socket file descriptor.
x11_connect_to_server:
static x11_connect_to_server:function
  push rbp
  mov rbp, rsp 

  ; Open a Unix socket: socket(2).
  mov rax, SYSCALL_SOCKET
  mov rdi, AF_UNIX ; Unix socket.
  mov rsi, SOCK_STREAM ; Stream oriented.
  mov rdx, 0 ; Automatic protocol.
  syscall

  cmp rax, 0
  jle die

  mov rdi, rax ; Store socket fd in `rdi` for the remainder of the function.

  sub rsp, 112 ; Store struct sockaddr_un on the stack.

  mov WORD [rsp], AF_UNIX ; Set sockaddr_un.sun_family to AF_UNIX
  ; Fill sockaddr_un.sun_path with: &quot;/tmp/.X11-unix/X0&quot;.
  lea rsi, sun_path
  mov r12, rdi ; Save the socket file descriptor in `rdi` in `r12`.
  lea rdi, [rsp + 2]
  cld ; Move forward
  mov ecx, 19 ; Length is 19 with the null terminator.
  rep movsb ; Copy.

  ; Connect to the server: connect(2).
  mov rax, SYSCALL_CONNECT
  mov rdi, r12
  lea rsi, [rsp]
  %define SIZEOF_SOCKADDR_UN 2+108
  mov rdx, SIZEOF_SOCKADDR_UN
  syscall

  cmp rax, 0
  jne die

  mov rax, rdi ; Return the socket fd.

  add rsp, 112
  pop rbp
  ret

; Send the handshake to the X11 server and read the returned system information.
; @param rdi The socket file descriptor
; @returns The window root id (uint32_t) in rax.
x11_send_handshake:
static x11_send_handshake:function
  push rbp
  mov rbp, rsp

  sub rsp, 1&lt;&lt;15
  mov BYTE [rsp + 0], 'l' ; Set order to 'l'.
  mov WORD [rsp + 2], 11 ; Set major version to 11.

  ; Send the handshake to the server: write(2).
  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 12*8
  syscall

  cmp rax, 12*8 ; Check that all bytes were written.
  jnz die

  ; Read the server response: read(2).
  ; Use the stack for the read buffer.
  ; The X11 server first replies with 8 bytes. Once these are read, it replies with a much bigger message.
  mov rax, SYSCALL_READ
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 8
  syscall

  cmp rax, 8 ; Check that the server replied with 8 bytes.
  jnz die

  cmp BYTE [rsp], 1 ; Check that the server sent 'success' (first byte is 1).
  jnz die

  ; Read the rest of the server response: read(2).
  ; Use the stack for the read buffer.
  mov rax, SYSCALL_READ
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 1&lt;&lt;15
  syscall

  cmp rax, 0 ; Check that the server replied with something.
  jle die

  ; Set id_base globally.
  mov edx, DWORD [rsp + 4]
  mov DWORD [id_base], edx

  ; Set id_mask globally.
  mov edx, DWORD [rsp + 8]
  mov DWORD [id_mask], edx

  ; Read the information we need, skip over the rest.
  lea rdi, [rsp] ; Pointer that will skip over some data.
  
  mov cx, WORD [rsp + 16] ; Vendor length (v).
  movzx rcx, cx

  mov al, BYTE [rsp + 21]; Number of formats (n).
  movzx rax, al ; Fill the rest of the register with zeroes to avoid garbage values.
  imul rax, 8 ; sizeof(format) == 8

  add rdi, 32 ; Skip the connection setup

  ; Skip over padding.
  add rdi, 3
  and rdi, -4

  add rdi, rcx ; Skip over the vendor information (v).
  add rdi, rax ; Skip over the format information (n*8).

  mov eax, DWORD [rdi] ; Store (and return) the window root id.

  ; Set the root_visual_id globally.
  mov edx, DWORD [rdi + 32]
  mov DWORD [root_visual_id], edx

  add rsp, 1&lt;&lt;15
  pop rbp
  ret

; Increment the global id.
; @return The new id.
x11_next_id:
static x11_next_id:function
  push rbp
  mov rbp, rsp

  mov eax, DWORD [id] ; Load global id.

  mov edi, DWORD [id_base] ; Load global id_base.
  mov edx, DWORD [id_mask] ; Load global id_mask.

  ; Return: id_mask &amp; (id) | id_base
  and eax, edx
  or eax, edi

  add DWORD [id], 1 ; Increment id.

  pop rbp
  ret

; Open the font on the server side.
; @param rdi The socket file descriptor.
; @param esi The font id.
x11_open_font:
static x11_open_font:function
  push rbp
  mov rbp, rsp

  %define OPEN_FONT_NAME_BYTE_COUNT 5
  %define OPEN_FONT_PADDING ((4 - (OPEN_FONT_NAME_BYTE_COUNT % 4)) % 4)
  %define OPEN_FONT_PACKET_U32_COUNT (3 + (OPEN_FONT_NAME_BYTE_COUNT + OPEN_FONT_PADDING) / 4)
  %define X11_OP_REQ_OPEN_FONT 0x2d

  sub rsp, 6*8
  mov DWORD [rsp + 0*4], X11_OP_REQ_OPEN_FONT | (OPEN_FONT_NAME_BYTE_COUNT &lt;&lt; 16)
  mov DWORD [rsp + 1*4], esi
  mov DWORD [rsp + 2*4], OPEN_FONT_NAME_BYTE_COUNT
  mov BYTE [rsp + 3*4 + 0], 'f'
  mov BYTE [rsp + 3*4 + 1], 'i'
  mov BYTE [rsp + 3*4 + 2], 'x'
  mov BYTE [rsp + 3*4 + 3], 'e'
  mov BYTE [rsp + 3*4 + 4], 'd'


  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, OPEN_FONT_PACKET_U32_COUNT*4
  syscall

  cmp rax, OPEN_FONT_PACKET_U32_COUNT*4
  jnz die

  add rsp, 6*8

  pop rbp
  ret

; Create a X11 graphical context.
; @param rdi The socket file descriptor.
; @param esi The graphical context id.
; @param edx The window root id.
; @param ecx The font id.
x11_create_gc:
static x11_create_gc:function
  push rbp
  mov rbp, rsp

  sub rsp, 8*8

%define X11_OP_REQ_CREATE_GC 0x37
%define X11_FLAG_GC_BG 0x00000004
%define X11_FLAG_GC_FG 0x00000008
%define X11_FLAG_GC_FONT 0x00004000
%define X11_FLAG_GC_EXPOSE 0x00010000

%define CREATE_GC_FLAGS X11_FLAG_GC_BG | X11_FLAG_GC_FG | X11_FLAG_GC_FONT
%define CREATE_GC_PACKET_FLAG_COUNT 3
%define CREATE_GC_PACKET_U32_COUNT (4 + CREATE_GC_PACKET_FLAG_COUNT)
%define MY_COLOR_RGB 0x0000ffff

  mov DWORD [rsp + 0*4], X11_OP_REQ_CREATE_GC | (CREATE_GC_PACKET_U32_COUNT&lt;&lt;16)
  mov DWORD [rsp + 1*4], esi
  mov DWORD [rsp + 2*4], edx
  mov DWORD [rsp + 3*4], CREATE_GC_FLAGS
  mov DWORD [rsp + 4*4], MY_COLOR_RGB
  mov DWORD [rsp + 5*4], 0
  mov DWORD [rsp + 6*4], ecx

  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, CREATE_GC_PACKET_U32_COUNT*4
  syscall

  cmp rax, CREATE_GC_PACKET_U32_COUNT*4
  jnz die
  
  add rsp, 8*8

  pop rbp
  ret

; Create the X11 window.
; @param rdi The socket file descriptor.
; @param esi The new window id.
; @param edx The window root id.
; @param ecx The root visual id.
; @param r8d Packed x and y.
; @param r9d Packed w and h.
x11_create_window:
static x11_create_window:function
  push rbp
  mov rbp, rsp

  %define X11_OP_REQ_CREATE_WINDOW 0x01
  %define X11_FLAG_WIN_BG_COLOR 0x00000002
  %define X11_EVENT_FLAG_KEY_RELEASE 0x0002
  %define X11_EVENT_FLAG_EXPOSURE 0x8000
  %define X11_FLAG_WIN_EVENT 0x00000800
  
  %define CREATE_WINDOW_FLAG_COUNT 2
  %define CREATE_WINDOW_PACKET_U32_COUNT (8 + CREATE_WINDOW_FLAG_COUNT)
  %define CREATE_WINDOW_BORDER 1
  %define CREATE_WINDOW_GROUP 1

  sub rsp, 12*8

  mov DWORD [rsp + 0*4], X11_OP_REQ_CREATE_WINDOW | (CREATE_WINDOW_PACKET_U32_COUNT &lt;&lt; 16)
  mov DWORD [rsp + 1*4], esi
  mov DWORD [rsp + 2*4], edx
  mov DWORD [rsp + 3*4], r8d
  mov DWORD [rsp + 4*4], r9d
  mov DWORD [rsp + 5*4], CREATE_WINDOW_GROUP | (CREATE_WINDOW_BORDER &lt;&lt; 16)
  mov DWORD [rsp + 6*4], ecx
  mov DWORD [rsp + 7*4], X11_FLAG_WIN_BG_COLOR | X11_FLAG_WIN_EVENT
  mov DWORD [rsp + 8*4], 0
  mov DWORD [rsp + 9*4], X11_EVENT_FLAG_KEY_RELEASE | X11_EVENT_FLAG_EXPOSURE


  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, CREATE_WINDOW_PACKET_U32_COUNT*4
  syscall

  cmp rax, CREATE_WINDOW_PACKET_U32_COUNT*4
  jnz die

  add rsp, 12*8

  pop rbp
  ret

; Map a X11 window.
; @param rdi The socket file descriptor.
; @param esi The window id.
x11_map_window:
static x11_map_window:function
  push rbp
  mov rbp, rsp

  sub rsp, 16

  %define X11_OP_REQ_MAP_WINDOW 0x08
  mov DWORD [rsp + 0*4], X11_OP_REQ_MAP_WINDOW | (2&lt;&lt;16)
  mov DWORD [rsp + 1*4], esi

  mov rax, SYSCALL_WRITE
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 2*4
  syscall

  cmp rax, 2*4
  jnz die

  add rsp, 16

  pop rbp
  ret

; Read the X11 server reply.
; @return The message code in al.
x11_read_reply:
static x11_read_reply:function
  push rbp
  mov rbp, rsp

  sub rsp, 32

  mov rax, SYSCALL_READ
  mov rdi, rdi
  lea rsi, [rsp]
  mov rdx, 32
  syscall

  cmp rax, 1
  jle die

  mov al, BYTE [rsp]

  add rsp, 32

  pop rbp
  ret

die:
  mov rax, SYSCALL_EXIT
  mov rdi, 1
  syscall


; Set a file descriptor in non-blocking mode.
; @param rdi The file descriptor.
set_fd_non_blocking:
static set_fd_non_blocking:function
  push rbp
  mov rbp, rsp

  %define F_GETFL 3
  %define F_SETFL 4

  %define O_NONBLOCK 2048

  mov rax, SYSCALL_FCNTL
  mov rdi, rdi 
  mov rsi, F_GETFL
  mov rdx, 0
  syscall

  cmp rax, 0
  jl die

  ; `or` the current file status flag with O_NONBLOCK.
  mov rdx, rax
  or rdx, O_NONBLOCK

  mov rax, SYSCALL_FCNTL
  mov rdi, rdi 
  mov rsi, F_SETFL
  mov rdx, rdx
  syscall

  cmp rax, 0
  jl die

  pop rbp
  ret

; Poll indefinitely messages from the X11 server with poll(2).
; @param rdi The socket file descriptor.
; @param esi The window id.
; @param edx The gc id.
poll_messages:
static poll_messages:function
  push rbp
  mov rbp, rsp

  sub rsp, 32

  %define POLLIN 0x001
  %define POLLPRI 0x002
  %define POLLOUT 0x004
  %define POLLERR  0x008
  %define POLLHUP  0x010
  %define POLLNVAL 0x020

  mov DWORD [rsp + 0*4], edi
  mov DWORD [rsp + 1*4], POLLIN

  mov DWORD [rsp + 16], esi ; window id
  mov DWORD [rsp + 20], edx ; gc id
  mov BYTE [rsp + 24], 0 ; exposed? (boolean)

  .loop:
    mov rax, SYSCALL_POLL
    lea rdi, [rsp]
    mov rsi, 1
    mov rdx, -1
    syscall

    cmp rax, 0
    jle die

    cmp DWORD [rsp + 2*4], POLLERR  
    je die

    cmp DWORD [rsp + 2*4], POLLHUP  
    je die

    mov rdi, [rsp + 0*4]
    call x11_read_reply

    %define X11_EVENT_EXPOSURE 0xc
    cmp eax, X11_EVENT_EXPOSURE
    jnz .received_other_event

    .received_exposed_event:
    mov BYTE [rsp + 24], 1 ; Mark as exposed.

    .received_other_event:

    cmp BYTE [rsp + 24], 1 ; exposed?
    jnz .loop

    .draw_text:
      mov rdi, [rsp + 0*4] ; socket fd
      lea rsi, [hello_world] ; string
      mov edx, 13 ; length
      mov ecx, [rsp + 16] ; window id
      mov r8d, [rsp + 20] ; gc id
      mov r9d, 100 ; x
      shl r9d, 16
      or r9d, 100 ; y
      call x11_draw_text


    jmp .loop


  add rsp, 32
  pop rbp
  ret

; Draw text in a X11 window with server-side text rendering.
; @param rdi The socket file descriptor.
; @param rsi The text string.
; @param edx The text string length in bytes.
; @param ecx The window id.
; @param r8d The gc id.
; @param r9d Packed x and y.
x11_draw_text:
static x11_draw_text:function
  push rbp
  mov rbp, rsp

  sub rsp, 1024

  mov DWORD [rsp + 1*4], ecx ; Store the window id directly in the packet data on the stack.
  mov DWORD [rsp + 2*4], r8d ; Store the gc id directly in the packet data on the stack.
  mov DWORD [rsp + 3*4], r9d ; Store x, y directly in the packet data on the stack.

  mov r8d, edx ; Store the string length in r8 since edx will be overwritten next.
  mov QWORD [rsp + 1024 - 8], rdi ; Store the socket file descriptor on the stack to free the register.

  ; Compute padding and packet u32 count with division and modulo 4.
  mov eax, edx ; Put dividend in eax.
  mov ecx, 4 ; Put divisor in ecx.
  cdq ; Sign extend.
  idiv ecx ; Compute eax / ecx, and put the remainder (i.e. modulo) in edx.
  ; LLVM optimizer magic: `(4-x)%4 == -x &amp; 3`, for some reason.
  neg edx
  and edx, 3
  mov r9d, edx ; Store padding in r9.

  mov eax, r8d 
  add eax, r9d
  shr eax, 2 ; Compute: eax /= 4
  add eax, 4 ; eax now contains the packet u32 count.


  %define X11_OP_REQ_IMAGE_TEXT8 0x4c
  mov DWORD [rsp + 0*4], r8d
  shl DWORD [rsp + 0*4], 8
  or DWORD [rsp + 0*4], X11_OP_REQ_IMAGE_TEXT8
  mov ecx, eax
  shl ecx, 16
  or [rsp + 0*4], ecx

  ; Copy the text string into the packet data on the stack.
  mov rsi, rsi ; Source string in rsi.
  lea rdi, [rsp + 4*4] ; Destination
  cld ; Move forward
  mov ecx, r8d ; String length.
  rep movsb ; Copy.

  mov rdx, rax ; packet u32 count
  imul rdx, 4
  mov rax, SYSCALL_WRITE
  mov rdi, QWORD [rsp + 1024 - 8] ; fd
  lea rsi, [rsp]
  syscall

  cmp rax, rdx
  jnz die

  add rsp, 1024

  pop rbp
  ret

_start:
global _start:function
  call x11_connect_to_server
  mov r15, rax ; Store the socket file descriptor in r15.

  mov rdi, rax
  call x11_send_handshake

  mov r12d, eax ; Store the window root id in r12.

  call x11_next_id
  mov r13d, eax ; Store the gc_id in r13.

  call x11_next_id
  mov r14d, eax ; Store the font_id in r14.

  mov rdi, r15
  mov esi, r14d
  call x11_open_font


  mov rdi, r15
  mov esi, r13d
  mov edx, r12d
  mov ecx, r14d
  call x11_create_gc

  call x11_next_id
  
  mov ebx, eax ; Store the window id in ebx.

  mov rdi, r15 ; socket fd
  mov esi, eax
  mov edx, r12d
  mov ecx, [root_visual_id]
  mov r8d, 200 | (200 &lt;&lt; 16) ; x and y are 200
  %define WINDOW_W 800
  %define WINDOW_H 600
  mov r9d, WINDOW_W | (WINDOW_H &lt;&lt; 16)
  call x11_create_window

  mov rdi, r15 ; socket fd
  mov esi, ebx
  call x11_map_window

  mov rdi, r15 ; socket fd
  call set_fd_non_blocking

  mov rdi, r15 ; socket fd
  mov esi, ebx ; window id
  mov edx, r13d ; gc id
  call poll_messages

  ; The end.
  mov rax, SYSCALL_EXIT
  mov rdi, 0
  syscall
</code></pre>
</div>
</body>
</html>

]]>
    </content>
     </entry>
</feed>
